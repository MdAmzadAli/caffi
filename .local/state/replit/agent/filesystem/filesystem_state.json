{"file_contents":{"hooks/useTheme.ts":{"content":"import { Colors } from \"@/constants/theme\";\nimport { useColorScheme } from \"@/hooks/useColorScheme\";\nimport { useThemeStore, ThemeMode } from \"@/store/themeStore\";\n\nexport function useTheme() {\n  const systemColorScheme = useColorScheme();\n  const { themeMode, setThemeMode, toggleTheme } = useThemeStore();\n  \n  const resolvedScheme = themeMode === \"system\" \n    ? (systemColorScheme ?? \"light\") \n    : themeMode;\n  \n  const isDark = resolvedScheme === \"dark\";\n  const theme = Colors[resolvedScheme];\n\n  return {\n    theme,\n    isDark,\n    themeMode,\n    setThemeMode,\n    toggleTheme,\n  };\n}\n","path":null,"size_bytes":594,"size_tokens":null},"hooks/useColorScheme.ts":{"content":"export { useColorScheme } from \"react-native\";\n","path":null,"size_bytes":47,"size_tokens":null},"screens/SettingsScreen.tsx":{"content":"import React, { useState } from \"react\";\nimport { View, StyleSheet, Pressable, TextInput, Alert, TouchableOpacity } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n} from \"react-native-reanimated\";\nimport { ScreenScrollView } from \"@/components/ScreenScrollView\";\nimport { ScreenHeader } from \"@/components/ScreenHeader\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport {\n  useCaffeineStore,\n  calculateOptimalCaffeine,\n  Gender,\n  CaffeineSensitivity,\n  SleepGoal,\n  AlcoholIntake,\n  Medication,\n} from \"@/store/caffeineStore\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { ThemeMode } from \"@/store/themeStore\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\nimport type { SettingsStackParamList } from \"@/navigation/SettingsStackNavigator\";\n\nconst THEME_LABELS: Record<ThemeMode, string> = {\n  light: \"Light\",\n  dark: \"Dark\",\n  system: \"System\",\n};\n\nconst GENDER_LABELS: Record<Gender, string> = {\n  male: \"Male\",\n  female: \"Female\",\n  other: \"Other\",\n  prefer_not_to_say: \"Prefer not to say\",\n};\n\nconst SENSITIVITY_LABELS: Record<CaffeineSensitivity, string> = {\n  low: \"Low\",\n  medium: \"Medium\",\n  high: \"High\",\n};\n\nconst SLEEP_GOAL_LABELS: Record<SleepGoal, string> = {\n  good_sleep: \"Good Sleep\",\n  normal_sleep: \"Normal Sleep\",\n  insomnia_prone: \"Insomnia-Prone\",\n};\n\nconst ALCOHOL_LABELS: Record<AlcoholIntake, string> = {\n  rare: \"Rare\",\n  sometimes: \"Sometimes\",\n  daily: \"Daily\",\n};\n\nconst MEDICATION_LABELS: Record<Medication, string> = {\n  anxiety_meds: \"Anxiety meds\",\n  adhd_stimulants: \"ADHD stimulants\",\n  ssris: \"SSRIs\",\n  beta_blockers: \"Beta-blockers\",\n  none: \"None\",\n};\n\ntype SettingsScreenProps = {\n  navigation: NativeStackNavigationProp<SettingsStackParamList, \"Settings\">;\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport default function SettingsScreen({ navigation }: SettingsScreenProps) {\n  const { theme, isDark, themeMode, setThemeMode } = useTheme();\n  const { profile, updateProfile, resetData } = useCaffeineStore();\n\n  const [name, setName] = useState(profile.name);\n  const [age, setAge] = useState(profile.age?.toString() || \"\");\n  const [weight, setWeight] = useState(profile.weight?.toString() || \"\");\n  const [dailyLimit, setDailyLimit] = useState(profile.dailyLimit.toString());\n  const [wakeTime, setWakeTime] = useState(profile.wakeTime);\n  const [sleepTime, setSleepTime] = useState(profile.sleepTime);\n\n  const handleSave = () => {\n    const newAge = age ? parseInt(age) : undefined;\n    const newWeight = weight ? parseInt(weight) : undefined;\n    \n    const { optimal, safe } = calculateOptimalCaffeine({\n      age: newAge,\n      weight: newWeight,\n      gender: profile.gender,\n      caffeineSensitivity: profile.caffeineSensitivity,\n      sleepGoal: profile.sleepGoal,\n      alcoholIntake: profile.alcoholIntake,\n      medications: profile.medications,\n      isPregnant: profile.isPregnant,\n      hasHeartCondition: profile.hasHeartCondition,\n      onBirthControl: profile.onBirthControl,\n    });\n\n    updateProfile({\n      name,\n      age: newAge,\n      weight: newWeight,\n      dailyLimit: parseInt(dailyLimit) || safe,\n      wakeTime,\n      sleepTime,\n      optimalCaffeine: optimal,\n      safeCaffeine: safe,\n    });\n  };\n\n  const getMedicationsDisplay = () => {\n    if (!profile.medications || profile.medications.length === 0) {\n      return \"Not set\";\n    }\n    return profile.medications.map((m) => MEDICATION_LABELS[m]).join(\", \");\n  };\n\n  const handleReset = () => {\n    Alert.alert(\n      \"Reset All Data\",\n      \"This will delete all your drink history. This action cannot be undone.\",\n      [\n        { text: \"Cancel\", style: \"cancel\" },\n        {\n          text: \"Reset\",\n          style: \"destructive\",\n          onPress: () => {\n            resetData();\n          },\n        },\n      ],\n    );\n  };\n\n  return (\n    <ScreenScrollView header={<ScreenHeader title=\"Settings\" />}>\n      <View style={styles.section}>\n        <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n          YOUR CAFFEINE LIMITS\n        </ThemedText>\n        <ThemedView elevation={1} style={styles.limitsCard}>\n          <View style={styles.limitItem}>\n            <ThemedText type=\"caption\" muted style={styles.limitLabel}>\n              Optimal Daily\n            </ThemedText>\n            <ThemedText type=\"h3\" style={{ color: Colors.light.accent }}>\n              {profile.optimalCaffeine} mg\n            </ThemedText>\n          </View>\n          <View style={[styles.limitDivider, { backgroundColor: theme.backgroundSecondary }]} />\n          <View style={styles.limitItem}>\n            <ThemedText type=\"caption\" muted style={styles.limitLabel}>\n              Safe Maximum\n            </ThemedText>\n            <ThemedText type=\"h3\">\n              {profile.safeCaffeine} mg\n            </ThemedText>\n          </View>\n        </ThemedView>\n      </View>\n\n      <View style={styles.section}>\n        <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n          PROFILE\n        </ThemedText>\n        <ThemedView elevation={1} style={styles.card}>\n          <SettingsInput\n            label=\"Name\"\n            value={name}\n            onChangeText={setName}\n            placeholder=\"Your name\"\n            onBlur={handleSave}\n          />\n          <View style={styles.divider} />\n          <SettingsInput\n            label=\"Age\"\n            value={age}\n            onChangeText={setAge}\n            placeholder=\"Not set\"\n            keyboardType=\"number-pad\"\n            onBlur={handleSave}\n          />\n          <View style={styles.divider} />\n          <SettingsInput\n            label=\"Weight (kg)\"\n            value={weight}\n            onChangeText={setWeight}\n            placeholder=\"Not set\"\n            keyboardType=\"number-pad\"\n            onBlur={handleSave}\n          />\n          <View style={styles.divider} />\n          <SettingsDisplayRow\n            label=\"Gender\"\n            value={profile.gender ? GENDER_LABELS[profile.gender] : \"Not set\"}\n          />\n          <View style={styles.divider} />\n          <ToggleRow\n            label=\"Pregnant / Nursing\"\n            value={profile.isPregnant}\n            onToggle={() => {\n              const newIsPregnant = !profile.isPregnant;\n              const { optimal, safe } = calculateOptimalCaffeine({\n                ...profile,\n                isPregnant: newIsPregnant,\n              });\n              updateProfile({\n                isPregnant: newIsPregnant,\n                optimalCaffeine: optimal,\n                safeCaffeine: safe,\n              });\n            }}\n          />\n          <View style={styles.divider} />\n          <ToggleRow\n            label=\"Heart Condition\"\n            value={profile.hasHeartCondition}\n            onToggle={() => {\n              const newHasHeartCondition = !profile.hasHeartCondition;\n              const { optimal, safe } = calculateOptimalCaffeine({\n                ...profile,\n                hasHeartCondition: newHasHeartCondition,\n              });\n              updateProfile({\n                hasHeartCondition: newHasHeartCondition,\n                optimalCaffeine: optimal,\n                safeCaffeine: safe,\n              });\n            }}\n          />\n          {profile.gender === \"female\" && (\n            <>\n              <View style={styles.divider} />\n              <ToggleRow\n                label=\"On Birth Control\"\n                value={profile.onBirthControl}\n                onToggle={() => {\n                  const newOnBirthControl = !profile.onBirthControl;\n                  const { optimal, safe } = calculateOptimalCaffeine({\n                    ...profile,\n                    onBirthControl: newOnBirthControl,\n                  });\n                  updateProfile({\n                    onBirthControl: newOnBirthControl,\n                    optimalCaffeine: optimal,\n                    safeCaffeine: safe,\n                  });\n                }}\n              />\n            </>\n          )}\n        </ThemedView>\n      </View>\n\n      <View style={styles.section}>\n        <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n          HEALTH FACTORS\n        </ThemedText>\n        <ThemedView elevation={1} style={styles.card}>\n          <SettingsDisplayRow\n            label=\"Caffeine Sensitivity\"\n            value={profile.caffeineSensitivity ? SENSITIVITY_LABELS[profile.caffeineSensitivity] : \"Not set\"}\n          />\n          <View style={styles.divider} />\n          <SettingsDisplayRow\n            label=\"Sleep Goal\"\n            value={profile.sleepGoal ? SLEEP_GOAL_LABELS[profile.sleepGoal] : \"Not set\"}\n          />\n          <View style={styles.divider} />\n          <SettingsDisplayRow\n            label=\"Alcohol Intake\"\n            value={profile.alcoholIntake ? ALCOHOL_LABELS[profile.alcoholIntake] : \"Not set\"}\n          />\n          <View style={styles.divider} />\n          <SettingsDisplayRow\n            label=\"Medications\"\n            value={getMedicationsDisplay()}\n          />\n        </ThemedView>\n        <ThemedText type=\"caption\" muted style={styles.hint}>\n          These factors affect your caffeine recommendations\n        </ThemedText>\n      </View>\n\n      <View style={styles.section}>\n        <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n          CAFFEINE SETTINGS\n        </ThemedText>\n        <ThemedView elevation={1} style={styles.card}>\n          <SettingsInput\n            label=\"Daily Limit (mg)\"\n            value={dailyLimit}\n            onChangeText={setDailyLimit}\n            placeholder=\"400\"\n            keyboardType=\"number-pad\"\n            onBlur={handleSave}\n          />\n          <View style={styles.divider} />\n          <SettingsInput\n            label=\"Wake Time\"\n            value={wakeTime}\n            onChangeText={setWakeTime}\n            placeholder=\"07:00\"\n            onBlur={handleSave}\n          />\n          <View style={styles.divider} />\n          <SettingsInput\n            label=\"Sleep Time\"\n            value={sleepTime}\n            onChangeText={setSleepTime}\n            placeholder=\"23:00\"\n            onBlur={handleSave}\n          />\n        </ThemedView>\n        <ThemedText type=\"caption\" muted style={styles.hint}>\n          Recommended daily limit: 400mg for adults, 200mg if pregnant\n        </ThemedText>\n      </View>\n\n      <View style={styles.section}>\n        <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n          APPEARANCE\n        </ThemedText>\n        <ThemedView elevation={1} style={styles.card}>\n          <View style={styles.themeRow}>\n            <ThemedText type=\"body\">Theme</ThemedText>\n            <View style={styles.themeOptions}>\n              <TouchableOpacity\n                activeOpacity={0.7}\n                onPress={() => setThemeMode(\"light\")}\n                style={[\n                  styles.themeOption,\n                  {\n                    backgroundColor:\n                      themeMode === \"light\"\n                        ? Colors.light.accent\n                        : theme.backgroundTertiary,\n                  },\n                ]}\n              >\n                <ThemedText\n                  type=\"small\"\n                  style={{\n                    color: themeMode === \"light\" ? \"#FFFFFF\" : theme.text,\n                    fontWeight: themeMode === \"light\" ? \"600\" : \"400\",\n                  }}\n                >\n                  Light\n                </ThemedText>\n              </TouchableOpacity>\n              <TouchableOpacity\n                activeOpacity={0.7}\n                onPress={() => setThemeMode(\"dark\")}\n                style={[\n                  styles.themeOption,\n                  {\n                    backgroundColor:\n                      themeMode === \"dark\"\n                        ? Colors.light.accent\n                        : theme.backgroundTertiary,\n                  },\n                ]}\n              >\n                <ThemedText\n                  type=\"small\"\n                  style={{\n                    color: themeMode === \"dark\" ? \"#FFFFFF\" : theme.text,\n                    fontWeight: themeMode === \"dark\" ? \"600\" : \"400\",\n                  }}\n                >\n                  Dark\n                </ThemedText>\n              </TouchableOpacity>\n              <TouchableOpacity\n                activeOpacity={0.7}\n                onPress={() => setThemeMode(\"system\")}\n                style={[\n                  styles.themeOption,\n                  {\n                    backgroundColor:\n                      themeMode === \"system\"\n                        ? Colors.light.accent\n                        : theme.backgroundTertiary,\n                  },\n                ]}\n              >\n                <ThemedText\n                  type=\"small\"\n                  style={{\n                    color: themeMode === \"system\" ? \"#FFFFFF\" : theme.text,\n                    fontWeight: themeMode === \"system\" ? \"600\" : \"400\",\n                  }}\n                >\n                  System\n                </ThemedText>\n              </TouchableOpacity>\n            </View>\n          </View>\n        </ThemedView>\n      </View>\n\n      <View style={styles.section}>\n        <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n          DATA\n        </ThemedText>\n        <ThemedView elevation={1} style={styles.card}>\n          <SettingsButton\n            icon=\"trash-2\"\n            label=\"Reset All Data\"\n            onPress={handleReset}\n            destructive\n          />\n        </ThemedView>\n      </View>\n\n      <View style={styles.section}>\n        <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n          PRIVACY\n        </ThemedText>\n        <ThemedView elevation={1} style={styles.privacyCard}>\n          <Feather name=\"shield\" size={24} color={Colors.light.success} />\n          <View style={styles.privacyText}>\n            <ThemedText type=\"body\" style={styles.privacyTitle}>\n              Your data is private\n            </ThemedText>\n            <ThemedText type=\"small\" muted>\n              All data is stored locally on your device. We never collect or\n              share your information.\n            </ThemedText>\n          </View>\n        </ThemedView>\n      </View>\n\n      <View style={styles.footer}>\n        <ThemedText type=\"caption\" muted style={styles.version}>\n          Caffi v1.0.0\n        </ThemedText>\n      </View>\n    </ScreenScrollView>\n  );\n}\n\ninterface SettingsInputProps {\n  label: string;\n  value: string;\n  onChangeText: (text: string) => void;\n  placeholder?: string;\n  keyboardType?: \"default\" | \"number-pad\";\n  onBlur?: () => void;\n}\n\nfunction SettingsInput({\n  label,\n  value,\n  onChangeText,\n  placeholder,\n  keyboardType = \"default\",\n  onBlur,\n}: SettingsInputProps) {\n  const { theme } = useTheme();\n\n  return (\n    <View style={styles.inputRow}>\n      <ThemedText type=\"body\">{label}</ThemedText>\n      <TextInput\n        value={value}\n        onChangeText={onChangeText}\n        placeholder={placeholder}\n        placeholderTextColor={theme.textMuted}\n        keyboardType={keyboardType}\n        onBlur={onBlur}\n        style={[styles.input, { color: theme.text }]}\n      />\n    </View>\n  );\n}\n\ninterface ToggleRowProps {\n  label: string;\n  value: boolean;\n  onToggle: () => void;\n}\n\nfunction ToggleRow({ label, value, onToggle }: ToggleRowProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  return (\n    <Pressable style={styles.toggleRow} onPress={onToggle}>\n      <ThemedText type=\"body\">{label}</ThemedText>\n      <AnimatedPressable\n        onPress={onToggle}\n        onPressIn={() => {\n          scale.value = withSpring(0.9);\n        }}\n        onPressOut={() => {\n          scale.value = withSpring(1);\n        }}\n        style={[\n          styles.toggle,\n          {\n            backgroundColor: value\n              ? Colors.light.accent\n              : theme.backgroundSecondary,\n          },\n          animatedStyle,\n        ]}\n      >\n        <Animated.View\n          style={[\n            styles.toggleKnob,\n            {\n              transform: [{ translateX: value ? 20 : 0 }],\n            },\n          ]}\n        />\n      </AnimatedPressable>\n    </Pressable>\n  );\n}\n\ninterface SettingsDisplayRowProps {\n  label: string;\n  value: string;\n}\n\nfunction SettingsDisplayRow({ label, value }: SettingsDisplayRowProps) {\n  const { theme } = useTheme();\n\n  return (\n    <View style={styles.displayRow}>\n      <ThemedText type=\"body\">{label}</ThemedText>\n      <ThemedText type=\"body\" muted style={styles.displayValue}>\n        {value}\n      </ThemedText>\n    </View>\n  );\n}\n\ninterface SettingsButtonProps {\n  icon: keyof typeof Feather.glyphMap;\n  label: string;\n  onPress: () => void;\n  destructive?: boolean;\n}\n\nfunction SettingsButton({\n  icon,\n  label,\n  onPress,\n  destructive,\n}: SettingsButtonProps) {\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={() => {\n        scale.value = withSpring(0.98);\n      }}\n      onPressOut={() => {\n        scale.value = withSpring(1);\n      }}\n      style={[styles.settingsButton, animatedStyle]}\n    >\n      <View style={styles.settingsButtonContent}>\n        <Feather\n          name={icon}\n          size={20}\n          color={destructive ? Colors.light.danger : Colors.light.accent}\n        />\n        <ThemedText\n          type=\"body\"\n          style={[\n            styles.settingsButtonLabel,\n            destructive && { color: Colors.light.danger },\n          ]}\n        >\n          {label}\n        </ThemedText>\n      </View>\n      <Feather name=\"chevron-right\" size={20} color={Colors.light.textMuted} />\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  section: {\n    marginBottom: Spacing.xl,\n  },\n  sectionLabel: {\n    marginBottom: Spacing.sm,\n    marginLeft: Spacing.xs,\n    fontWeight: \"600\",\n    letterSpacing: 0.5,\n  },\n  card: {\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n  },\n  limitsCard: {\n    flexDirection: \"row\",\n    borderRadius: BorderRadius.md,\n    padding: Spacing.lg,\n    alignItems: \"center\",\n  },\n  limitItem: {\n    flex: 1,\n    alignItems: \"center\",\n  },\n  limitLabel: {\n    marginBottom: Spacing.xs,\n    textTransform: \"uppercase\",\n    letterSpacing: 0.5,\n    fontWeight: \"500\",\n  },\n  limitDivider: {\n    width: 1,\n    height: 40,\n    marginHorizontal: Spacing.lg,\n  },\n  inputRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n  },\n  displayRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n  },\n  displayValue: {\n    textAlign: \"right\",\n    maxWidth: \"60%\",\n  },\n  input: {\n    textAlign: \"right\",\n    fontSize: 16,\n    minWidth: 100,\n  },\n  divider: {\n    height: 1,\n    backgroundColor: Colors.light.divider,\n    marginLeft: Spacing.lg,\n  },\n  toggleRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n  },\n  toggle: {\n    width: 50,\n    height: 30,\n    borderRadius: 15,\n    padding: 2,\n  },\n  toggleKnob: {\n    width: 26,\n    height: 26,\n    borderRadius: 13,\n    backgroundColor: \"#FFFFFF\",\n  },\n  hint: {\n    marginTop: Spacing.sm,\n    marginLeft: Spacing.xs,\n  },\n  settingsButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n  },\n  settingsButtonContent: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n  },\n  settingsButtonLabel: {\n    fontWeight: \"500\",\n  },\n  privacyCard: {\n    flexDirection: \"row\",\n    alignItems: \"flex-start\",\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    gap: Spacing.md,\n  },\n  privacyText: {\n    flex: 1,\n  },\n  privacyTitle: {\n    fontWeight: \"600\",\n    marginBottom: Spacing.xs,\n  },\n  footer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing[\"3xl\"],\n  },\n  version: {\n    textAlign: \"center\",\n  },\n  themeRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n  },\n  themeOptions: {\n    flexDirection: \"row\",\n    gap: Spacing.xs,\n  },\n  themeOption: {\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.xs,\n    minHeight: 36,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n});\n","path":null,"size_bytes":21001,"size_tokens":null},"screens/CaffeineBySourceScreen.tsx":{"content":"import React, { useMemo, useState } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Text,\n  Pressable,\n  ScrollView,\n  Dimensions,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useCaffeineStore } from \"@/store/caffeineStore\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\nimport Svg, { G, Path, Circle, Text as SvgText } from \"react-native-svg\";\nimport { DateRangePickerModal, DateRangeOption } from \"@/components/DateRangePickerModal\";\n\ntype ViewMode = \"item\" | \"category\";\n\ninterface DateRange {\n  start: Date;\n  end: Date;\n}\n\nconst CATEGORY_COLORS: Record<string, string> = {\n  coffee: \"#5D4037\",\n  tea: \"#7B8D42\",\n  energy: \"#FF6B35\",\n  soda: \"#E74C3C\",\n  chocolate: \"#8B4513\",\n  custom: \"#9B59B6\",\n};\n\nconst ITEM_COLORS = [\n  \"#5D4037\",\n  \"#FF9800\",\n  \"#4CAF50\",\n  \"#2196F3\",\n  \"#9C27B0\",\n  \"#E91E63\",\n  \"#00BCD4\",\n  \"#795548\",\n  \"#607D8B\",\n  \"#FF5722\",\n];\n\nconst DATE_OPTION_LABELS: Record<DateRangeOption, string> = {\n  today: \"Today\",\n  yesterday: \"Yesterday\",\n  last30: \"Last 30 days\",\n  last90: \"Last 90 days\",\n  custom: \"Custom\",\n};\n\nfunction getDateRange(option: DateRangeOption, customRange?: DateRange): DateRange {\n  const now = new Date();\n  \n  switch (option) {\n    case \"today\": {\n      const start = new Date(now);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(now);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    }\n    case \"yesterday\": {\n      const start = new Date(now);\n      start.setDate(start.getDate() - 1);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    }\n    case \"last30\": {\n      const start = new Date(now);\n      start.setDate(start.getDate() - 30);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(now);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    }\n    case \"last90\": {\n      const start = new Date(now);\n      start.setDate(start.getDate() - 90);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(now);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    }\n    case \"custom\":\n      return customRange || { start: now, end: now };\n    default:\n      return { start: now, end: now };\n  }\n}\n\nexport default function CaffeineBySourceScreen() {\n  const { theme } = useTheme();\n  const navigation = useNavigation();\n  const insets = useSafeAreaInsets();\n  const { entries } = useCaffeineStore();\n  const [viewMode, setViewMode] = useState<ViewMode>(\"item\");\n  const [showDatePicker, setShowDatePicker] = useState(false);\n  const [selectedDateOption, setSelectedDateOption] = useState<DateRangeOption>(\"today\");\n  const [customDateRange, setCustomDateRange] = useState<DateRange | undefined>(undefined);\n\n  const currentDateRange = useMemo(() => {\n    return getDateRange(selectedDateOption, customDateRange);\n  }, [selectedDateOption, customDateRange]);\n\n  const dateButtonLabel = useMemo(() => {\n    if (selectedDateOption === \"custom\" && customDateRange) {\n      const formatDate = (date: Date) => date.toLocaleDateString(\"en-US\", {\n        month: \"short\",\n        day: \"numeric\",\n      });\n      return `${formatDate(customDateRange.start)} - ${formatDate(customDateRange.end)}`;\n    }\n    return DATE_OPTION_LABELS[selectedDateOption];\n  }, [selectedDateOption, customDateRange]);\n\n  const filteredEntries = useMemo(() => {\n    const { start, end } = currentDateRange;\n    return entries.filter((e) => {\n      const t = new Date(e.timestamp);\n      return t >= start && t <= end;\n    });\n  }, [entries, currentDateRange]);\n\n  const chartData = useMemo(() => {\n    if (filteredEntries.length === 0) {\n      return { items: [], total: 0 };\n    }\n\n    const total = filteredEntries.reduce((sum, e) => sum + e.caffeineAmount, 0);\n\n    if (viewMode === \"category\") {\n      const categoryMap: Record<string, { caffeine: number; count: number; items: Record<string, number> }> = {};\n      \n      filteredEntries.forEach((e) => {\n        if (!categoryMap[e.category]) {\n          categoryMap[e.category] = { caffeine: 0, count: 0, items: {} };\n        }\n        categoryMap[e.category].caffeine += e.caffeineAmount;\n        categoryMap[e.category].count += 1;\n        categoryMap[e.category].items[e.name] = (categoryMap[e.category].items[e.name] || 0) + 1;\n      });\n\n      const items = Object.entries(categoryMap)\n        .map(([category, data]) => {\n          const mostFrequent = Object.entries(data.items).sort((a, b) => b[1] - a[1])[0];\n          return {\n            id: category,\n            name: category.charAt(0).toUpperCase() + category.slice(1),\n            caffeine: data.caffeine,\n            count: data.count,\n            percentage: (data.caffeine / total) * 100,\n            color: CATEGORY_COLORS[category] || CATEGORY_COLORS.custom,\n            mostFrequent: mostFrequent ? mostFrequent[0] : undefined,\n            category,\n          };\n        })\n        .sort((a, b) => b.caffeine - a.caffeine);\n\n      return { items, total };\n    } else {\n      const itemMap: Record<string, { caffeine: number; count: number; category: string }> = {};\n      \n      filteredEntries.forEach((e) => {\n        const key = e.drinkId || e.name;\n        if (!itemMap[key]) {\n          itemMap[key] = { caffeine: 0, count: 0, category: e.category };\n        }\n        itemMap[key].caffeine += e.caffeineAmount;\n        itemMap[key].count += 1;\n      });\n\n      const items = Object.entries(itemMap)\n        .map(([id, data], index) => {\n          const entry = filteredEntries.find((e) => (e.drinkId || e.name) === id);\n          return {\n            id,\n            name: entry?.name || id,\n            caffeine: data.caffeine,\n            count: data.count,\n            percentage: (data.caffeine / total) * 100,\n            color: ITEM_COLORS[index % ITEM_COLORS.length],\n            category: data.category,\n          };\n        })\n        .sort((a, b) => b.caffeine - a.caffeine);\n\n      return { items, total };\n    }\n  }, [filteredEntries, viewMode]);\n\n  const handleDateRangeSelect = (option: DateRangeOption, range: DateRange) => {\n    setSelectedDateOption(option);\n    if (option === \"custom\") {\n      setCustomDateRange(range);\n    } else {\n      setCustomDateRange(undefined);\n    }\n  };\n\n  const CHART_SIZE = Dimensions.get(\"window\").width * 0.5;\n  const CENTER = CHART_SIZE / 2;\n  const RADIUS = CHART_SIZE / 2 - 10;\n  const INNER_RADIUS = RADIUS * 0.6;\n\n  const renderDonutChart = () => {\n    if (chartData.items.length === 0) {\n      return (\n        <View style={styles.chartContainer}>\n          <View style={styles.chartWrapper}>\n            <Svg width={CHART_SIZE} height={CHART_SIZE}>\n              <Circle\n                cx={CENTER}\n                cy={CENTER}\n                r={RADIUS}\n                fill={theme.divider}\n              />\n              <Circle\n                cx={CENTER}\n                cy={CENTER}\n                r={INNER_RADIUS}\n                fill={theme.backgroundRoot}\n              />\n            </Svg>\n          </View>\n          <View style={styles.legendContainer}>\n            <View style={styles.legendItem}>\n              <View style={[styles.legendDot, { backgroundColor: theme.divider }]} />\n              <Text style={[styles.legendText, { color: theme.mutedGrey }]}>No data</Text>\n            </View>\n          </View>\n        </View>\n      );\n    }\n\n    let startAngle = -90;\n    const paths: React.ReactNode[] = [];\n    const percentageLabels: React.ReactNode[] = [];\n\n    chartData.items.forEach((item, index) => {\n      const angle = (item.percentage / 100) * 360;\n      const endAngle = startAngle + angle;\n      \n      const startRad = (startAngle * Math.PI) / 180;\n      const endRad = (endAngle * Math.PI) / 180;\n      \n      const x1 = CENTER + RADIUS * Math.cos(startRad);\n      const y1 = CENTER + RADIUS * Math.sin(startRad);\n      const x2 = CENTER + RADIUS * Math.cos(endRad);\n      const y2 = CENTER + RADIUS * Math.sin(endRad);\n      \n      const x3 = CENTER + INNER_RADIUS * Math.cos(endRad);\n      const y3 = CENTER + INNER_RADIUS * Math.sin(endRad);\n      const x4 = CENTER + INNER_RADIUS * Math.cos(startRad);\n      const y4 = CENTER + INNER_RADIUS * Math.sin(startRad);\n      \n      const largeArcFlag = angle > 180 ? 1 : 0;\n      \n      const d = `\n        M ${x1} ${y1}\n        A ${RADIUS} ${RADIUS} 0 ${largeArcFlag} 1 ${x2} ${y2}\n        L ${x3} ${y3}\n        A ${INNER_RADIUS} ${INNER_RADIUS} 0 ${largeArcFlag} 0 ${x4} ${y4}\n        Z\n      `;\n      \n      paths.push(\n        <Path key={item.id} d={d} fill={item.color} />\n      );\n\n      if (item.percentage >= 10) {\n        const midAngle = startAngle + angle / 2;\n        const midRad = (midAngle * Math.PI) / 180;\n        const labelRadius = (RADIUS + INNER_RADIUS) / 2;\n        const labelX = CENTER + labelRadius * Math.cos(midRad);\n        const labelY = CENTER + labelRadius * Math.sin(midRad);\n        \n        percentageLabels.push(\n          <SvgText\n            key={`label-${item.id}`}\n            x={labelX}\n            y={labelY}\n            fill=\"#FFFFFF\"\n            fontSize=\"12\"\n            fontWeight=\"600\"\n            textAnchor=\"middle\"\n            alignmentBaseline=\"middle\"\n          >\n            {item.percentage.toFixed(1)}%\n          </SvgText>\n        );\n      }\n\n      startAngle = endAngle;\n    });\n\n    return (\n      <View style={styles.chartContainer}>\n        <View style={styles.chartWrapper}>\n          <Svg width={CHART_SIZE} height={CHART_SIZE}>\n            <G>{paths}</G>\n            <Circle\n              cx={CENTER}\n              cy={CENTER}\n              r={INNER_RADIUS}\n              fill={theme.backgroundRoot}\n            />\n            {percentageLabels}\n          </Svg>\n        </View>\n        <View style={styles.legendContainer}>\n          {chartData.items.map((item) => (\n            <View key={item.id} style={styles.legendItem}>\n              <View style={[styles.legendDot, { backgroundColor: item.color }]} />\n              <Text style={[styles.legendText, { color: theme.text }]}>{item.name}</Text>\n            </View>\n          ))}\n        </View>\n      </View>\n    );\n  };\n\n  return (\n    <View style={[styles.container, { backgroundColor: theme.backgroundRoot }]}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.md }]}>\n        <Pressable\n          onPress={() => navigation.goBack()}\n          style={styles.backButton}\n          hitSlop={{ top: 12, bottom: 12, left: 12, right: 12 }}\n        >\n          <Feather name=\"arrow-left\" size={24} color={theme.text} />\n        </Pressable>\n        <Text style={[styles.headerTitle, { color: theme.text }]}>Analytics</Text>\n        <View style={styles.headerSpacer} />\n      </View>\n\n      <ScrollView\n        style={styles.scrollView}\n        contentContainerStyle={styles.scrollContent}\n        showsVerticalScrollIndicator={false}\n      >\n        <View style={styles.titleSection}>\n          <Text style={[styles.title, { color: theme.text }]}>Caffeine by source</Text>\n          <Text style={[styles.description, { color: theme.mutedGrey }]}>\n            Where does the caffeine you consume come from?\n          </Text>\n        </View>\n\n        <View style={styles.controlsRow}>\n          <Pressable\n            style={[styles.dateButton, { borderColor: theme.divider }]}\n            onPress={() => setShowDatePicker(true)}\n          >\n            <Text style={[styles.dateButtonText, { color: theme.text }]}>\n              {dateButtonLabel}\n            </Text>\n            <Feather name=\"chevron-down\" size={16} color={theme.text} />\n          </Pressable>\n\n          <Pressable\n            style={[styles.viewModeButton, { backgroundColor: viewMode === \"item\" ? \"#4A4A4A\" : theme.accentGold }]}\n            onPress={() => setViewMode(viewMode === \"item\" ? \"category\" : \"item\")}\n          >\n            <Feather name=\"grid\" size={16} color=\"#FFFFFF\" />\n            <Text style={styles.viewModeButtonText}>\n              {viewMode === \"item\" ? \"Item view\" : \"Category view\"}\n            </Text>\n          </Pressable>\n        </View>\n\n        {renderDonutChart()}\n\n        {chartData.items.length === 0 ? (\n          <View style={styles.noDataContainer}>\n            <Text style={[styles.noDataTitle, { color: theme.text }]}>No data</Text>\n            <Text style={[styles.noDataDescription, { color: theme.mutedGrey }]}>\n              No data for the given time period.\n            </Text>\n          </View>\n        ) : (\n          <View style={styles.itemsList}>\n            {chartData.items.map((item) => (\n              <View\n                key={item.id}\n                style={[styles.itemRow, { borderBottomColor: theme.divider }]}\n              >\n                <View style={styles.itemLeft}>\n                  <View style={[styles.itemImageContainer, { backgroundColor: theme.backgroundSecondary }]}>\n                    {viewMode === \"category\" ? (\n                      <Feather name=\"coffee\" size={24} color={item.color} />\n                    ) : (\n                      <Feather name=\"coffee\" size={24} color={item.color} />\n                    )}\n                  </View>\n                  <View style={styles.itemInfo}>\n                    <Text style={[styles.itemName, { color: theme.text }]}>{item.name}</Text>\n                    <Text style={[styles.itemSubtext, { color: theme.mutedGrey }]}>\n                      {viewMode === \"category\" && (item as any).mostFrequent\n                        ? `Most frequent: ${(item as any).mostFrequent}`\n                        : `${item.count} time${item.count !== 1 ? \"s\" : \"\"}`}\n                    </Text>\n                  </View>\n                </View>\n                <View style={styles.itemRight}>\n                  <Text style={[styles.itemPercentage, { color: theme.text }]}>\n                    {item.percentage.toFixed(1)}%\n                  </Text>\n                  <Text style={[styles.itemCaffeine, { color: theme.mutedGrey }]}>\n                    {item.caffeine}mg\n                  </Text>\n                </View>\n              </View>\n            ))}\n          </View>\n        )}\n      </ScrollView>\n\n      <DateRangePickerModal\n        visible={showDatePicker}\n        onClose={() => setShowDatePicker(false)}\n        onSelectRange={handleDateRangeSelect}\n        selectedOption={selectedDateOption}\n        customRange={customDateRange}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing.lg,\n  },\n  backButton: {\n    width: 24,\n  },\n  headerTitle: {\n    fontSize: 18,\n    fontWeight: \"600\",\n    textAlign: \"center\",\n  },\n  headerSpacer: {\n    width: 24,\n  },\n  scrollView: {\n    flex: 1,\n  },\n  scrollContent: {\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing[\"3xl\"],\n  },\n  titleSection: {\n    marginBottom: Spacing.xl,\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: \"700\",\n    marginBottom: Spacing.sm,\n  },\n  description: {\n    fontSize: 14,\n    lineHeight: 20,\n  },\n  controlsRow: {\n    flexDirection: \"row\",\n    gap: Spacing.md,\n    marginBottom: Spacing.xl,\n  },\n  dateButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.xl,\n    borderWidth: 1,\n  },\n  dateButtonText: {\n    fontSize: 14,\n    fontWeight: \"500\",\n  },\n  viewModeButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.xl,\n    flex: 1,\n    justifyContent: \"center\",\n  },\n  viewModeButtonText: {\n    fontSize: 14,\n    fontWeight: \"600\",\n    color: \"#FFFFFF\",\n  },\n  chartContainer: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    marginBottom: Spacing.xl,\n  },\n  chartWrapper: {\n    flex: 1,\n  },\n  legendContainer: {\n    flex: 1,\n    paddingLeft: Spacing.md,\n  },\n  legendItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.sm,\n  },\n  legendDot: {\n    width: 10,\n    height: 10,\n    borderRadius: 5,\n  },\n  legendText: {\n    fontSize: 14,\n    fontWeight: \"500\",\n  },\n  noDataContainer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing[\"3xl\"],\n  },\n  noDataTitle: {\n    fontSize: 20,\n    fontWeight: \"700\",\n    marginBottom: Spacing.sm,\n  },\n  noDataDescription: {\n    fontSize: 14,\n  },\n  itemsList: {\n    marginTop: Spacing.md,\n  },\n  itemRow: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingVertical: Spacing.lg,\n    borderBottomWidth: StyleSheet.hairlineWidth,\n  },\n  itemLeft: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n    flex: 1,\n  },\n  itemImageContainer: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  itemInfo: {\n    flex: 1,\n  },\n  itemName: {\n    fontSize: 16,\n    fontWeight: \"600\",\n    marginBottom: 2,\n  },\n  itemSubtext: {\n    fontSize: 13,\n  },\n  itemRight: {\n    alignItems: \"flex-end\",\n  },\n  itemPercentage: {\n    fontSize: 16,\n    fontWeight: \"700\",\n  },\n  itemCaffeine: {\n    fontSize: 13,\n  },\n});\n","path":null,"size_bytes":17505,"size_tokens":null},"components/ScreenFlatList.tsx":{"content":"import React from \"react\";\nimport { FlatList, FlatListProps, StyleSheet, View } from \"react-native\";\nimport { SafeAreaView, useSafeAreaInsets } from \"react-native-safe-area-context\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useScreenInsets } from \"@/hooks/useScreenInsets\";\nimport { Spacing } from \"@/constants/theme\";\n\nexport function ScreenFlatList<T>({\n  contentContainerStyle,\n  style,\n  ...flatListProps\n}: FlatListProps<T>) {\n  const { theme } = useTheme();\n  const { paddingTop, paddingBottom, scrollInsetBottom } = useScreenInsets();\n  const insets = useSafeAreaInsets();\n\n  return (\n    <View\n      style={[\n        styles.outerContainer,\n        { backgroundColor: theme.backgroundRoot },\n      ]}\n    >\n      <SafeAreaView\n        style={[\n          styles.safeArea,\n          {\n            paddingTop: insets.top,\n            paddingBottom: insets.bottom,\n          },\n        ]}\n        edges={[]}\n      >\n        <FlatList\n          style={[\n            styles.container,\n            style,\n          ]}\n          contentContainerStyle={[\n            {\n              paddingTop,\n              paddingBottom,\n            },\n            styles.contentContainer,\n            contentContainerStyle,\n          ]}\n          scrollIndicatorInsets={{ bottom: scrollInsetBottom }}\n          {...flatListProps}\n        />\n      </SafeAreaView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  outerContainer: {\n    flex: 1,\n  },\n  safeArea: {\n    flex: 1,\n  },\n  container: {\n    flex: 1,\n  },\n  contentContainer: {\n    paddingHorizontal: Spacing.xl,\n  },\n});\n","path":null,"size_bytes":1586,"size_tokens":null},"navigation/SettingsStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport SettingsScreen from \"@/screens/SettingsScreen\";\nimport CustomDrinkScreen from \"@/screens/CustomDrinkScreen\";\n\nexport type SettingsStackParamList = {\n  Settings: undefined;\n  CustomDrink: undefined;\n};\n\nconst Stack = createNativeStackNavigator<SettingsStackParamList>();\n\nexport default function SettingsStackNavigator() {\n  return (\n    <Stack.Navigator\n      screenOptions={{\n        headerShown: false,\n      }}\n    >\n      <Stack.Screen name=\"Settings\" component={SettingsScreen} />\n      <Stack.Screen name=\"CustomDrink\" component={CustomDrinkScreen} />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":699,"size_tokens":null},"utils/recommendationEngine.ts":{"content":"export interface CaffeineEvent {\n  id: string;\n  name: string;\n  mg: number;\n  timestamp: string;\n  iconUrl?: string;\n}\n\nexport interface RecommendationInputs {\n  consumedTodayMg: number;\n  upcomingHoursUntilBed: number;\n  currentCaffeineMg: number;\n  userSensitivityFactor?: number;\n  optimalDailyMg?: number;\n  halfLifeHours?: number;\n  sleepThresholdMg?: number;\n}\n\nexport interface RecommendationResult {\n  focusDoseMg: number;\n  bestWindowStart: string;\n  bestWindowEnd: string;\n  cutoffTime: string;\n  reasoning: string;\n  focusDoseReasoning: string;\n  bestTimeReasoning: string;\n  cutoffReasoning: string;\n  noSafeDose: boolean;\n}\n\nconst roundTo5 = (n: number): number => Math.round(n / 5) * 5;\n\nconst roundTo15Minutes = (date: Date): Date => {\n  const minutes = date.getMinutes();\n  const roundedMinutes = Math.round(minutes / 15) * 15;\n  const result = new Date(date);\n  result.setMinutes(roundedMinutes, 0, 0);\n  return result;\n};\n\nconst formatTime = (date: Date): string => {\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const ampm = hours >= 12 ? \"PM\" : \"AM\";\n  const hour12 = hours % 12 || 12;\n  const minuteStr = minutes.toString().padStart(2, \"0\");\n  return `${hour12}:${minuteStr} ${ampm}`;\n};\n\nexport const calculateCaffeineAtTime = (\n  events: CaffeineEvent[],\n  targetTime: Date,\n  halfLifeHours: number = 5.5\n): number => {\n  let caffeine = 0;\n\n  events.forEach((event) => {\n    const eventTime = new Date(event.timestamp);\n    if (eventTime <= targetTime) {\n      const hoursElapsed =\n        (targetTime.getTime() - eventTime.getTime()) / (1000 * 60 * 60);\n      const remainingFactor = Math.pow(0.5, hoursElapsed / halfLifeHours);\n      caffeine += event.mg * remainingFactor;\n    }\n  });\n\n  return Math.round(caffeine * 10) / 10;\n};\n\nexport const calculateDecayCurvePoints = (\n  events: CaffeineEvent[],\n  startTime: Date,\n  endTime: Date,\n  halfLifeHours: number = 5.5,\n  pointsPerHour: number = 4\n): { time: Date; mg: number }[] => {\n  const points: { time: Date; mg: number }[] = [];\n  const totalHours =\n    (endTime.getTime() - startTime.getTime()) / (1000 * 60 * 60);\n  const totalPoints = Math.ceil(totalHours * pointsPerHour);\n\n  for (let i = 0; i <= totalPoints; i++) {\n    const time = new Date(\n      startTime.getTime() + (i / totalPoints) * (endTime.getTime() - startTime.getTime())\n    );\n    const mg = calculateCaffeineAtTime(events, time, halfLifeHours);\n    points.push({ time, mg });\n  }\n\n  return points;\n};\n\nexport const hoursNeededToDecay = (\n  currentMg: number,\n  targetMg: number,\n  halfLifeHours: number = 5.5\n): number => {\n  if (currentMg <= targetMg) return 0;\n  if (targetMg <= 0) targetMg = 1;\n  return (halfLifeHours * Math.log(currentMg / targetMg)) / Math.log(2);\n};\n\nexport const calculateRecommendations = (\n  inputs: RecommendationInputs\n): RecommendationResult => {\n  const {\n    consumedTodayMg,\n    upcomingHoursUntilBed,\n    currentCaffeineMg,\n    userSensitivityFactor = 1.0,\n    optimalDailyMg = 200,\n    halfLifeHours = 5.5,\n    sleepThresholdMg = 100,\n  } = inputs;\n\n  const now = new Date();\n\n  const remainingSafeMg = Math.max(\n    0,\n    optimalDailyMg * userSensitivityFactor - consumedTodayMg\n  );\n\n  const noSafeDose = remainingSafeMg <= 0;\n\n  let focusDoseMg = 0;\n  let focusDoseReasoning = \"\";\n\n  if (noSafeDose) {\n    focusDoseMg = 0;\n    focusDoseReasoning = \"You've reached your daily limit. No additional caffeine recommended today.\";\n  } else {\n    const conservativeReserveMg = Math.min(remainingSafeMg, 80);\n    focusDoseMg = roundTo5(Math.min(40, conservativeReserveMg * 0.5));\n    focusDoseReasoning = `Small boost for concentration. ${Math.round(remainingSafeMg)}mg remaining in your daily budget.`;\n  }\n\n  const bedtime = new Date(now.getTime() + upcomingHoursUntilBed * 60 * 60 * 1000);\n  const adjustedSleepThreshold = sleepThresholdMg * userSensitivityFactor;\n\n  const hoursToDecayCurrentToSafe = hoursNeededToDecay(\n    currentCaffeineMg,\n    adjustedSleepThreshold,\n    halfLifeHours\n  );\n  const cutoffDate = roundTo15Minutes(\n    new Date(bedtime.getTime() - hoursToDecayCurrentToSafe * 60 * 60 * 1000)\n  );\n  const cutoffTime = formatTime(cutoffDate);\n  const cutoffReasoning = `Caffeine needs ${Math.round(hoursToDecayCurrentToSafe * 10) / 10} hours to reach safe sleep levels.`;\n\n  let bestWindowEnd: Date;\n  let bestWindowStart: Date;\n\n  if (focusDoseMg > 0) {\n    const hoursForDoseToDecay = hoursNeededToDecay(\n      currentCaffeineMg + focusDoseMg,\n      adjustedSleepThreshold,\n      halfLifeHours\n    );\n    bestWindowEnd = roundTo15Minutes(\n      new Date(bedtime.getTime() - hoursForDoseToDecay * 60 * 60 * 1000)\n    );\n    bestWindowStart = roundTo15Minutes(\n      new Date(\n        Math.max(\n          now.getTime() + 30 * 60 * 1000,\n          bestWindowEnd.getTime() - 2 * 60 * 60 * 1000\n        )\n      )\n    );\n  } else {\n    bestWindowStart = now;\n    bestWindowEnd = now;\n  }\n\n  const bestTimeReasoning =\n    focusDoseMg > 0\n      ? `Your ideal caffeine window for best sleep quality.`\n      : `No safe window available today.`;\n\n  return {\n    focusDoseMg,\n    bestWindowStart: formatTime(bestWindowStart),\n    bestWindowEnd: formatTime(bestWindowEnd),\n    cutoffTime,\n    reasoning: noSafeDose\n      ? \"Daily limit reached. Focus on hydration and rest.\"\n      : `Stay within ${Math.round(remainingSafeMg)}mg for optimal energy without sleep impact.`,\n    focusDoseReasoning,\n    bestTimeReasoning,\n    cutoffReasoning,\n    noSafeDose,\n  };\n};\n\nexport const getHoursUntilBedtime = (bedtimeString: string): number => {\n  const now = new Date();\n  const [hours, minutes] = bedtimeString.split(\":\").map(Number);\n  const bedtime = new Date();\n  bedtime.setHours(hours, minutes, 0, 0);\n  if (bedtime <= now) {\n    bedtime.setDate(bedtime.getDate() + 1);\n  }\n  return (bedtime.getTime() - now.getTime()) / (1000 * 60 * 60);\n};\n","path":null,"size_bytes":5862,"size_tokens":null},"navigation/StatsStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport StatisticsScreen from \"@/screens/StatisticsScreen\";\nimport CaffeineIntakeDetailScreen from \"@/screens/CaffeineIntakeDetailScreen\";\nimport CaffeineBySourceScreen from \"@/screens/CaffeineBySourceScreen\";\nimport SleepTargetScreen from \"@/screens/SleepTargetScreen\";\nimport ConsumptionByTimeScreen from \"@/screens/ConsumptionByTimeScreen\";\n\nexport type StatsStackParamList = {\n  Statistics: undefined;\n  CaffeineIntakeDetail: undefined;\n  CaffeineBySource: undefined;\n  SleepTarget: undefined;\n  ConsumptionByTime: undefined;\n};\n\nconst Stack = createNativeStackNavigator<StatsStackParamList>();\n\nexport default function StatsStackNavigator() {\n  return (\n    <Stack.Navigator\n      screenOptions={{\n        headerShown: false,\n      }}\n    >\n      <Stack.Screen name=\"Statistics\" component={StatisticsScreen} />\n      <Stack.Screen name=\"CaffeineIntakeDetail\" component={CaffeineIntakeDetailScreen} />\n      <Stack.Screen name=\"CaffeineBySource\" component={CaffeineBySourceScreen} />\n      <Stack.Screen name=\"SleepTarget\" component={SleepTargetScreen} />\n      <Stack.Screen name=\"ConsumptionByTime\" component={ConsumptionByTimeScreen} />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":1277,"size_tokens":null},"components/CaffeineChart.tsx":{"content":"import React, { useMemo } from \"react\";\nimport { View, StyleSheet, Dimensions } from \"react-native\";\nimport Svg, { Rect, Line, Text as SvgText } from \"react-native-svg\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing } from \"@/constants/theme\";\nimport type { DrinkEntry } from \"@/store/caffeineStore\";\n\ninterface CaffeineChartProps {\n  entries: DrinkEntry[];\n  timeRange: \"day\" | \"week\";\n  dailyLimit: number;\n}\n\nconst CHART_HEIGHT = 120;\nconst BAR_RADIUS = 4;\n\nexport function CaffeineChart({\n  entries,\n  timeRange,\n  dailyLimit,\n}: CaffeineChartProps) {\n  const { theme } = useTheme();\n  const chartWidth = Dimensions.get(\"window\").width - Spacing.xl * 4;\n\n  const chartData = useMemo(() => {\n    if (timeRange === \"day\") {\n      const hourlyData: { hour: number; mg: number }[] = [];\n      for (let h = 0; h < 24; h++) {\n        hourlyData.push({ hour: h, mg: 0 });\n      }\n\n      entries.forEach((entry) => {\n        const hour = new Date(entry.timestamp).getHours();\n        hourlyData[hour].mg += entry.caffeineAmount;\n      });\n\n      return hourlyData.filter((d) => d.hour >= 6 && d.hour <= 22);\n    } else {\n      const dailyData: { day: string; mg: number }[] = [];\n      const days = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n\n      for (let i = 6; i >= 0; i--) {\n        const date = new Date();\n        date.setDate(date.getDate() - i);\n        date.setHours(0, 0, 0, 0);\n\n        const nextDate = new Date(date);\n        nextDate.setDate(nextDate.getDate() + 1);\n\n        const dayEntries = entries.filter((e) => {\n          const entryDate = new Date(e.timestamp);\n          return entryDate >= date && entryDate < nextDate;\n        });\n\n        const totalMg = dayEntries.reduce((sum, e) => sum + e.caffeineAmount, 0);\n        dailyData.push({ day: days[date.getDay()], mg: totalMg });\n      }\n\n      return dailyData;\n    }\n  }, [entries, timeRange]);\n\n  const maxValue = Math.max(...chartData.map((d) => d.mg), dailyLimit);\n  const barWidth =\n    timeRange === \"day\"\n      ? chartWidth / chartData.length - 4\n      : chartWidth / 7 - 8;\n\n  if (entries.length === 0) {\n    return (\n      <View style={[styles.emptyContainer, { height: CHART_HEIGHT }]}>\n        <ThemedText type=\"small\" muted>\n          No data for this period\n        </ThemedText>\n      </View>\n    );\n  }\n\n  return (\n    <View style={styles.container}>\n      <Svg width={chartWidth} height={CHART_HEIGHT + 30}>\n        <Line\n          x1={0}\n          y1={(1 - dailyLimit / maxValue) * CHART_HEIGHT}\n          x2={chartWidth}\n          y2={(1 - dailyLimit / maxValue) * CHART_HEIGHT}\n          stroke={Colors.light.danger}\n          strokeWidth={1}\n          strokeDasharray=\"4,4\"\n          opacity={0.5}\n        />\n\n        {chartData.map((item, index) => {\n          const barHeight = (item.mg / maxValue) * CHART_HEIGHT;\n          const x =\n            timeRange === \"day\"\n              ? index * (chartWidth / chartData.length) + 2\n              : index * (chartWidth / 7) + 4;\n          const y = CHART_HEIGHT - barHeight;\n\n          const isOverLimit = item.mg > dailyLimit;\n          const barColor = isOverLimit\n            ? Colors.light.danger\n            : item.mg > dailyLimit * 0.8\n              ? Colors.light.warning\n              : Colors.light.accent;\n\n          return (\n            <React.Fragment key={index}>\n              <Rect\n                x={x}\n                y={y}\n                width={barWidth}\n                height={Math.max(barHeight, 2)}\n                fill={barColor}\n                rx={BAR_RADIUS}\n                ry={BAR_RADIUS}\n              />\n              <SvgText\n                x={x + barWidth / 2}\n                y={CHART_HEIGHT + 20}\n                fontSize={10}\n                fill={theme.textMuted}\n                textAnchor=\"middle\"\n              >\n                {\"hour\" in item ? `${item.hour}` : item.day}\n              </SvgText>\n            </React.Fragment>\n          );\n        })}\n      </Svg>\n\n      <View style={styles.legend}>\n        <View style={styles.legendItem}>\n          <View\n            style={[styles.legendDot, { backgroundColor: Colors.light.accent }]}\n          />\n          <ThemedText type=\"caption\" muted>\n            Under limit\n          </ThemedText>\n        </View>\n        <View style={styles.legendItem}>\n          <View\n            style={[styles.legendDot, { backgroundColor: Colors.light.danger }]}\n          />\n          <ThemedText type=\"caption\" muted>\n            Over limit\n          </ThemedText>\n        </View>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    alignItems: \"center\",\n  },\n  emptyContainer: {\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  legend: {\n    flexDirection: \"row\",\n    justifyContent: \"center\",\n    gap: Spacing.lg,\n    marginTop: Spacing.md,\n  },\n  legendItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.xs,\n  },\n  legendDot: {\n    width: 8,\n    height: 8,\n    borderRadius: 4,\n  },\n});\n","path":null,"size_bytes":5072,"size_tokens":null},"store/caffeineStore.ts":{"content":"import { useState, useCallback, useEffect } from \"react\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport caffeineDB from \"./caffeineDB.json\";\n\nexport interface DrinkEntry {\n  id: string;\n  drinkId: string;\n  name: string;\n  caffeineAmount: number;\n  servingSize: number;\n  category: string;\n  timestamp: Date;\n  notes?: string;\n  isFavorite?: boolean;\n  imageUri?: string;\n}\n\nexport interface DrinkItem {\n  id: string;\n  name: string;\n  category: \"coffee\" | \"tea\" | \"energy\" | \"soda\" | \"chocolate\" | \"custom\";\n  caffeinePer100ml: number;\n  defaultServingMl: number;\n  sizes?: { name: string; ml: number }[];\n  icon: string;\n  imageUri?: string;\n}\n\nexport type Gender = \"male\" | \"female\" | \"other\" | \"prefer_not_to_say\";\nexport type CaffeineSensitivity = \"low\" | \"medium\" | \"high\";\nexport type SleepGoal = \"good_sleep\" | \"normal_sleep\" | \"insomnia_prone\";\nexport type AlcoholIntake = \"rare\" | \"sometimes\" | \"daily\";\nexport type AgeRange = \"under_18\" | \"18_to_60\" | \"over_60\";\nexport type Medication = \"anxiety_panic\" | \"adhd_medication\" | \"insomnia_medication\" | \"acid_reflux\" | \"high_blood_pressure\" | \"depression_treatment\" | \"none\";\n\nexport interface UserProfile {\n  name: string;\n  ageRange?: AgeRange;\n  weight?: number;\n  caffeineSensitivity?: CaffeineSensitivity;\n  alcoholIntake?: AlcoholIntake;\n  medications?: Medication[];\n  wakeTime: string;\n  sleepTime: string;\n  dailyLimit: number;\n  optimalCaffeine: number;\n  safeCaffeine: number;\n  isPregnant: boolean;\n  hasHeartCondition: boolean;\n  hasCompletedOnboarding: boolean;\n}\n\nexport interface CaffeineCalculationInputs {\n  age?: number;\n  ageRange?: AgeRange;\n  weight?: number;\n  gender?: Gender;\n  caffeineSensitivity?: CaffeineSensitivity;\n  sleepGoal?: SleepGoal;\n  alcoholIntake?: AlcoholIntake;\n  medications?: Medication[];\n  isPregnant?: boolean;\n  hasHeartCondition?: boolean;\n  onBirthControl?: boolean;\n}\n\nexport function calculateOptimalCaffeine(inputs: CaffeineCalculationInputs): { optimal: number; safe: number } {\n  let optimal = 200;\n  let safe = 400;\n\n  if (inputs.weight) {\n    optimal = inputs.weight * 3;\n    optimal = Math.min(optimal, 200);\n    safe = Math.min(inputs.weight * 6, 400);\n  }\n\n  if (inputs.ageRange) {\n    switch (inputs.ageRange) {\n      case \"over_60\":\n        optimal *= 0.8;\n        break;\n      case \"under_18\":\n        optimal = 80;\n        safe = 100;\n        break;\n    }\n  }\n\n  if (inputs.isPregnant) {\n    optimal = Math.min(optimal, 200);\n    safe = Math.min(safe, 200);\n    optimal *= 0.5;\n  }\n\n  if (inputs.hasHeartCondition) {\n    optimal = Math.min(optimal, 100);\n    safe = Math.min(safe, 200);\n  }\n\n  if (inputs.caffeineSensitivity) {\n    switch (inputs.caffeineSensitivity) {\n      case \"low\":\n        optimal *= 1.1;\n        break;\n      case \"high\":\n        optimal *= 0.5;\n        break;\n    }\n  }\n\n  if (inputs.alcoholIntake) {\n    switch (inputs.alcoholIntake) {\n      case \"sometimes\":\n        optimal *= 0.9;\n        break;\n      case \"daily\":\n        optimal *= 0.85;\n        break;\n    }\n  }\n\n  if (inputs.medications && inputs.medications.length > 0 && !inputs.medications.includes(\"none\")) {\n    const medicationMultipliers: Record<Medication, number> = {\n      anxiety_panic: 0.6,\n      adhd_medication: 0.6,\n      insomnia_medication: 0.6,\n      acid_reflux: 0.75,\n      high_blood_pressure: 0.7,\n      depression_treatment: 0.7,\n      none: 1,\n    };\n\n    let lowestMultiplier = 1;\n    inputs.medications.forEach((med) => {\n      const multiplier = medicationMultipliers[med] || 1;\n      if (multiplier < lowestMultiplier) {\n        lowestMultiplier = multiplier;\n      }\n    });\n    optimal *= lowestMultiplier;\n  }\n\n  optimal = Math.round(optimal);\n  optimal = Math.max(optimal, 50);\n  optimal = Math.min(optimal, 200);\n  safe = Math.round(safe);\n\n  return { optimal, safe };\n}\n\nconst CAFFEINE_HALF_LIFE_HOURS = 5;\n\nconst CATEGORY_MAP: Record<string, DrinkItem[\"category\"]> = {\n  \"Coffee\": \"coffee\",\n  \"Tea\": \"tea\",\n  \"Energy Drinks\": \"energy\",\n  \"Soft Drinks\": \"soda\",\n  \"Chocolate\": \"chocolate\",\n};\n\nconst ICON_MAP: Record<DrinkItem[\"category\"], string> = {\n  coffee: \"coffee\",\n  tea: \"droplet\",\n  energy: \"zap\",\n  soda: \"droplet\",\n  chocolate: \"square\",\n  custom: \"plus\",\n};\n\nexport const DRINK_DATABASE: DrinkItem[] = Object.entries(caffeineDB).flatMap(\n  ([categoryName, drinks]) => {\n    const category = CATEGORY_MAP[categoryName];\n    if (!category) return [];\n    return drinks.map((drink: { name: string; serving_size_ml: number; caffeine_mg_per_ml: number | null }) => ({\n      id: drink.name.toLowerCase().replace(/[^a-z0-9]+/g, \"-\"),\n      name: drink.name,\n      category,\n      caffeinePer100ml: parseFloat(((drink.caffeine_mg_per_ml ?? 0) * 100).toFixed(3)),\n      defaultServingMl: drink.serving_size_ml,\n      sizes: [{ name: \"Default\", ml: drink.serving_size_ml }],\n      icon: ICON_MAP[category],\n    }));\n  }\n);\n\nconst STORAGE_KEYS = {\n  PROFILE: \"@caffi_profile\",\n  ENTRIES: \"@caffi_entries\",\n  CUSTOM_DRINKS: \"@caffi_custom_drinks\",\n  FAVORITES: \"@caffi_favorites\",\n};\n\nconst DEFAULT_PROFILE: UserProfile = {\n  name: \"\",\n  dailyLimit: 400,\n  optimalCaffeine: 200,\n  safeCaffeine: 400,\n  wakeTime: \"07:00\",\n  sleepTime: \"23:00\",\n  isPregnant: false,\n  hasHeartCondition: false,\n  hasCompletedOnboarding: false,\n};\n\nlet globalEntries: DrinkEntry[] = [];\nlet globalProfile: UserProfile = { ...DEFAULT_PROFILE };\nlet globalCustomDrinks: DrinkItem[] = [];\nlet globalFavorites: string[] = [];\nlet globalListeners: (() => void)[] = [];\nlet isInitialized = false;\n\nconst notifyListeners = () => {\n  globalListeners.forEach((listener) => listener());\n};\n\nconst saveToStorage = async () => {\n  try {\n    await AsyncStorage.multiSet([\n      [STORAGE_KEYS.PROFILE, JSON.stringify(globalProfile)],\n      [STORAGE_KEYS.ENTRIES, JSON.stringify(globalEntries)],\n      [STORAGE_KEYS.CUSTOM_DRINKS, JSON.stringify(globalCustomDrinks)],\n      [STORAGE_KEYS.FAVORITES, JSON.stringify(globalFavorites)],\n    ]);\n  } catch (error) {\n    console.error(\"Error saving to storage:\", error);\n  }\n};\n\nconst loadFromStorage = async () => {\n  try {\n    const results = await AsyncStorage.multiGet([\n      STORAGE_KEYS.PROFILE,\n      STORAGE_KEYS.ENTRIES,\n      STORAGE_KEYS.CUSTOM_DRINKS,\n      STORAGE_KEYS.FAVORITES,\n    ]);\n\n    const profileData = results[0][1];\n    const entriesData = results[1][1];\n    const customDrinksData = results[2][1];\n    const favoritesData = results[3][1];\n\n    if (profileData) {\n      globalProfile = JSON.parse(profileData);\n    }\n    if (entriesData) {\n      globalEntries = JSON.parse(entriesData).map((entry: any) => ({\n        ...entry,\n        timestamp: new Date(entry.timestamp),\n      }));\n    }\n    if (customDrinksData) {\n      globalCustomDrinks = JSON.parse(customDrinksData);\n    }\n    if (favoritesData) {\n      globalFavorites = JSON.parse(favoritesData);\n    }\n\n    isInitialized = true;\n    notifyListeners();\n  } catch (error) {\n    console.error(\"Error loading from storage:\", error);\n    isInitialized = true;\n  }\n};\n\nloadFromStorage();\n\nexport function useCaffeineStore() {\n  const [, setUpdate] = useState(0);\n\n  const subscribe = useCallback(() => {\n    const listener = () => setUpdate((n) => n + 1);\n    globalListeners.push(listener);\n    return () => {\n      globalListeners = globalListeners.filter((l) => l !== listener);\n    };\n  }, []);\n\n  useState(() => {\n    const unsubscribe = subscribe();\n    return unsubscribe;\n  });\n\n  const addEntry = useCallback(\n    (\n      drink: DrinkItem,\n      servingSize: number,\n      notes?: string,\n      isFavorite?: boolean,\n      timestamp?: Date,\n    ) => {\n      const caffeineAmount = Math.round(\n        (drink.caffeinePer100ml * servingSize) / 100,\n      );\n      const entry: DrinkEntry = {\n        id: Date.now().toString(),\n        drinkId: drink.id,\n        name: drink.name,\n        caffeineAmount,\n        servingSize,\n        category: drink.category,\n        timestamp: timestamp || new Date(),\n        notes,\n        isFavorite,\n        imageUri: drink.imageUri,\n      };\n      globalEntries = [entry, ...globalEntries];\n      if (isFavorite && !globalFavorites.includes(drink.id)) {\n        globalFavorites = [...globalFavorites, drink.id];\n      }\n      notifyListeners();\n      saveToStorage();\n      return entry;\n    },\n    [],\n  );\n\n  const deleteEntry = useCallback((id: string) => {\n    globalEntries = globalEntries.filter((e) => e.id !== id);\n    notifyListeners();\n    saveToStorage();\n  }, []);\n\n  const updateEntry = useCallback((id: string, updates: Partial<DrinkEntry>) => {\n    globalEntries = globalEntries.map((entry) => {\n      if (entry.id === id) {\n        return { ...entry, ...updates };\n      }\n      return entry;\n    });\n    notifyListeners();\n    saveToStorage();\n  }, []);\n\n  const updateProfile = useCallback((updates: Partial<UserProfile>) => {\n    globalProfile = { ...globalProfile, ...updates };\n    notifyListeners();\n    saveToStorage();\n  }, []);\n\n  const addCustomDrink = useCallback((drink: Omit<DrinkItem, \"id\">) => {\n    const newDrink: DrinkItem = {\n      ...drink,\n      id: `custom-${Date.now()}`,\n    };\n    globalCustomDrinks = [...globalCustomDrinks, newDrink];\n    notifyListeners();\n    saveToStorage();\n    return newDrink;\n  }, []);\n\n  const updateCustomDrink = useCallback((id: string, updates: Partial<DrinkItem>) => {\n    globalCustomDrinks = globalCustomDrinks.map((drink) => {\n      if (drink.id === id) {\n        return { ...drink, ...updates };\n      }\n      return drink;\n    });\n    notifyListeners();\n    saveToStorage();\n  }, []);\n\n  const toggleFavorite = useCallback((drinkId: string) => {\n    if (globalFavorites.includes(drinkId)) {\n      globalFavorites = globalFavorites.filter((id) => id !== drinkId);\n    } else {\n      globalFavorites = [...globalFavorites, drinkId];\n    }\n    notifyListeners();\n    saveToStorage();\n  }, []);\n\n  const getTodayEntries = useCallback(() => {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    return globalEntries.filter((e) => new Date(e.timestamp) >= today);\n  }, []);\n\n  const getTodayCaffeine = useCallback(() => {\n    return getTodayEntries().reduce((sum, e) => sum + e.caffeineAmount, 0);\n  }, [getTodayEntries]);\n\n  const getActiveCaffeine = useCallback(() => {\n    const now = new Date();\n    let activeCaffeine = 0;\n\n    globalEntries.forEach((entry) => {\n      const hoursElapsed =\n        (now.getTime() - new Date(entry.timestamp).getTime()) / (1000 * 60 * 60);\n      if (hoursElapsed < 24) {\n        const remainingFactor = Math.pow(\n          0.5,\n          hoursElapsed / CAFFEINE_HALF_LIFE_HOURS,\n        );\n        activeCaffeine += entry.caffeineAmount * remainingFactor;\n      }\n    });\n\n    return Math.round(activeCaffeine);\n  }, []);\n\n  const getCaffeineAtTime = useCallback(\n    (targetTime: Date) => {\n      let caffeine = 0;\n\n      globalEntries.forEach((entry) => {\n        const entryTime = new Date(entry.timestamp);\n        if (entryTime <= targetTime) {\n          const hoursElapsed =\n            (targetTime.getTime() - entryTime.getTime()) / (1000 * 60 * 60);\n          const remainingFactor = Math.pow(\n            0.5,\n            hoursElapsed / CAFFEINE_HALF_LIFE_HOURS,\n          );\n          caffeine += entry.caffeineAmount * remainingFactor;\n        }\n      });\n\n      return Math.round(caffeine);\n    },\n    [],\n  );\n\n  const getSleepImpact = useCallback(() => {\n    const sleepHour = parseInt(globalProfile.sleepTime.split(\":\")[0]);\n    const now = new Date();\n    const sleepTime = new Date();\n    sleepTime.setHours(sleepHour, 0, 0, 0);\n    if (sleepTime <= now) {\n      sleepTime.setDate(sleepTime.getDate() + 1);\n    }\n\n    const caffeineAtSleep = getCaffeineAtTime(sleepTime);\n\n    if (caffeineAtSleep < 50) return { level: \"good\", message: \"Sleep friendly\" };\n    if (caffeineAtSleep < 100)\n      return { level: \"warning\", message: \"May affect sleep\" };\n    return { level: \"danger\", message: \"Will impact sleep\" };\n  }, [getCaffeineAtTime]);\n\n  const getLastDrink = useCallback(() => {\n    if (globalEntries.length === 0) return null;\n    return globalEntries[0];\n  }, []);\n\n  const getEntriesForDateRange = useCallback(\n    (startDate: Date, endDate: Date) => {\n      return globalEntries.filter((e) => {\n        const date = new Date(e.timestamp);\n        return date >= startDate && date <= endDate;\n      });\n    },\n    [],\n  );\n\n  const getAllDrinks = useCallback(() => {\n    return [...DRINK_DATABASE, ...globalCustomDrinks];\n  }, []);\n\n  const getFavoriteDrinks = useCallback(() => {\n    const allDrinks = getAllDrinks();\n    return allDrinks.filter((d) => globalFavorites.includes(d.id));\n  }, [getAllDrinks]);\n\n  const resetData = useCallback(() => {\n    globalEntries = [];\n    globalCustomDrinks = [];\n    globalFavorites = [];\n    notifyListeners();\n    saveToStorage();\n  }, []);\n\n  return {\n    entries: globalEntries,\n    profile: globalProfile,\n    customDrinks: globalCustomDrinks,\n    favorites: globalFavorites,\n    isInitialized,\n    addEntry,\n    deleteEntry,\n    updateEntry,\n    updateProfile,\n    addCustomDrink,\n    updateCustomDrink,\n    toggleFavorite,\n    getTodayEntries,\n    getTodayCaffeine,\n    getActiveCaffeine,\n    getCaffeineAtTime,\n    getSleepImpact,\n    getLastDrink,\n    getEntriesForDateRange,\n    getAllDrinks,\n    getFavoriteDrinks,\n    resetData,\n  };\n}\n","path":null,"size_bytes":13343,"size_tokens":null},"components/ConsumptionList.tsx":{"content":"import React, { useMemo } from \"react\";\nimport { View, StyleSheet, Text, Image, Pressable, SectionList } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { Spacing } from \"@/constants/theme\";\nimport { DrinkEntry } from \"@/store/caffeineStore\";\nimport { useTheme } from \"@/hooks/useTheme\";\n\ninterface ConsumptionListProps {\n  entries: DrinkEntry[];\n  onEntryPress?: (entry: DrinkEntry) => void;\n  onDeleteEntry?: (id: string) => void;\n}\n\ninterface SectionData {\n  title: string;\n  data: DrinkEntry[];\n  dateKey: string;\n}\n\nconst CATEGORY_ICONS: Record<string, string> = {\n  coffee: \"\",\n  tea: \"\",\n  energy: \"\",\n  soda: \"\",\n  chocolate: \"\",\n  custom: \"\",\n};\n\nconst CATEGORY_IMAGES: Record<string, any> = {\n  coffee: require(\"@/attached_assets/generated_images/caffi_app_icon_coffee_cup.png\"),\n};\n\nfunction formatDateHeader(date: Date): string {\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  const yesterday = new Date(today);\n  yesterday.setDate(yesterday.getDate() - 1);\n  \n  const entryDate = new Date(date);\n  entryDate.setHours(0, 0, 0, 0);\n  \n  if (entryDate.getTime() === today.getTime()) {\n    return \"Today\";\n  } else if (entryDate.getTime() === yesterday.getTime()) {\n    return \"Yesterday\";\n  } else {\n    const days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n    const dayName = days[entryDate.getDay()];\n    const day = entryDate.getDate().toString().padStart(2, \"0\");\n    const month = (entryDate.getMonth() + 1).toString().padStart(2, \"0\");\n    const year = entryDate.getFullYear();\n    return `${dayName.toUpperCase()}, ${day}/${month}/${year}`;\n  }\n}\n\nfunction formatTime(timestamp: Date): string {\n  const date = new Date(timestamp);\n  return date.toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  });\n}\n\nfunction getEntryIcon(category: string): string {\n  return CATEGORY_ICONS[category] || \"\";\n}\n\nexport function ConsumptionList({\n  entries,\n  onEntryPress,\n  onDeleteEntry,\n}: ConsumptionListProps) {\n  const { theme } = useTheme();\n\n  const sections = useMemo(() => {\n    if (entries.length === 0) return [];\n\n    // Group entries by date\n    const grouped = new Map<string, DrinkEntry[]>();\n    \n    entries.forEach((entry) => {\n      const entryDate = new Date(entry.timestamp);\n      entryDate.setHours(0, 0, 0, 0);\n      const dateKey = entryDate.toISOString();\n      \n      if (!grouped.has(dateKey)) {\n        grouped.set(dateKey, []);\n      }\n      grouped.get(dateKey)!.push(entry);\n    });\n\n    // Convert to sections array and sort by date (newest first)\n    const sectionsArray: SectionData[] = Array.from(grouped.entries())\n      .map(([dateKey, data]) => {\n        // Sort entries within each section by time (newest first)\n        const sortedData = [...data].sort(\n          (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n        );\n        return {\n          title: formatDateHeader(new Date(dateKey)),\n          data: sortedData,\n          dateKey,\n        };\n      })\n      .sort((a, b) => {\n        // Sort sections by date (newest first)\n        return new Date(b.dateKey).getTime() - new Date(a.dateKey).getTime();\n      });\n\n    return sectionsArray;\n  }, [entries]);\n\n  const renderItem = ({ item }: { item: DrinkEntry }) => {\n    return (\n      <Pressable\n        style={({ pressed }) => [\n          styles.entryRow,\n          {\n            backgroundColor: theme.backgroundSecondary,\n          },\n          pressed && { backgroundColor: theme.backgroundTertiary },\n        ]}\n        onPress={() => onEntryPress?.(item)}\n      >\n        <View style={[styles.iconContainer, { backgroundColor: theme.backgroundTertiary }]}>\n          {CATEGORY_IMAGES[item.category] ? (\n            <Image\n              source={CATEGORY_IMAGES[item.category]}\n              style={styles.entryImage}\n            />\n          ) : (\n            <Text style={styles.entryEmoji}>{getEntryIcon(item.category)}</Text>\n          )}\n        </View>\n\n        <View style={styles.entryInfo}>\n          <Text style={[styles.entryName, { color: theme.darkBrown }]}>\n            {item.name}\n          </Text>\n          <Text style={[styles.entryTime, { color: theme.mutedGrey }]}>\n            {formatTime(item.timestamp)}\n          </Text>\n        </View>\n\n        <Text style={[styles.entryMg, { color: theme.darkBrown }]}>\n          {item.caffeineAmount} mg\n        </Text>\n      </Pressable>\n    );\n  };\n\n  const renderSectionHeader = ({ section }: { section: SectionData }) => {\n    return (\n      <View style={[styles.sectionHeader, { backgroundColor: theme.bg }]}>\n        <Text style={[styles.sectionHeaderText, { color: theme.mutedGrey }]}>\n          {section.title}\n        </Text>\n      </View>\n    );\n  };\n\n  if (entries.length === 0) {\n    return (\n      <View style={[styles.emptyContainer, { backgroundColor: theme.backgroundDefault }]}>\n        <Feather name=\"coffee\" size={32} color={theme.mutedGrey} />\n        <Text style={[styles.emptyText, { color: theme.mutedGrey }]}>No drinks logged</Text>\n        <Text style={[styles.emptySubtext, { color: theme.mutedGrey }]}>Tap + to add your first drink</Text>\n      </View>\n    );\n  }\n\n  return (\n    <SectionList\n      sections={sections}\n      renderItem={renderItem}\n      renderSectionHeader={renderSectionHeader}\n      keyExtractor={(item) => item.id}\n      stickySectionHeadersEnabled={true}\n      contentContainerStyle={styles.listContent}\n      style={styles.list}\n      showsVerticalScrollIndicator={false}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  list: {\n    flex: 1,\n  },\n  listContent: {\n    paddingBottom: Spacing.xl,\n  },\n  sectionHeader: {\n    paddingVertical: Spacing.sm,\n    paddingHorizontal: Spacing.lg,\n  },\n  sectionHeaderText: {\n    fontSize: 12,\n    fontWeight: \"600\",\n    letterSpacing: 0.5,\n  },\n  entryRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingVertical: Spacing.md,\n    paddingHorizontal: Spacing.lg,\n    width: \"100%\",\n  },\n  iconContainer: {\n    width: 44,\n    height: 44,\n    borderRadius: 8,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginRight: Spacing.md,\n    overflow: \"hidden\",\n  },\n  entryImage: {\n    width: 44,\n    height: 44,\n    borderRadius: 8,\n  },\n  entryEmoji: {\n    fontSize: 22,\n  },\n  entryInfo: {\n    flex: 1,\n  },\n  entryName: {\n    fontSize: 15,\n    fontWeight: \"700\",\n    marginBottom: 2,\n  },\n  entryTime: {\n    fontSize: 12,\n    fontWeight: \"400\",\n  },\n  entryMg: {\n    fontSize: 16,\n    fontWeight: \"700\",\n  },\n  emptyContainer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing[\"3xl\"],\n    gap: Spacing.sm,\n  },\n  emptyText: {\n    fontSize: 16,\n    marginTop: Spacing.sm,\n  },\n  emptySubtext: {\n    fontSize: 13,\n  },\n});\n","path":null,"size_bytes":6791,"size_tokens":null},"components/CollapsibleInfoCards.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Pressable } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  withSpring,\n  interpolate,\n  Extrapolation,\n} from \"react-native-reanimated\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { RecommendationCards } from \"./RecommendationCards\";\nimport { RecommendationResult } from \"@/utils/recommendationEngine\";\nimport { InfoCardResult } from \"@/utils/infocardLogic\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing } from \"@/constants/theme\";\n\ninterface CollapsibleInfoCardsProps {\n  recommendations?: RecommendationResult;\n  infoCard?: InfoCardResult;\n  scrollY: Animated.SharedValue<number>;\n  collapseThreshold: number;\n  onExpand: () => void;\n  graphHeight: number;\n  headerHeight: number;\n  topInset: number;\n}\n\nexport function CollapsibleInfoCards({\n  recommendations,\n  infoCard,\n  scrollY,\n  collapseThreshold,\n  onExpand,\n  graphHeight,\n  headerHeight,\n  topInset,\n}: CollapsibleInfoCardsProps) {\n  const { theme } = useTheme();\n  \n  // Calculate position at bottom right of graph area\n  const expandButtonTop = headerHeight + graphHeight + topInset - 40; // Position near bottom of graph\n\n  // Animate collapse based on scroll position\n  const containerStyle = useAnimatedStyle(() => {\n    const progress = Math.min(scrollY.value / collapseThreshold, 1);\n    \n    return {\n      height: interpolate(\n        progress,\n        [0, 1],\n        [120, 0], // Collapse from 120px to 0\n        Extrapolation.CLAMP\n      ),\n      opacity: interpolate(\n        progress,\n        [0, 0.5, 1],\n        [1, 0.5, 0],\n        Extrapolation.CLAMP\n      ),\n      overflow: \"hidden\" as const,\n    };\n  });\n\n  const expandButtonStyle = useAnimatedStyle(() => {\n    const progress = Math.min(scrollY.value / collapseThreshold, 1);\n    \n    return {\n      opacity: interpolate(\n        progress,\n        [0.3, 1],\n        [0, 1],\n        Extrapolation.CLAMP\n      ),\n      transform: [\n        {\n          translateX: interpolate(\n            progress,\n            [0.3, 1],\n            [20, 0],\n            Extrapolation.CLAMP\n          ),\n        },\n      ],\n      position: \"absolute\" as const,\n      top: expandButtonTop,\n      right: Spacing.lg,\n      zIndex: 100,\n    };\n  });\n\n  return (\n    <View style={styles.wrapper}>\n      <Animated.View style={[styles.cardsContainer, containerStyle]}>\n        <View style={styles.cardsWrapper}>\n          <RecommendationCards \n            recommendations={recommendations}\n            infoCard={infoCard}\n          />\n        </View>\n      </Animated.View>\n    </View>\n  );\n}\n\n// Separate expand button component to position outside scroll view\ninterface ExpandButtonProps {\n  scrollY: Animated.SharedValue<number>;\n  collapseThreshold: number;\n  onExpand: () => void;\n  graphHeight: number;\n  headerHeight: number;\n  topInset: number;\n}\n\nexport function ExpandButton({\n  scrollY,\n  collapseThreshold,\n  onExpand,\n  graphHeight,\n  headerHeight,\n  topInset,\n}: ExpandButtonProps) {\n  const { theme } = useTheme();\n  \n  // Position at bottom right of graph area (just below graph)\n  const expandButtonTop = headerHeight + graphHeight + topInset - 18; // Center of button at graph bottom\n\n  const expandButtonStyle = useAnimatedStyle(() => {\n    const progress = Math.min(scrollY.value / collapseThreshold, 1);\n    \n    return {\n      opacity: interpolate(\n        progress,\n        [0.3, 1],\n        [0, 1],\n        Extrapolation.CLAMP\n      ),\n      transform: [\n        {\n          translateX: interpolate(\n            progress,\n            [0.3, 1],\n            [20, 0],\n            Extrapolation.CLAMP\n          ),\n        },\n      ],\n    };\n  });\n\n  return (\n    <Animated.View \n      style={[\n        {\n          position: \"absolute\" as const,\n          top: expandButtonTop,\n          right: Spacing.lg,\n          zIndex: 100,\n        },\n        expandButtonStyle\n      ]} \n      pointerEvents=\"box-none\"\n    >\n      <Pressable\n        onPress={onExpand}\n        style={({ pressed }) => [\n          styles.expandButton,\n          {\n            backgroundColor: theme.backgroundSecondary,\n            opacity: pressed ? 0.8 : 1,\n          },\n        ]}\n      >\n        <Feather name=\"chevron-down\" size={20} color={theme.text} />\n      </Pressable>\n    </Animated.View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  wrapper: {\n    position: \"relative\",\n    // marginBottom: Spacing.xl,\n  },\n  cardsContainer: {\n    overflow: \"hidden\",\n  },\n  cardsWrapper: {\n    paddingHorizontal: Spacing.lg,\n  },\n  expandButton: {\n    width: 36,\n    height: 36,\n    borderRadius: 18,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3,\n  },\n});\n\n","path":null,"size_bytes":4792,"size_tokens":null},"hooks/useColorScheme.web.ts":{"content":"import { useEffect, useState } from \"react\";\nimport { useColorScheme as useRNColorScheme } from \"react-native\";\n\n/**\n * To support static rendering, this value needs to be re-calculated on the client side for web\n */\nexport function useColorScheme() {\n  const [hasHydrated, setHasHydrated] = useState(false);\n\n  useEffect(() => {\n    setHasHydrated(true);\n  }, []);\n\n  const colorScheme = useRNColorScheme();\n\n  if (hasHydrated) {\n    return colorScheme;\n  }\n\n  return \"light\";\n}\n","path":null,"size_bytes":480,"size_tokens":null},"navigation/MainTabNavigator.tsx":{"content":"import React, { useState } from \"react\";\nimport { createBottomTabNavigator } from \"@react-navigation/bottom-tabs\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { BlurView } from \"expo-blur\";\nimport { Platform, StyleSheet, View, Pressable } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n} from \"react-native-reanimated\";\nimport { useNavigation, NavigationProp } from \"@react-navigation/native\";\nimport HomeStackNavigator from \"@/navigation/HomeStackNavigator\";\nimport HistoryStackNavigator from \"@/navigation/HistoryStackNavigator\";\nimport SettingsStackNavigator from \"@/navigation/SettingsStackNavigator\";\nimport StatsStackNavigator from \"@/navigation/StatsStackNavigator\";\nimport AddDrinkModal from \"@/screens/AddDrinkModal\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius, Shadows } from \"@/constants/theme\";\n\nexport type MainTabParamList = {\n  HomeTab: undefined;\n  StatsTab: undefined;\n  AddTab: undefined;\n  HistoryTab: undefined;\n  SettingsTab: undefined;\n};\n\nconst Tab = createBottomTabNavigator<MainTabParamList>();\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nfunction FABPlaceholder() {\n  return <View style={{ flex: 1 }} />;\n}\n\ninterface FABProps {\n  onPress: () => void;\n}\n\nfunction FloatingActionButton({ onPress }: FABProps) {\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.9, { damping: 15, stiffness: 200 });\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1, { damping: 15, stiffness: 200 });\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      style={[styles.fab, animatedStyle]}\n    >\n      <View style={styles.fabInner}>\n        <Feather name=\"plus\" size={28} color=\"#FFFFFF\" />\n      </View>\n    </AnimatedPressable>\n  );\n}\n\n\nexport default function MainTabNavigator() {\n  const { theme, isDark } = useTheme();\n  const [showAddModal, setShowAddModal] = useState(false);\n  const navigation = useNavigation<NavigationProp<MainTabParamList>>();\n\n  const handleNavigateToCustomDrink = () => {\n    navigation.navigate(\"SettingsTab\", {\n      screen: \"CustomDrink\",\n    } as any);\n  };\n\n  return (\n    <>\n      <Tab.Navigator\n        initialRouteName=\"HomeTab\"\n        screenOptions={{\n          tabBarActiveTintColor: Colors.light.accent,\n          tabBarInactiveTintColor: theme.tabIconDefault,\n          tabBarStyle: {\n            position: \"absolute\",\n            backgroundColor: Platform.select({\n              ios: \"transparent\",\n              android: theme.backgroundRoot,\n            }),\n            borderTopWidth: 0,\n            elevation: 0,\n            height: Platform.OS === \"ios\" ? 88 : 64,\n            paddingBottom: Platform.OS === \"ios\" ? 28 : 8,\n          },\n          tabBarBackground: () =>\n            Platform.OS === \"ios\" ? (\n              <BlurView\n                intensity={100}\n                tint={isDark ? \"dark\" : \"light\"}\n                style={StyleSheet.absoluteFill}\n              />\n            ) : null,\n          headerShown: false,\n          tabBarLabelStyle: {\n            fontSize: 11,\n            fontWeight: \"500\",\n          },\n          tabBarShowLabel: false,\n        }}\n      >\n        <Tab.Screen\n          name=\"HomeTab\"\n          component={HomeStackNavigator}\n          options={{\n            title: \"Home\",\n            tabBarIcon: ({ color, size }) => (\n              <Feather name=\"message-circle\" size={size} color={color} />\n            ),\n          }}\n        />\n        <Tab.Screen\n          name=\"StatsTab\"\n          component={StatsStackNavigator}\n          options={{\n            title: \"Stats\",\n            tabBarIcon: ({ color, size }) => (\n              <Feather name=\"bar-chart-2\" size={size} color={color} />\n            ),\n          }}\n        />\n        <Tab.Screen\n          name=\"AddTab\"\n          component={FABPlaceholder}\n          options={{\n            title: \"\",\n            tabBarButton: () => (\n              <FloatingActionButton onPress={() => setShowAddModal(true)} />\n            ),\n          }}\n        />\n        <Tab.Screen\n          name=\"HistoryTab\"\n          component={HistoryStackNavigator}\n          options={{\n            title: \"History\",\n            tabBarIcon: ({ color, size }) => (\n              <Feather name=\"layers\" size={size} color={color} />\n            ),\n          }}\n        />\n        <Tab.Screen\n          name=\"SettingsTab\"\n          component={SettingsStackNavigator}\n          options={{\n            title: \"Settings\",\n            tabBarIcon: ({ color, size }) => (\n              <Feather name=\"settings\" size={size} color={color} />\n            ),\n          }}\n        />\n      </Tab.Navigator>\n\n      <AddDrinkModal\n        visible={showAddModal}\n        onClose={() => setShowAddModal(false)}\n        onNavigateToCustomDrink={handleNavigateToCustomDrink}\n      />\n    </>\n  );\n}\n\nconst styles = StyleSheet.create({\n  fab: {\n    position: \"absolute\",\n    top: -20,\n    alignSelf: \"center\",\n    width: 64,\n    height: 64,\n    borderRadius: 32,\n    ...Shadows.large,\n  },\n  fabInner: {\n    flex: 1,\n    backgroundColor: Colors.light.accent,\n    borderRadius: 32,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n});\n","path":null,"size_bytes":5428,"size_tokens":null},"components/ThemedText.tsx":{"content":"import { Text, type TextProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Typography } from \"@/constants/theme\";\n\nexport type ThemedTextProps = TextProps & {\n  lightColor?: string;\n  darkColor?: string;\n  type?: \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"body\" | \"small\" | \"caption\" | \"link\";\n  muted?: boolean;\n};\n\nexport function ThemedText({\n  style,\n  lightColor,\n  darkColor,\n  type = \"body\",\n  muted = false,\n  ...rest\n}: ThemedTextProps) {\n  const { theme, isDark } = useTheme();\n\n  const getColor = () => {\n    if (isDark && darkColor) {\n      return darkColor;\n    }\n\n    if (!isDark && lightColor) {\n      return lightColor;\n    }\n\n    if (muted) {\n      return theme.textMuted;\n    }\n\n    if (type === \"link\") {\n      return theme.link;\n    }\n\n    return theme.text;\n  };\n\n  const getTypeStyle = () => {\n    switch (type) {\n      case \"h1\":\n        return Typography.h1;\n      case \"h2\":\n        return Typography.h2;\n      case \"h3\":\n        return Typography.h3;\n      case \"h4\":\n        return Typography.h4;\n      case \"body\":\n        return Typography.body;\n      case \"small\":\n        return Typography.small;\n      case \"caption\":\n        return Typography.caption;\n      case \"link\":\n        return Typography.link;\n      default:\n        return Typography.body;\n    }\n  };\n\n  return (\n    <Text style={[{ color: getColor() }, getTypeStyle(), style]} {...rest} />\n  );\n}\n","path":null,"size_bytes":1410,"size_tokens":null},"components/ScreenHeader.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Image, Pressable } from \"react-native\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing } from \"@/constants/theme\";\nimport { Feather } from \"@expo/vector-icons\";\n\ninterface ScreenHeaderProps {\n  title: string;\n  showIcon?: boolean;\n  showBackButton?: boolean;\n}\n\nexport function ScreenHeader({ title, showIcon = false, showBackButton = false }: ScreenHeaderProps) {\n  const { theme } = useTheme();\n  const navigation = useNavigation();\n\n  return (\n    <View style={[styles.header, { backgroundColor: theme.backgroundRoot }]}>\n      {showBackButton && (\n        <Pressable\n          onPress={() => navigation.goBack()}\n          style={styles.backButton}\n        >\n          <Feather name=\"chevron-left\" size={24} color={theme.text} />\n        </Pressable>\n      )}\n      <View style={styles.titleContainer}>\n        {showIcon && (\n          <Image\n            source={require(\"../assets/images/icon.png\")}\n            style={styles.icon}\n            resizeMode=\"contain\"\n          />\n        )}\n        <ThemedText style={[styles.title, { color: theme.text }]}>\n          {title}\n        </ThemedText>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    minHeight: 44,\n  },\n  backButton: {\n    marginRight: Spacing.sm,\n    padding: Spacing.xs,\n  },\n  titleContainer: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    flex: 1,\n    justifyContent: \"center\",\n  },\n  icon: {\n    width: 28,\n    height: 28,\n    marginRight: Spacing.sm,\n    borderRadius: 6,\n  },\n  title: {\n    fontSize: 17,\n    fontWeight: \"600\",\n  },\n});\n\n","path":null,"size_bytes":1860,"size_tokens":null},"screens/HistoryScreen.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Text, Pressable, ScrollView, Image } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\nimport { HistoryStackParamList } from \"@/navigation/HistoryStackNavigator\";\n\ntype NavigationProp = NativeStackNavigationProp<HistoryStackParamList>;\n\ninterface Article {\n  id: string;\n  title: string;\n  summary: string;\n  image: string;\n  content: string;\n  references: string[];\n}\n\ninterface Section {\n  title: string;\n  articles: Article[];\n}\n\nconst SECTIONS: Section[] = [\n  {\n    title: \"Caffeine\",\n    articles: [\n      {\n        id: \"caf-1\",\n        title: \"Understanding How Caffeine Works in Your Body\",\n        summary: \"A look at how this popular stimulant affects your brain and nervous system.\",\n        image: \"https://images.unsplash.com/photo-1514432324607-a09d9b4aefdd?w=400&h=400&fit=crop&q=80\",\n        content: \"Caffeine is one of the most widely consumed psychoactive substances in the world, found naturally in coffee beans, tea leaves, and cacao pods. When you consume caffeine, it travels through your bloodstream to your brain within about 15 to 45 minutes. Once there, it blocks adenosine receptors, which are responsible for making you feel tired and sleepy. By blocking these receptors, caffeine prevents the natural buildup of drowsiness that occurs throughout the day.\\n\\nThis blocking action also triggers the release of other neurotransmitters like dopamine and norepinephrine, which contribute to improved mood, alertness, and concentration. Your heart rate may increase slightly, and your blood pressure can rise temporarily. The liver metabolizes caffeine, with a half-life of about 5 to 6 hours in most adults, meaning half of the caffeine you consume is still active in your system hours later.\\n\\nCaffeine also stimulates the release of adrenaline, preparing your body for physical exertion. This is why many athletes use caffeine as a performance enhancer before workouts or competitions. Additionally, caffeine can increase thermogenesis, the process by which your body generates heat and burns calories. Research suggests that regular moderate consumption may offer protective benefits against certain neurodegenerative conditions.\\n\\nHowever, individual responses to caffeine vary significantly based on genetics, tolerance levels, and overall health. Some people metabolize caffeine quickly and feel minimal effects, while others are highly sensitive and may experience jitters, anxiety, or sleep disturbances from even small amounts. Understanding your personal response to caffeine can help you optimize your intake for maximum benefit with minimal side effects.\",\n        references: [\n          \"https://www.ncbi.nlm.nih.gov/books/NBK519490/\",\n          \"https://www.efsa.europa.eu/en/efsajournal/pub/4102\",\n          \"https://www.mayoclinic.org/healthy-lifestyle/nutrition-and-healthy-eating/in-depth/caffeine/art-20045678\",\n        ],\n      },\n      {\n        id: \"caf-2\",\n        title: \"Daily Caffeine Limits: What Science Recommends\",\n        summary: \"Guidelines for safe consumption across different age groups and conditions.\",\n        image: \"https://images.unsplash.com/photo-1495474472287-4d71bcdd2085?w=400&h=400&fit=crop&q=80\",\n        content: \"Health authorities around the world have established guidelines for safe caffeine consumption based on extensive research. For healthy adults, the general consensus is that up to 400 milligrams per day is considered safe, which translates to approximately four standard cups of brewed coffee. This amount has been shown to provide cognitive benefits without significantly increasing health risks for most people.\\n\\nPregnant and breastfeeding women are advised to limit their intake to no more than 200 milligrams daily. This reduced limit exists because caffeine crosses the placenta and can affect fetal development, potentially leading to lower birth weight or other complications. The developing fetus lacks the enzymes needed to metabolize caffeine efficiently, making it particularly vulnerable to its effects.\\n\\nTeenagers aged 12 to 18 should consume no more than 100 milligrams of caffeine per day, roughly equivalent to one cup of coffee. Children under 12 are advised to avoid caffeine entirely or limit intake to very small amounts. Their developing nervous systems are more sensitive to stimulants, and caffeine can interfere with sleep patterns crucial for growth and development.\\n\\nPeople with certain health conditions need to be especially cautious. Those with heart arrhythmias, anxiety disorders, or sleep problems may need to significantly reduce or eliminate caffeine. If you experience symptoms like rapid heartbeat, persistent anxiety, or chronic insomnia, consulting with a healthcare provider about your caffeine intake is recommended. Individual tolerance varies widely, so paying attention to your body's signals is essential for determining your optimal intake level.\",\n        references: [\n          \"https://www.fda.gov/regulatory-information/search-fda-guidance-documents/guidance-industry-highly-concentrated-caffeine-dietary-supplements\",\n          \"https://publications.aap.org/pediatrics/article/133/3/386/32320/Trends-in-Caffeine-Intake-Among-US-Children-and\",\n          \"https://www.efsa.europa.eu/en/press/news/150527\",\n        ],\n      },\n      {\n        id: \"caf-3\",\n        title: \"Caffeine Withdrawal: Symptoms and Management\",\n        summary: \"What happens when you suddenly stop consuming caffeine and how to cope.\",\n        image: \"https://images.unsplash.com/photo-1509042239860-f550ce710b93?w=400&h=400&fit=crop&q=80\",\n        content: \"Caffeine withdrawal is a recognized medical condition that occurs when regular caffeine consumers suddenly reduce or stop their intake. Symptoms typically begin 12 to 24 hours after the last caffeine dose and can last anywhere from two to nine days. The severity of withdrawal depends on the amount typically consumed and individual sensitivity levels.\\n\\nThe most common withdrawal symptom is headache, which affects more than half of people who quit caffeine abruptly. These headaches occur because caffeine causes blood vessels in the brain to constrict, and when caffeine is removed, the vessels dilate, causing pain. Fatigue and drowsiness are also extremely common, as the body suddenly loses its artificial energy boost and must readjust to functioning without the stimulant.\\n\\nMood changes including irritability, difficulty concentrating, and even mild depression can occur during withdrawal. Some people experience flu-like symptoms such as nausea, muscle aches, and general malaise. These symptoms happen because the brain has adapted to the presence of caffeine and needs time to recalibrate its normal functioning without it.\\n\\nTo minimize withdrawal symptoms, experts recommend gradually reducing caffeine intake over one to two weeks rather than stopping abruptly. Cutting your daily intake by about 10 to 25 percent each week allows your body to adjust slowly. Staying well-hydrated, getting adequate sleep, and engaging in light exercise can also help ease the transition. Some people find that switching to lower-caffeine beverages like green tea can provide a gentler step-down approach.\",\n        references: [\n          \"https://www.ncbi.nlm.nih.gov/books/NBK430790/\",\n          \"https://health.clevelandclinic.org/how-to-quit-caffeine\",\n          \"https://pubmed.ncbi.nlm.nih.gov/15448977/\",\n        ],\n      },\n    ],\n  },\n  {\n    title: \"Coffee\",\n    articles: [\n      {\n        id: \"cof-1\",\n        title: \"The Journey of Coffee: From Ethiopian Forests to Your Cup\",\n        summary: \"Exploring the rich history and global spread of coffee cultivation.\",\n        image: \"https://images.unsplash.com/photo-1447933601403-0c6688de566e?w=400&h=400&fit=crop&q=80\",\n        content: \"Coffee has a fascinating origin story that begins in the ancient forests of Ethiopia. Legend tells of a goat herder named Kaldi who noticed his goats becoming unusually energetic after eating berries from a certain tree. This discovery, believed to have occurred around the 9th century, marked the beginning of humanity's relationship with coffee. The berries were initially consumed as food, mixed with animal fat to create energy-boosting snacks.\\n\\nBy the 15th century, coffee cultivation had spread to Yemen, where Sufi monks began brewing the beans into a beverage to help them stay awake during lengthy nighttime prayers. The port city of Mocha became a major trading hub for coffee, giving its name to the chocolate-coffee flavor combination we know today. Coffeehouses, known as qahveh khaneh, emerged throughout the Arabian Peninsula and became centers of social activity, music, and intellectual discussion.\\n\\nCoffee reached Europe in the 17th century, arriving first in Venice through trade routes. Initially met with suspicion and even called the bitter invention of Satan by some clergy, coffee eventually gained papal approval and quickly became popular across the continent. London's first coffeehouse opened in 1652, and these establishments became known as penny universities because for the price of a cup, one could engage in stimulating conversation and learn about current events.\\n\\nColonial powers spread coffee cultivation to their territories around the world. The Dutch brought coffee to Java, the French to the Caribbean, and eventually cultivation reached Brazil and Central America. Today, over 70 countries produce coffee, with Brazil remaining the world's largest producer. The journey from those Ethiopian forests has made coffee the second most traded commodity globally after oil, consumed by billions of people every day.\",\n        references: [\n          \"https://www.aboutcoffee.org/origins/history-of-coffee/\",\n          \"https://www.britannica.com/topic/history-of-coffee\",\n          \"https://www.smithsonianmag.com/arts-culture/the-long-history-of-the-espresso-machine-126012814/\",\n        ],\n      },\n      {\n        id: \"cof-2\",\n        title: \"Arabica vs Robusta: Comparing Coffee Bean Varieties\",\n        summary: \"Understanding the key differences between the world's two main coffee species.\",\n        image: \"https://images.unsplash.com/photo-1559056199-641a0ac8b55e?w=400&h=400&fit=crop&q=80\",\n        content: \"The coffee world is dominated by two main species: Arabica and Robusta, which together account for virtually all commercial coffee production. Arabica, scientifically known as Coffea arabica, represents about 60 to 70 percent of global production and is prized for its complex, nuanced flavors. It originated in the highlands of Ethiopia and thrives at higher altitudes between 2,000 and 6,000 feet, requiring specific growing conditions with steady rainfall and moderate temperatures.\\n\\nRobusta, or Coffea canephora, makes up the remaining 30 to 40 percent of production. As its name suggests, this species is more robust and hardy, capable of growing at lower altitudes and withstanding harsher conditions. Robusta plants are more resistant to diseases and pests, partly due to their higher caffeine content, which acts as a natural insecticide. Vietnam is the world's largest producer of Robusta beans.\\n\\nThe flavor profiles of these two species differ significantly. Arabica beans tend to have a sweeter, softer taste with notes of fruit, berries, and even floral undertones. They contain more natural sugars and higher acidity, contributing to their complexity. Robusta beans, in contrast, have a stronger, harsher, and more bitter taste, often described as earthy or woody. They contain nearly twice the caffeine of Arabica beans.\\n\\nBeyond these two main species, coffee enthusiasts are increasingly interested in lesser-known varieties like Liberica and Excelsa. Liberica, grown primarily in the Philippines and Malaysia, has a distinctive smoky, woody flavor with floral notes. The choice between coffee types ultimately depends on personal preference, brewing method, and whether you prioritize flavor complexity or caffeine content. Many espresso blends combine both Arabica and Robusta to achieve a balance of flavor and crema.\",\n        references: [\n          \"https://sca.coffee/research/coffee-plants-of-the-world\",\n          \"https://worldcoffeeresearch.org/resources/coffee-varieties-poster\",\n          \"https://ico.org/\",\n        ],\n      },\n      {\n        id: \"cof-3\",\n        title: \"How Roasting Transforms the Coffee Bean\",\n        summary: \"The science behind light, medium, and dark roasts and their flavor profiles.\",\n        image: \"https://images.unsplash.com/photo-1442512595331-e89e73853f31?w=400&h=400&fit=crop&q=80\",\n        content: \"The roasting process is where green coffee beans transform into the aromatic brown beans we recognize. This transformation involves complex chemical reactions that develop the flavors, aromas, and colors we associate with coffee. Raw green beans are dense and have a grassy, almost hay-like smell, nothing like the rich aroma of roasted coffee. The roasting process unlocks hundreds of aromatic compounds that create coffee's characteristic flavor.\\n\\nDuring roasting, beans undergo the Maillard reaction, the same chemical process that browns bread crust and seared meat. As temperatures rise above 300 degrees Fahrenheit, sugars and amino acids combine to create new flavor compounds. Caramelization of sugars adds sweetness and complexity. At around 400 degrees, beans experience first crack, an audible popping sound as steam escapes, marking the transition to a light roast.\\n\\nLight roasts preserve more of the bean's original characteristics, including higher acidity and fruity or floral notes. They retain more caffeine than darker roasts and showcase the unique flavors of different growing regions. Medium roasts balance origin characteristics with roast flavors, offering a more rounded profile with reduced acidity. This level is often preferred for everyday drinking and reveals notes of chocolate, nuts, and caramel.\\n\\nDark roasts are taken past the second crack, where oils begin to appear on the bean's surface. These roasts emphasize bold, smoky, and sometimes bitter flavors while muting the bean's origin characteristics. Contrary to popular belief, dark roasts actually contain slightly less caffeine than lighter roasts because the roasting process breaks down caffeine molecules. The choice of roast level is largely a matter of personal preference, though certain brewing methods pair better with specific roast levels.\",\n        references: [\n          \"https://sca.coffee/research/botany\",\n          \"https://www.ncausa.org/About-Coffee/Coffee-Roasts-Guide\",\n          \"https://www.sciencedirect.com/science/article/abs/pii/S0308814612001173\",\n        ],\n      },\n    ],\n  },\n  {\n    title: \"Energy Drinks\",\n    articles: [\n      {\n        id: \"eng-1\",\n        title: \"What Goes Into Energy Drinks: A Complete Breakdown\",\n        summary: \"Examining the key ingredients found in popular energy beverages.\",\n        image: \"https://images.unsplash.com/photo-1527960471264-932f39eb5846?w=400&h=400&fit=crop&q=80\",\n        content: \"Energy drinks have become a multi-billion dollar industry, particularly popular among young adults and athletes. Understanding what goes into these beverages is essential for making informed consumption choices. The primary active ingredient in most energy drinks is caffeine, typically ranging from 80 to 320 milligrams per can, with some products containing even more. For context, a standard cup of coffee contains about 95 milligrams.\\n\\nTaurine is another common ingredient, an amino acid naturally found in meat, fish, and dairy. Energy drinks often contain 750 to 1,000 milligrams of taurine per serving. While taurine plays important roles in the body including supporting neurological development and regulating mineral levels in cells, research on its effects when combined with high doses of caffeine is still evolving.\\n\\nMany energy drinks contain significant amounts of sugar, sometimes as much as 54 grams per can, which equals about 13 teaspoons. This sugar provides quick energy but can lead to blood sugar spikes followed by crashes. Some brands offer sugar-free versions that use artificial sweeteners instead. B vitamins are commonly added, though most people already get adequate amounts through their regular diet.\\n\\nGuarana and yerba mate are often included as additional sources of caffeine, though their caffeine content may not be separately listed on labels. This means the total caffeine in a drink could be higher than what appears on the nutrition facts. Other additives include ginseng, glucuronolactone, and L-carnitine. While these ingredients are marketed as enhancing the energizing effects, scientific evidence supporting their benefits when added to energy drinks is limited.\",\n        references: [\n          \"https://www.health.harvard.edu/nutrition/are-energy-drinks-bad-for-you\",\n          \"https://www.nccih.nih.gov/health/energy-drinks\",\n          \"https://www.efsa.europa.eu/en/efsajournal/pub/4102\",\n        ],\n      },\n      {\n        id: \"eng-2\",\n        title: \"Energy Drinks and Heart Health: Current Research\",\n        summary: \"What studies reveal about cardiovascular effects of energy drink consumption.\",\n        image: \"https://images.unsplash.com/photo-1622543925917-763c34d1a86e?w=400&h=400&fit=crop&q=80\",\n        content: \"Research into the cardiovascular effects of energy drinks has intensified in recent years, with findings that warrant attention from consumers. Studies have documented that consuming energy drinks can cause immediate increases in heart rate and blood pressure, even in healthy young adults. Blood pressure can rise by 6 to 7 points within 30 minutes of consumption, effects that may persist for several hours.\\n\\nMore concerning are documented cases of serious cardiac events associated with energy drink consumption. Medical literature includes reports of heart arrhythmias, including atrial fibrillation and ventricular tachycardia, occurring after energy drink intake. Some cases have resulted in cardiac arrest, particularly when drinks were consumed in large quantities or combined with alcohol or intense physical activity.\\n\\nThe combination of ingredients in energy drinks appears to have effects beyond what caffeine alone would produce. Research suggests that the interaction between caffeine, taurine, and other stimulants may create a synergistic effect on the cardiovascular system. Studies have shown changes in the heart's electrical activity, specifically QT interval prolongation, which can increase the risk of dangerous heart rhythms.\\n\\nHealth organizations recommend that people with existing heart conditions, high blood pressure, or a family history of cardiac problems avoid energy drinks entirely. For healthy adults who choose to consume them, moderation is essential. Experts suggest limiting intake to no more than one can per day and avoiding combining energy drinks with alcohol or consuming them before or during intense exercise. Children and adolescents are advised not to consume energy drinks due to their developing cardiovascular systems.\",\n        references: [\n          \"https://www.heart.org/en/news/2019/05/29/energy-drinks-may-provide-jolt-to-heart-function-blood-pressure\",\n          \"https://www.ahajournals.org/doi/10.1161/jaha.118.011318\",\n          \"https://www.mayoclinichealthsystem.org/hometown-health/speaking-of-health/the-buzz-on-energy-drinks\",\n        ],\n      },\n      {\n        id: \"eng-3\",\n        title: \"Youth and Energy Drinks: Age-Appropriate Guidelines\",\n        summary: \"Why health experts recommend children and teens avoid energy drinks.\",\n        image: \"https://images.unsplash.com/photo-1534438327276-14e5300c3a48?w=400&h=400&fit=crop&q=80\",\n        content: \"The American Academy of Pediatrics has taken a clear stance: energy drinks have no place in the diets of children and adolescents. This recommendation stems from growing evidence that young people are particularly vulnerable to the effects of these highly caffeinated beverages. Unlike coffee or tea, which teens might consume in moderate amounts, energy drinks are often marketed aggressively to young consumers and packaged in ways that encourage overconsumption.\\n\\nChildren and teenagers metabolize caffeine more slowly than adults, meaning its effects last longer in their systems. Their developing nervous systems are also more sensitive to stimulants. Research has linked energy drink consumption in adolescents to increased rates of anxiety, sleep disturbances, and behavioral problems. Sleep disruption is particularly concerning during adolescence, a period when adequate rest is crucial for physical and cognitive development.\\n\\nEmergency room visits related to energy drink consumption among young people have increased significantly over the past decade. Many of these visits involve heart palpitations, seizures, or severe anxiety. The high sugar content in many energy drinks also contributes to obesity risk and dental problems, issues already prevalent among youth.\\n\\nSeveral countries have implemented age restrictions on energy drink sales. Lithuania became the first European Union country to ban sales to minors under 18, followed by Latvia. Some regions require warning labels specifically mentioning risks for children. For parents concerned about their teenager's energy drink consumption, having open conversations about the risks and suggesting healthier alternatives like water, milk, or small amounts of regular coffee or tea can be helpful approaches.\",\n        references: [\n          \"https://publications.aap.org/pediatrics/article/127/3/511/65072/Sports-Drinks-and-Energy-Drinks-for-Children-and\",\n          \"https://www.cdc.gov/school-nutrition/energy-drinks/index.html\",\n          \"https://pubmed.ncbi.nlm.nih.gov/21321035/\",\n        ],\n      },\n    ],\n  },\n  {\n    title: \"Sleep & Alertness\",\n    articles: [\n      {\n        id: \"slp-1\",\n        title: \"How Caffeine Disrupts Your Sleep Patterns\",\n        summary: \"Understanding the science behind caffeine's impact on sleep quality and duration.\",\n        image: \"https://images.unsplash.com/photo-1541781774459-bb2af2f05b55?w=400&h=400&fit=crop&q=80\",\n        content: \"Caffeine's effects on sleep extend far beyond simply making it harder to fall asleep. Research using sleep monitoring technology has revealed that caffeine consumption affects multiple aspects of sleep architecture, even when consumed many hours before bedtime. A comprehensive analysis of controlled studies found that caffeine reduces total sleep time by an average of 35 minutes and decreases sleep efficiency by nearly 5 percent.\\n\\nOne of caffeine's most significant impacts is on slow-wave sleep, the deepest and most restorative phase of the sleep cycle. This stage is crucial for physical recovery, immune function, and memory consolidation. Studies show that caffeine reduces the amount of time spent in slow-wave sleep, meaning even if you sleep for your usual duration, the quality of that sleep is diminished. You may wake feeling less refreshed and restored.\\n\\nThe timing of caffeine consumption matters enormously. Caffeine has a half-life of approximately 5 to 6 hours, meaning half of the caffeine from your afternoon coffee is still circulating in your bloodstream at bedtime. Research suggests stopping caffeine intake by mid-afternoon, ideally 6 to 8 hours before your planned sleep time. However, individual sensitivity varies significantly based on genetics, with some people being rapid metabolizers and others slow metabolizers.\\n\\nBeyond blocking adenosine receptors, caffeine also interferes with melatonin production, the hormone that signals to your body it's time to sleep. Studies have shown that caffeine consumed 3 hours before bedtime can delay the body's internal clock by approximately 40 minutes. This phase delay means your body's natural sleep signals are pushed later, creating a cycle where you feel awake at night but tired in the morning.\",\n        references: [\n          \"https://pubmed.ncbi.nlm.nih.gov/36870101/\",\n          \"https://www.science.org/doi/10.1126/scitranslmed.aac5125\",\n          \"https://jcsm.aasm.org/doi/10.5664/jcsm.3170\",\n        ],\n      },\n      {\n        id: \"slp-2\",\n        title: \"Strategic Caffeine Timing for Peak Performance\",\n        summary: \"Research-backed approaches to maximize alertness while protecting sleep.\",\n        image: \"https://images.unsplash.com/photo-1434494878577-86c23bcb06b9?w=400&h=400&fit=crop&q=80\",\n        content: \"Scientists have developed sophisticated models for optimizing caffeine consumption to maximize alertness during waking hours while minimizing sleep disruption. Recent research combining sleep scheduling with caffeine timing has shown that strategic consumption can reduce alertness impairment by over 60 percent compared to unplanned intake. This represents a significant improvement in cognitive performance for those who need to stay sharp during demanding schedules.\\n\\nThe key insight from this research is that both when you sleep and when you consume caffeine need to be coordinated for optimal results. Simply optimizing one without the other provides limited benefits. For shift workers, travelers dealing with jet lag, or anyone facing irregular schedules, this integrated approach offers practical guidance for maintaining performance while protecting sleep quality.\\n\\nOne effective strategy is to consume caffeine 30 to 60 minutes after waking rather than immediately upon rising. This timing allows your body's natural cortisol awakening response to work first, then supplements it with caffeine when cortisol levels begin declining. This approach can provide more sustained energy throughout the morning without requiring higher doses.\\n\\nFor those who need afternoon alertness, a small caffeine dose of 50 to 100 milligrams consumed before 2 PM can provide a boost without significantly impacting nighttime sleep for most people. Some research supports the caffeine nap strategy, where you consume caffeine immediately before a 20-minute nap. The caffeine takes about 20 minutes to kick in, so you wake just as the alerting effects begin, feeling doubly refreshed.\",\n        references: [\n          \"https://academic.oup.com/sleep/article/48/4/zsae230/7815486\",\n          \"https://jcsm.aasm.org/doi/10.5664/jcsm.9736\",\n          \"https://www.tandfonline.com/doi/full/10.1080/07420528.2020.1867157\",\n        ],\n      },\n      {\n        id: \"slp-3\",\n        title: \"Natural Alternatives for Sustained Energy\",\n        summary: \"Evidence-based ways to boost alertness without relying on caffeine.\",\n        image: \"https://images.unsplash.com/photo-1571019613454-1cb2f99b2d8b?w=400&h=400&fit=crop&q=80\",\n        content: \"While caffeine is effective for boosting alertness, relying on it too heavily can create dependency and disrupt natural energy regulation. Fortunately, research has identified several evidence-based alternatives that can provide sustained energy without the potential downsides of excessive caffeine consumption. Understanding these options allows for a more balanced approach to managing energy levels throughout the day.\\n\\nPhysical activity is one of the most powerful natural energy boosters. Even a brief 10-minute walk can increase alertness and improve mood for up to 2 hours afterward. Exercise increases blood flow to the brain, releases endorphins, and can be more effective than caffeine for combating afternoon fatigue. Regular exercise also improves sleep quality, creating a positive cycle of better rest and more natural daytime energy.\\n\\nHydration plays a surprisingly significant role in energy levels. Even mild dehydration of 1 to 2 percent of body weight can cause fatigue, difficulty concentrating, and reduced alertness. Many people mistake thirst for tiredness and reach for caffeine when water would be more helpful. Keeping a water bottle nearby and drinking consistently throughout the day can prevent these energy dips.\\n\\nExposure to natural light, particularly in the morning, helps regulate circadian rhythms and promotes daytime alertness. Light exposure suppresses melatonin production and signals to your body that it's time to be awake. Strategic napping, limited to 20 to 30 minutes before 3 PM, can restore alertness without interfering with nighttime sleep. Balanced meals that combine protein, complex carbohydrates, and healthy fats provide steady energy without the blood sugar spikes and crashes associated with sugary snacks and drinks.\",\n        references: [\n          \"https://ijbnpa.biomedcentral.com/articles/10.1186/s12966-017-0525-8\",\n          \"https://www.nature.com/articles/ejcn2012184\",\n          \"https://onlinelibrary.wiley.com/doi/10.1111/jsr.12866\",\n        ],\n      },\n    ],\n  },\n  {\n    title: \"Healthy Consumption Tips\",\n    articles: [\n      {\n        id: \"tip-1\",\n        title: \"Building a Balanced Caffeine Routine\",\n        summary: \"Practical strategies for enjoying caffeine while maintaining overall wellness.\",\n        image: \"https://images.unsplash.com/photo-1511920170033-f8396924c348?w=400&h=400&fit=crop&q=80\",\n        content: \"Creating a sustainable caffeine routine involves more than just counting milligrams. A thoughtful approach considers timing, sources, and individual responses to optimize benefits while avoiding potential drawbacks. The goal is to use caffeine as a tool for enhanced performance and enjoyment rather than a crutch for getting through the day.\\n\\nStart by tracking your current consumption for a week, including all sources: coffee, tea, soft drinks, energy drinks, chocolate, and any medications containing caffeine. Many people are surprised to discover they consume significantly more than they realized. This baseline helps identify opportunities for adjustment if needed. Pay attention to how different amounts and timings affect your energy, mood, and sleep.\\n\\nConsider the quality of your caffeine sources. Coffee and tea offer additional health benefits from antioxidants and other plant compounds that energy drinks and soft drinks lack. If you drink multiple cups of coffee daily, try making your second or third cup a half-caf blend to reduce total intake while maintaining the ritual you enjoy. Green tea provides a gentler caffeine boost with L-theanine, an amino acid that promotes calm focus.\\n\\nBuild in caffeine-free days or periods to prevent tolerance from building up. Some people benefit from one caffeine-free day per week, while others do well with periodic week-long breaks. These breaks help reset your adenosine receptors so caffeine remains effective at lower doses. If you experience withdrawal symptoms during breaks, this indicates some level of dependence and suggests gradually reducing your baseline intake.\",\n        references: [\n          \"https://nutritionsource.hsph.harvard.edu/caffeine/\",\n          \"https://www.eatright.org/food/nutrition/dietary-guidelines-and-myplate\",\n          \"https://www.sleepfoundation.org/nutrition/caffeine-and-sleep\",\n        ],\n      },\n      {\n        id: \"tip-2\",\n        title: \"Recognizing When to Cut Back on Caffeine\",\n        summary: \"Signs that your caffeine intake may be affecting your health negatively.\",\n        image: \"https://images.unsplash.com/photo-1512621776951-a57141f2eefd?w=400&h=400&fit=crop&q=80\",\n        content: \"While moderate caffeine consumption is safe for most adults, there are clear signals that indicate it may be time to reduce intake. Recognizing these signs early can prevent more significant health issues and help restore a healthier relationship with caffeine. Your body provides valuable feedback if you learn to listen to it.\\n\\nSleep problems are often the first warning sign of excessive caffeine consumption. If you consistently have trouble falling asleep, wake frequently during the night, or feel unrested despite adequate sleep duration, caffeine may be a contributing factor. Keep a sleep diary noting both your caffeine intake and sleep quality to identify patterns. Even if you feel you fall asleep fine, caffeine could be reducing your deep sleep stages.\\n\\nAnxiety, restlessness, and jitteriness are direct effects of caffeine overstimulation. If you notice your heart racing, hands trembling, or feeling on edge, these symptoms suggest your caffeine intake exceeds your tolerance. Some people experience digestive issues like acid reflux, stomach upset, or frequent urination as caffeine stimulates these systems.\\n\\nDependence is indicated by needing caffeine just to feel normal or function at baseline levels. If your first thought upon waking is about getting coffee, if you experience headaches or irritability when caffeine is delayed, or if you've gradually increased your intake over time to achieve the same effects, these patterns suggest problematic use. Cutting back gradually rather than abruptly can help minimize withdrawal symptoms while restoring sensitivity to lower doses.\",\n        references: [\n          \"https://www.mayoclinic.org/healthy-lifestyle/nutrition-and-healthy-eating/in-depth/caffeine/art-20045678\",\n          \"https://health.clevelandclinic.org/how-to-get-caffeine-out-of-your-system\",\n          \"https://www.liebertpub.com/doi/10.1089/jcr.2013.0016\",\n        ],\n      },\n      {\n        id: \"tip-3\",\n        title: \"Caffeine Considerations for Special Populations\",\n        summary: \"Tailored guidance for pregnant women, athletes, and those with health conditions.\",\n        image: \"https://images.unsplash.com/photo-1493894473891-10fc1e5dbd22?w=400&h=400&fit=crop&q=80\",\n        content: \"Different life circumstances and health conditions require modified approaches to caffeine consumption. What works well for one person may not be appropriate for another. Understanding these nuances helps ensure caffeine remains a positive part of life without creating unnecessary risks.\\n\\nPregnant women should limit caffeine to under 200 milligrams daily, approximately one 12-ounce cup of coffee. Caffeine crosses the placenta, and because the developing fetus cannot metabolize it efficiently, exposure lasts longer and can affect growth. Research has linked higher caffeine intake during pregnancy to increased risks of low birth weight and preterm delivery. Many women choose to further reduce or eliminate caffeine during pregnancy out of caution.\\n\\nAthletes can benefit from strategic caffeine use for performance enhancement, with research supporting doses of 3 to 6 milligrams per kilogram of body weight taken 30 to 60 minutes before exercise. However, regular high intake can diminish these performance benefits through tolerance. Some athletes periodically reduce caffeine to resensitize before important competitions. Caffeine also acts as a diuretic, so adequate hydration during exercise is especially important.\\n\\nPeople with anxiety disorders may find that caffeine worsens symptoms, as it activates the same fight-or-flight response that underlies anxiety. Those with heart arrhythmias, uncontrolled high blood pressure, or gastroesophageal reflux disease often benefit from significantly reducing or eliminating caffeine. Anyone taking medications should check for interactions, as caffeine can affect how certain drugs are metabolized, potentially increasing or decreasing their effectiveness.\",\n        references: [\n          \"https://www.acog.org/womens-health/experts-and-stories/ask-acog/how-much-coffee-can-i-drink-while-pregnant\",\n          \"https://jissn.biomedcentral.com/articles/10.1186/s12970-021-00420-6\",\n          \"https://adaa.org/understanding-anxiety/related-illnesses/other-related-conditions/stress/physical-activity-reduces-st\",\n        ],\n      },\n    ],\n  },\n];\n\nexport default function HistoryScreen() {\n  const { theme } = useTheme();\n  const insets = useSafeAreaInsets();\n  const navigation = useNavigation<NavigationProp>();\n\n  const handleArticlePress = (article: Article) => {\n    navigation.navigate(\"Article\", { article });\n  };\n\n  return (\n    <View style={[styles.container, { backgroundColor: theme.backgroundRoot }]}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.md }]}>\n        <Text style={[styles.headerTitle, { color: theme.text }]}>Information Hub</Text>\n      </View>\n\n      <ScrollView\n        style={styles.scrollView}\n        contentContainerStyle={styles.scrollContent}\n        showsVerticalScrollIndicator={false}\n      >\n        {SECTIONS.map((section) => (\n          <View key={section.title} style={styles.section}>\n            <Text style={[styles.sectionTitle, { color: theme.text }]}>{section.title}</Text>\n            {section.articles.map((article) => (\n              <Pressable\n                key={article.id}\n                style={[styles.articleCard, { backgroundColor: theme.backgroundDefault }]}\n                onPress={() => handleArticlePress(article)}\n              >\n                <Image source={{ uri: article.image }} style={styles.articleImage} />\n                <View style={styles.articleContent}>\n                  <Text style={[styles.articleTitle, { color: theme.text }]} numberOfLines={2}>\n                    {article.title}\n                  </Text>\n                  <Text style={[styles.articleSummary, { color: theme.mutedGrey }]} numberOfLines={2}>\n                    {article.summary}\n                  </Text>\n                </View>\n              </Pressable>\n            ))}\n          </View>\n        ))}\n      </ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing.lg,\n    alignItems: \"center\",\n  },\n  headerTitle: {\n    fontSize: 20,\n    fontWeight: \"700\",\n  },\n  scrollView: {\n    flex: 1,\n  },\n  scrollContent: {\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing[\"3xl\"],\n  },\n  section: {\n    marginBottom: Spacing.xl,\n  },\n  sectionTitle: {\n    fontSize: 16,\n    fontWeight: \"600\",\n    marginBottom: Spacing.md,\n  },\n  articleCard: {\n    flexDirection: \"row\",\n    padding: Spacing.md,\n    borderRadius: BorderRadius.md,\n    marginBottom: Spacing.sm,\n  },\n  articleImage: {\n    width: 60,\n    height: 60,\n    borderRadius: BorderRadius.sm,\n  },\n  articleContent: {\n    flex: 1,\n    marginLeft: Spacing.md,\n    justifyContent: \"center\",\n  },\n  articleTitle: {\n    fontSize: 13,\n    fontWeight: \"600\",\n    marginBottom: 2,\n    lineHeight: 16,\n  },\n  articleSummary: {\n    fontSize: 11,\n    lineHeight: 14,\n  },\n});\n","path":null,"size_bytes":38878,"size_tokens":null},"utils/dummy_logs.ts":{"content":"import { DrinkEntry } from \"@/store/caffeineStore\";\n\n// Generate dummy entries with varying dates\nconst now = new Date();\nconst today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\nconst yesterday = new Date(today);\nyesterday.setDate(yesterday.getDate() - 1);\nconst twoDaysAgo = new Date(today);\ntwoDaysAgo.setDate(twoDaysAgo.getDate() - 2);\nconst threeDaysAgo = new Date(today);\nthreeDaysAgo.setDate(threeDaysAgo.getDate() - 3);\nconst fourDaysAgo = new Date(today);\nfourDaysAgo.setDate(fourDaysAgo.getDate() - 4);\nconst fiveDaysAgo = new Date(today);\nfiveDaysAgo.setDate(fiveDaysAgo.getDate() - 5);\nconst sixDaysAgo = new Date(today);\nsixDaysAgo.setDate(sixDaysAgo.getDate() - 6);\n\nexport const DUMMY_ENTRIES: DrinkEntry[] = [\n  // Today\n  {\n    id: \"dummy-1\",\n    drinkId: \"espresso-1\",\n    name: \"Espresso\",\n    caffeineAmount: 77,\n    servingSize: 30,\n    category: \"coffee\",\n    timestamp: new Date(today.getTime() + 19 * 3600000 + 33 * 60000), // 7:33 PM\n  },\n  {\n    id: \"dummy-2\",\n    drinkId: \"latte-1\",\n    name: \"Latte\",\n    caffeineAmount: 95,\n    servingSize: 240,\n    category: \"coffee\",\n    timestamp: new Date(today.getTime() + 14 * 3600000 + 15 * 60000), // 2:15 PM\n  },\n  {\n    id: \"dummy-3\",\n    drinkId: \"americano-1\",\n    name: \"Americano\",\n    caffeineAmount: 150,\n    servingSize: 355,\n    category: \"coffee\",\n    timestamp: new Date(today.getTime() + 10 * 3600000 + 45 * 60000), // 10:45 AM\n  },\n  \n  // Yesterday\n  {\n    id: \"dummy-4\",\n    drinkId: \"bnk-1\",\n    name: \"Bnk\",\n    caffeineAmount: 20,\n    servingSize: 250,\n    category: \"coffee\",\n    timestamp: new Date(yesterday.getTime() + 6 * 3600000 + 16 * 60000), // 6:16 AM\n  },\n  {\n    id: \"dummy-5\",\n    drinkId: \"green-tea-1\",\n    name: \"Green Tea\",\n    caffeineAmount: 30,\n    servingSize: 240,\n    category: \"tea\",\n    timestamp: new Date(yesterday.getTime() + 15 * 3600000 + 30 * 60000), // 3:30 PM\n  },\n  \n  // 2 days ago (Saturday, 06/12/2025)\n  {\n    id: \"dummy-6\",\n    drinkId: \"cghu-1\",\n    name: \"Cghu\",\n    caffeineAmount: 200,\n    servingSize: 500,\n    category: \"coffee\",\n    timestamp: new Date(twoDaysAgo.getTime() + 22 * 3600000 + 24 * 60000), // 10:24 PM\n  },\n  {\n    id: \"dummy-7\",\n    drinkId: \"drip-coffee-1\",\n    name: \"Drip coffee\",\n    caffeineAmount: 95,\n    servingSize: 240,\n    category: \"coffee\",\n    timestamp: new Date(twoDaysAgo.getTime() + 18 * 3600000 + 23 * 60000), // 6:23 PM\n  },\n  {\n    id: \"dummy-8\",\n    drinkId: \"cappuccino-1\",\n    name: \"Cappuccino\",\n    caffeineAmount: 80,\n    servingSize: 180,\n    category: \"coffee\",\n    timestamp: new Date(twoDaysAgo.getTime() + 8 * 3600000 + 10 * 60000), // 8:10 AM\n  },\n  \n  // 3 days ago\n  {\n    id: \"dummy-9\",\n    drinkId: \"red-bull-1\",\n    name: \"Red Bull\",\n    caffeineAmount: 80,\n    servingSize: 250,\n    category: \"energy\",\n    timestamp: new Date(threeDaysAgo.getTime() + 12 * 3600000 + 0 * 60000), // 12:00 PM\n  },\n  {\n    id: \"dummy-10\",\n    drinkId: \"matcha-1\",\n    name: \"Matcha\",\n    caffeineAmount: 70,\n    servingSize: 240,\n    category: \"tea\",\n    timestamp: new Date(threeDaysAgo.getTime() + 9 * 3600000 + 30 * 60000), // 9:30 AM\n  },\n  \n  // 4 days ago\n  {\n    id: \"dummy-11\",\n    drinkId: \"cold-brew-1\",\n    name: \"Cold Brew\",\n    caffeineAmount: 200,\n    servingSize: 355,\n    category: \"coffee\",\n    timestamp: new Date(fourDaysAgo.getTime() + 16 * 3600000 + 45 * 60000), // 4:45 PM\n  },\n  \n  // 5 days ago\n  {\n    id: \"dummy-12\",\n    drinkId: \"coca-cola-1\",\n    name: \"Coca Cola\",\n    caffeineAmount: 34,\n    servingSize: 355,\n    category: \"soda\",\n    timestamp: new Date(fiveDaysAgo.getTime() + 13 * 3600000 + 20 * 60000), // 1:20 PM\n  },\n  \n  // 6 days ago\n  {\n    id: \"dummy-13\",\n    drinkId: \"dark-chocolate-1\",\n    name: \"Dark Chocolate\",\n    caffeineAmount: 12,\n    servingSize: 100,\n    category: \"chocolate\",\n    timestamp: new Date(sixDaysAgo.getTime() + 20 * 3600000 + 0 * 60000), // 8:00 PM\n  },\n  {\n    id: \"dummy-14\",\n    drinkId: \"mocha-1\",\n    name: \"Mocha\",\n    caffeineAmount: 95,\n    servingSize: 355,\n    category: \"coffee\",\n    timestamp: new Date(sixDaysAgo.getTime() + 11 * 3600000 + 15 * 60000), // 11:15 AM\n  },\n];\n\n\n\n\n\n\n\n\n\n","path":null,"size_bytes":4150,"size_tokens":null},"components/GlowIndicator.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, ViewStyle } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ntype IndicatorStatus = \"safe\" | \"warning\" | \"danger\";\n\ninterface GlowIndicatorProps {\n  icon: \"coffee\" | \"moon\";\n  label: string;\n  status: IndicatorStatus;\n  style?: ViewStyle;\n}\n\nconst STATUS_COLORS = {\n  safe: \"#53A451\",\n  warning: \"#F2A43A\",\n  danger: \"#D9534F\",\n};\n\nexport function GlowIndicator({ icon, label, status, style }: GlowIndicatorProps) {\n  const { theme } = useTheme();\n  const color = STATUS_COLORS[status];\n\n  return (\n    <View style={[styles.container, style]}>\n      <View style={[styles.iconWrapper, { shadowColor: color }]}>\n        <View style={[styles.iconCircle, { backgroundColor: `${color}20` }]}>\n          <Feather name={icon} size={24} color={color} />\n        </View>\n      </View>\n      <ThemedText type=\"caption\" style={[styles.label, { color: theme.text }]}>\n        {label}\n      </ThemedText>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    paddingVertical: Spacing.xs,\n  },\n  iconWrapper: {\n    shadowOffset: { width: 0, height: 0 },\n    shadowOpacity: 0.6,\n    shadowRadius: 12,\n    elevation: 8,\n  },\n  iconCircle: {\n    width: 48,\n    height: 48,\n    borderRadius: BorderRadius.full,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  label: {\n    marginTop: Spacing.xs,\n    textAlign: \"center\",\n  },\n});\n","path":null,"size_bytes":1633,"size_tokens":null},"components/ErrorFallback.tsx":{"content":"import React, { useState } from \"react\";\nimport { reloadAppAsync } from \"expo\";\nimport {\n  StyleSheet,\n  View,\n  Pressable,\n  ScrollView,\n  Text,\n  Modal,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius, Fonts, Colors } from \"@/constants/theme\";\n\nexport type ErrorFallbackProps = {\n  error: Error;\n  resetError: () => void;\n};\n\nexport function ErrorFallback({ error, resetError }: ErrorFallbackProps) {\n  const { theme } = useTheme();\n  const [isModalVisible, setIsModalVisible] = useState(false);\n\n  const handleRestart = async () => {\n    try {\n      await reloadAppAsync();\n    } catch (restartError) {\n      console.error(\"Failed to restart app:\", restartError);\n      resetError();\n    }\n  };\n\n  const formatErrorDetails = (): string => {\n    let details = `Error: ${error.message}\\n\\n`;\n    if (error.stack) {\n      details += `Stack Trace:\\n${error.stack}`;\n    }\n    return details;\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      {__DEV__ ? (\n        <Pressable\n          onPress={() => setIsModalVisible(true)}\n          style={({ pressed }) => [\n            styles.topButton,\n            {\n              backgroundColor: theme.backgroundDefault,\n              opacity: pressed ? 0.8 : 1,\n            },\n          ]}\n        >\n          <Feather name=\"alert-circle\" size={20} color={theme.text} />\n        </Pressable>\n      ) : null}\n\n      <View style={styles.content}>\n        <View style={styles.iconContainer}>\n          <Feather name=\"coffee\" size={48} color={Colors.light.accent} />\n        </View>\n        \n        <ThemedText type=\"h2\" style={styles.title}>\n          Oops! Caffi spilled\n        </ThemedText>\n\n        <ThemedText type=\"body\" style={styles.message}>\n          Something went wrong. Please restart the app to continue tracking your caffeine.\n        </ThemedText>\n\n        <Pressable\n          onPress={handleRestart}\n          style={({ pressed }) => [\n            styles.button,\n            {\n              backgroundColor: Colors.light.accent,\n              opacity: pressed ? 0.9 : 1,\n              transform: [{ scale: pressed ? 0.98 : 1 }],\n            },\n          ]}\n        >\n          <ThemedText\n            type=\"body\"\n            style={[styles.buttonText, { color: \"#FFFFFF\" }]}\n          >\n            Brew Again\n          </ThemedText>\n        </Pressable>\n      </View>\n\n      {__DEV__ ? (\n        <Modal\n          visible={isModalVisible}\n          animationType=\"slide\"\n          transparent={true}\n          onRequestClose={() => setIsModalVisible(false)}\n        >\n          <View style={styles.modalOverlay}>\n            <ThemedView style={styles.modalContainer}>\n              <View style={styles.modalHeader}>\n                <ThemedText type=\"h3\" style={styles.modalTitle}>\n                  Error Details\n                </ThemedText>\n                <Pressable\n                  onPress={() => setIsModalVisible(false)}\n                  style={({ pressed }) => [\n                    styles.closeButton,\n                    { opacity: pressed ? 0.6 : 1 },\n                  ]}\n                >\n                  <Feather name=\"x\" size={24} color={theme.text} />\n                </Pressable>\n              </View>\n\n              <ScrollView\n                style={styles.modalScrollView}\n                contentContainerStyle={styles.modalScrollContent}\n                showsVerticalScrollIndicator\n              >\n                <View\n                  style={[\n                    styles.errorContainer,\n                    { backgroundColor: theme.backgroundDefault },\n                  ]}\n                >\n                  <Text\n                    style={[\n                      styles.errorText,\n                      {\n                        color: theme.text,\n                        fontFamily: Fonts?.mono || \"monospace\",\n                      },\n                    ]}\n                    selectable\n                  >\n                    {formatErrorDetails()}\n                  </Text>\n                </View>\n              </ScrollView>\n            </ThemedView>\n          </View>\n        </Modal>\n      ) : null}\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    width: \"100%\",\n    height: \"100%\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    padding: Spacing[\"2xl\"],\n  },\n  content: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: Spacing.lg,\n    width: \"100%\",\n    maxWidth: 600,\n  },\n  iconContainer: {\n    width: 100,\n    height: 100,\n    borderRadius: 50,\n    backgroundColor: `${Colors.light.accent}20`,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginBottom: Spacing.md,\n  },\n  title: {\n    textAlign: \"center\",\n  },\n  message: {\n    textAlign: \"center\",\n    opacity: 0.7,\n  },\n  topButton: {\n    position: \"absolute\",\n    top: Spacing[\"2xl\"] + Spacing.lg,\n    right: Spacing.lg,\n    width: 44,\n    height: 44,\n    borderRadius: BorderRadius.md,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    zIndex: 10,\n  },\n  button: {\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing[\"3xl\"],\n    minWidth: 200,\n  },\n  buttonText: {\n    fontWeight: \"600\",\n    textAlign: \"center\",\n    fontSize: 16,\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    justifyContent: \"flex-end\",\n  },\n  modalContainer: {\n    width: \"100%\",\n    height: \"90%\",\n    borderTopLeftRadius: BorderRadius.lg,\n    borderTopRightRadius: BorderRadius.lg,\n  },\n  modalHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingTop: Spacing.lg,\n    paddingBottom: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: \"rgba(128, 128, 128, 0.2)\",\n  },\n  modalTitle: {\n    fontWeight: \"600\",\n  },\n  closeButton: {\n    padding: Spacing.xs,\n  },\n  modalScrollView: {\n    flex: 1,\n  },\n  modalScrollContent: {\n    padding: Spacing.lg,\n  },\n  errorContainer: {\n    width: \"100%\",\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n    padding: Spacing.lg,\n  },\n  errorText: {\n    fontSize: 12,\n    lineHeight: 18,\n    width: \"100%\",\n  },\n});\n","path":null,"size_bytes":6419,"size_tokens":null},"components/CaffeineRing.tsx":{"content":"import React, { useEffect } from \"react\";\nimport { View, StyleSheet } from \"react-native\";\nimport Svg, { Circle, G } from \"react-native-svg\";\nimport Animated, {\n  useSharedValue,\n  useAnimatedProps,\n  withTiming,\n  Easing,\n} from \"react-native-reanimated\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { Colors, Spacing } from \"@/constants/theme\";\n\nconst AnimatedCircle = Animated.createAnimatedComponent(Circle);\n\ninterface CaffeineRingProps {\n  percentage: number;\n  currentMg: number;\n  limitMg: number;\n  size?: number;\n}\n\nexport function CaffeineRing({\n  percentage,\n  currentMg,\n  limitMg,\n  size = 220,\n}: CaffeineRingProps) {\n  const strokeWidth = 16;\n  const radius = (size - strokeWidth) / 2;\n  const circumference = 2 * Math.PI * radius;\n\n  const progress = useSharedValue(0);\n\n  useEffect(() => {\n    progress.value = withTiming(percentage / 100, {\n      duration: 1000,\n      easing: Easing.out(Easing.cubic),\n    });\n  }, [percentage]);\n\n  const animatedProps = useAnimatedProps(() => {\n    const strokeDashoffset = circumference * (1 - progress.value);\n    return {\n      strokeDashoffset,\n    };\n  });\n\n  const getColor = () => {\n    if (percentage >= 100) return Colors.light.danger;\n    if (percentage >= 80) return Colors.light.warning;\n    return Colors.light.accent;\n  };\n\n  return (\n    <View style={[styles.container, { width: size, height: size }]}>\n      <Svg width={size} height={size}>\n        <G rotation=\"-90\" origin={`${size / 2}, ${size / 2}`}>\n          <Circle\n            cx={size / 2}\n            cy={size / 2}\n            r={radius}\n            stroke={Colors.light.divider}\n            strokeWidth={strokeWidth}\n            fill=\"transparent\"\n          />\n          <AnimatedCircle\n            cx={size / 2}\n            cy={size / 2}\n            r={radius}\n            stroke={getColor()}\n            strokeWidth={strokeWidth}\n            fill=\"transparent\"\n            strokeDasharray={circumference}\n            animatedProps={animatedProps}\n            strokeLinecap=\"round\"\n          />\n        </G>\n      </Svg>\n      <View style={styles.textContainer}>\n        <ThemedText type=\"h1\" style={{ color: getColor() }}>\n          {currentMg}\n        </ThemedText>\n        <ThemedText type=\"small\" muted>\n          of {limitMg} mg\n        </ThemedText>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  textContainer: {\n    position: \"absolute\",\n    alignItems: \"center\",\n  },\n});\n","path":null,"size_bytes":2530,"size_tokens":null},"utils/graphUtils.ts":{"content":"export interface CaffeineEvent {\n  id: string;\n  name: string;\n  mg: number;\n  timestampISO: string;\n  iconUrl?: string;\n  category?: string;\n  imageUri?: string;\n}\n\nexport interface SamplePoint {\n  t: number;\n  mg: number;\n}\n\nexport interface GraphSampleData {\n  samples: SamplePoint[];\n  startMs: number;\n  endMs: number;\n  sampleTimesMs: number[];\n}\n\nexport function buildSampleTimes(\n  centerTimeISO: string,\n  viewWindowHours: number,\n  resolutionMinutes: number\n): { samples: number[]; startMs: number; endMs: number } {\n  const centerMs = Date.parse(centerTimeISO);\n  const halfWindowMs = (viewWindowHours / 2) * 3600000;\n  const startMs = centerMs - halfWindowMs;\n  const endMs = centerMs + halfWindowMs;\n  const stepMs = resolutionMinutes * 60 * 1000;\n  const samples: number[] = [];\n  for (let t = startMs; t <= endMs; t += stepMs) {\n    samples.push(t);\n  }\n  return { samples, startMs, endMs };\n}\n\nconst K_ELIM = 0.00231;\nconst K_ABS = 0.045;\n\nexport function remainingAfterHours(\n  doseMg: number,\n  hoursSinceDose: number,\n  halfLifeHours: number\n): number {\n  if (hoursSinceDose < 0) return 0;\n  const dtMinutes = hoursSinceDose * 60;\n  return doseMg * (1 - Math.exp(-K_ABS * dtMinutes)) * Math.exp(-K_ELIM * dtMinutes);\n}\n\nexport function computeActiveCurve(\n  events: CaffeineEvent[],\n  samplesMs: number[],\n  halfLifeHours: number\n): SamplePoint[] {\n  return samplesMs.map((s) => {\n    let total = 0;\n    for (const e of events) {\n      const eventMs = Date.parse(e.timestampISO);\n      const dtHours = (s - eventMs) / 3600000;\n      if (dtHours >= 0) {\n        total += remainingAfterHours(e.mg, dtHours, halfLifeHours);\n      }\n    }\n    return { t: s, mg: total };\n  });\n}\n\nexport function getActiveAtTime(\n  events: CaffeineEvent[],\n  timeMs: number,\n  halfLifeHours: number\n): number {\n  let total = 0;\n  for (const e of events) {\n    const eventMs = Date.parse(e.timestampISO);\n    const dtHours = (timeMs - eventMs) / 3600000;\n    if (dtHours >= 0) {\n      total += remainingAfterHours(e.mg, dtHours, halfLifeHours);\n    }\n  }\n  return total;\n}\n\nexport function formatTimeLabel(ms: number): string {\n  const date = new Date(ms);\n  const hours = date.getHours();\n  const ampm = hours >= 12 ? \"PM\" : \"AM\";\n  const hour12 = hours % 12 || 12;\n  return `${hour12}${ampm}`;\n}\n\nexport function formatCurrentTime(ms: number): string {\n  const date = new Date(ms);\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const ampm = hours >= 12 ? \"PM\" : \"AM\";\n  const hour12 = hours % 12 || 12;\n  const minStr = minutes.toString().padStart(2, \"0\");\n  return `${hour12}:${minStr}${ampm}`;\n}\n\nexport function parseBedtimeToMs(bedtimeStr: string, referenceDate: Date): number {\n  const [hours, minutes] = bedtimeStr.split(\":\").map(Number);\n  const result = new Date(referenceDate);\n  result.setHours(hours, minutes, 0, 0);\n  if (result.getTime() < referenceDate.getTime()) {\n    result.setDate(result.getDate() + 1);\n  }\n  return result.getTime();\n}\n\nexport function getMaxCaffeineInSleepWindowForDisplay(\n  events: CaffeineEvent[],\n  bedtimeStr: string,\n  nowMs: number,\n  halfLifeHours: number,\n  windowHours: number = 6\n): number {\n  const nowDate = new Date(nowMs);\n  const sleepTimeMs = parseBedtimeToMs(bedtimeStr, nowDate);\n  const stepMs = 15 * 60 * 1000;\n  const endMs = sleepTimeMs + windowHours * 3600000;\n  let maxCaffeine = 0;\n  for (let t = sleepTimeMs; t <= endMs; t += stepMs) {\n    const mg = getActiveAtTime(events, t, halfLifeHours);\n    if (mg > maxCaffeine) maxCaffeine = mg;\n  }\n  return maxCaffeine;\n}\n\nexport function getSleepWindowStatusMessage(\n  maxCaffeineInWindow: number\n): { message: string; color: \"green\" | \"brown\" | \"red\" } {\n  if (maxCaffeineInWindow < 30) {\n    return { message: \"sleep undisrupted.\", color: \"green\" };\n  } else if (maxCaffeineInWindow <= 40) {\n    return { message: \"May disrupt sleep for some people.\", color: \"brown\" };\n  } else {\n    return { message: \"More likely to disrupt sleep.\", color: \"red\" };\n  }\n}\n\nexport function generateSmoothPath(\n  points: { x: number; y: number }[],\n  tension: number = 0.3\n): string {\n  if (points.length < 2) return \"\";\n\n  let path = `M ${points[0].x} ${points[0].y}`;\n\n  for (let i = 0; i < points.length - 1; i++) {\n    const p0 = points[i - 1] || points[i];\n    const p1 = points[i];\n    const p2 = points[i + 1];\n    const p3 = points[i + 2] || p2;\n\n    const cp1x = p1.x + (p2.x - p0.x) * tension;\n    const cp1y = p1.y + (p2.y - p0.y) * tension;\n    const cp2x = p2.x - (p3.x - p1.x) * tension;\n    const cp2y = p2.y - (p3.y - p1.y) * tension;\n\n    path += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`;\n  }\n\n  return path;\n}\n\nexport function getEventMarkersWithCollision(\n  events: CaffeineEvent[],\n  timeToX: (ms: number) => number,\n  collisionThreshold: number = 28\n): { event: CaffeineEvent; x: number; clustered: CaffeineEvent[] }[] {\n  const sorted = [...events].sort(\n    (a, b) => Date.parse(a.timestampISO) - Date.parse(b.timestampISO)\n  );\n\n  const markers: { event: CaffeineEvent; x: number; clustered: CaffeineEvent[] }[] = [];\n  let i = 0;\n\n  while (i < sorted.length) {\n    const current = sorted[i];\n    const currentX = timeToX(Date.parse(current.timestampISO));\n    const clustered: CaffeineEvent[] = [current];\n\n    let j = i + 1;\n    while (j < sorted.length) {\n      const nextX = timeToX(Date.parse(sorted[j].timestampISO));\n      if (Math.abs(nextX - currentX) < collisionThreshold) {\n        clustered.push(sorted[j]);\n        j++;\n      } else {\n        break;\n      }\n    }\n\n    markers.push({ event: current, x: currentX, clustered });\n    i = j;\n  }\n\n  return markers;\n}\n\nexport function getSleepStatusMessage(\n  currentMg: number,\n  sleepThresholdMg: number\n): { message: string; color: \"green\" | \"brown\" | \"red\" } {\n  if (currentMg <= sleepThresholdMg) {\n    return { message: \"Your sleep should be unaffected.\", color: \"green\" };\n  } else if (currentMg <= sleepThresholdMg * 1.4) {\n    return { message: \"Your sleep might be disrupted.\", color: \"brown\" };\n  } else {\n    return { message: \"High caffeine  might cause major disruption.\", color: \"red\" };\n  }\n}\n\nexport function getPeakCaffeineWithNewEntry(\n  events: CaffeineEvent[],\n  newEntryMg: number,\n  newEntryTimeMs: number,\n  halfLifeHours: number,\n  lookAheadHours: number = 24\n): number {\n  const tempEvent: CaffeineEvent = {\n    id: \"temp\",\n    name: \"temp\",\n    mg: newEntryMg,\n    timestampISO: new Date(newEntryTimeMs).toISOString(),\n  };\n  const allEvents = [...events, tempEvent];\n  \n  const stepMs = 15 * 60 * 1000;\n  const endMs = newEntryTimeMs + lookAheadHours * 3600000;\n  let peak = 0;\n  \n  for (let t = newEntryTimeMs; t <= endMs; t += stepMs) {\n    const mg = getActiveAtTime(allEvents, t, halfLifeHours);\n    if (mg > peak) peak = mg;\n  }\n  \n  return peak;\n}\n\nexport function getCaffeineAtSleepTimeWithNewEntry(\n  events: CaffeineEvent[],\n  newEntryMg: number,\n  newEntryTimeMs: number,\n  sleepTimeMs: number,\n  halfLifeHours: number\n): number {\n  const tempEvent: CaffeineEvent = {\n    id: \"temp\",\n    name: \"temp\",\n    mg: newEntryMg,\n    timestampISO: new Date(newEntryTimeMs).toISOString(),\n  };\n  const allEvents = [...events, tempEvent];\n  \n  return getActiveAtTime(allEvents, sleepTimeMs, halfLifeHours);\n}\n\nexport function getMaxCaffeineInSleepWindow(\n  events: CaffeineEvent[],\n  newEntryMg: number,\n  newEntryTimeMs: number,\n  sleepTimeMs: number,\n  halfLifeHours: number,\n  windowHours: number = 6\n): number {\n  const tempEvent: CaffeineEvent = {\n    id: \"temp\",\n    name: \"temp\",\n    mg: newEntryMg,\n    timestampISO: new Date(newEntryTimeMs).toISOString(),\n  };\n  const allEvents = [...events, tempEvent];\n  \n  const stepMs = 15 * 60 * 1000;\n  const endMs = sleepTimeMs + windowHours * 3600000;\n  let maxCaffeine = 0;\n  \n  for (let t = sleepTimeMs; t <= endMs; t += stepMs) {\n    const mg = getActiveAtTime(allEvents, t, halfLifeHours);\n    if (mg > maxCaffeine) maxCaffeine = mg;\n  }\n  \n  return maxCaffeine;\n}\n\nexport function getCaffeineLimitStatus(\n  peakMg: number,\n  optimalLimit: number\n): \"safe\" | \"warning\" | \"danger\" {\n  const percentage = (peakMg / optimalLimit) * 100;\n  if (percentage > 100) return \"danger\";\n  if (percentage >= 90) return \"warning\";\n  return \"safe\";\n}\n\nexport function getSleepImpactStatus(\n  caffeineAtSleepMg: number\n): \"safe\" | \"warning\" | \"danger\" {\n  if (caffeineAtSleepMg > 40) return \"danger\";\n  if (caffeineAtSleepMg >= 30) return \"warning\";\n  return \"safe\";\n}\n","path":null,"size_bytes":8455,"size_tokens":null},"babel.config.js":{"content":"module.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\"babel-preset-expo\"],\n    plugins: [\n      [\n        \"module-resolver\",\n        {\n          root: [\"./\"],\n          alias: {\n            \"@\": \"./\",\n          },\n          extensions: [\".ios.js\", \".android.js\", \".js\", \".ts\", \".tsx\", \".json\"],\n        },\n      ],\n      \"react-native-reanimated/plugin\",\n    ],\n  };\n};\n","path":null,"size_bytes":395,"size_tokens":null},"components/ImagePickerModal.tsx":{"content":"import React, { useEffect } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Modal,\n  Pressable,\n  ScrollView,\n  useWindowDimensions,\n  Image,\n  Alert,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  withTiming,\n  runOnJS,\n} from \"react-native-reanimated\";\nimport { Gesture, GestureDetector, GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport * as ImagePicker from \"expo-image-picker\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface ImagePickerModalProps {\n  visible: boolean;\n  onClose: () => void;\n  onSelectImage: (imageUri: string) => void;\n}\n\nexport const PRESET_IMAGES = [\n  { id: \"latte\", name: \"Latte\", image: require(\"@/assets/images/drinks/latte.jpg\") },\n  { id: \"coffee-cup\", name: \"Coffee Cup\", image: require(\"@/assets/images/drinks/coffee-cup.jpg\") },\n  { id: \"cappuccino\", name: \"Cappuccino\", image: require(\"@/assets/images/drinks/cappuccino.jpg\") },\n  { id: \"takeaway\", name: \"Takeaway\", image: require(\"@/assets/images/drinks/takeaway.jpg\") },\n  { id: \"mocha\", name: \"Mocha\", image: require(\"@/assets/images/drinks/mocha.jpg\") },\n  { id: \"french-press\", name: \"French Press\", image: require(\"@/assets/images/drinks/french-press.jpg\") },\n  { id: \"chocolate\", name: \"Chocolate\", image: require(\"@/assets/images/drinks/chocolate.jpg\") },\n  { id: \"matcha\", name: \"Matcha\", image: require(\"@/assets/images/drinks/matcha.jpg\") },\n];\n\nexport function ImagePickerModal({ visible, onClose, onSelectImage }: ImagePickerModalProps) {\n  const { theme } = useTheme();\n  const insets = useSafeAreaInsets();\n  const { height: windowHeight, width: windowWidth } = useWindowDimensions();\n\n  const MODAL_HEIGHT = windowHeight * 0.9;\n  const IMAGE_SIZE = (windowWidth - Spacing.xl * 2 - Spacing.md) / 2;\n\n  const translateY = useSharedValue(MODAL_HEIGHT);\n  const startY = useSharedValue(0);\n\n  useEffect(() => {\n    if (visible) {\n      translateY.value = MODAL_HEIGHT;\n      \n        translateY.value = withSpring(0);\n    } else {\n      translateY.value = MODAL_HEIGHT;\n    }\n  }, [visible, translateY, MODAL_HEIGHT]);\n\n  const closeModal = () => {\n    translateY.value = withTiming(MODAL_HEIGHT, { duration: 200 }, () => {\n      runOnJS(onClose)();\n    });\n  };\n\n  const panGesture = Gesture.Pan()\n    .onStart(() => {\n      startY.value = translateY.value;\n    })\n    .onUpdate((event) => {\n      const nextY = Math.max(0, startY.value + event.translationY);\n      translateY.value = nextY;\n    })\n    .onEnd((event) => {\n      const shouldClose = translateY.value > MODAL_HEIGHT * 0.35 || event.velocityY > 800;\n      if (shouldClose) {\n        translateY.value = withTiming(MODAL_HEIGHT, { duration: 200 }, () => {\n          runOnJS(onClose)();\n        });\n      } else {\n        translateY.value = withSpring(0, { damping: 16, stiffness: 200 });\n      }\n    });\n\n  const sheetStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: translateY.value }],\n  }));\n\n  const handleUploadCustom = async () => {\n    try {\n      const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();\n      \n      if (!permissionResult.granted) {\n        Alert.alert(\"Permission Required\", \"Please allow access to your photo library to upload custom images.\");\n        return;\n      }\n\n      const result = await ImagePicker.launchImageLibraryAsync({\n        mediaTypes: ImagePicker.MediaTypeOptions.Images,\n        allowsEditing: true,\n        aspect: [1, 1],\n        quality: 0.8,\n      });\n\n      if (!result.canceled && result.assets[0]) {\n        onSelectImage(result.assets[0].uri);\n        closeModal();\n      }\n    } catch (error) {\n      Alert.alert(\"Error\", \"Failed to pick image. Please try again.\");\n    }\n  };\n\n  const handleSelectPreset = (presetId: string) => {\n    onSelectImage(`preset:${presetId}`);\n    closeModal();\n  };\n\n  if (!visible) return null;\n\n  return (\n    <Modal\n      visible={visible}\n      transparent\n      statusBarTranslucent\n      animationType=\"fade\"\n      onRequestClose={closeModal}\n    >\n      <GestureHandlerRootView style={{ flex: 1 }} >\n      <View style={styles.overlay}>\n        <Pressable style={styles.backdrop} onPress={closeModal} />\n\n        {/* <GestureDetector gesture={panGesture}> */}\n          <Animated.View\n            style={[\n              styles.modalContent,\n              sheetStyle,\n              {\n                backgroundColor: theme.backgroundRoot,\n                paddingBottom: insets.bottom + Spacing.lg,\n                maxHeight: MODAL_HEIGHT,\n              },\n            ]}\n          >\n            <GestureDetector gesture={panGesture}>\n            <View style={styles.handleContainer}>\n              <View style={[styles.handle, { backgroundColor: Colors.light.accent }]} />\n              <ThemedText type=\"h3\" style={styles.title}>Select Image</ThemedText>\n            </View>\n            </GestureDetector>\n            \n\n            <ScrollView\n              style={styles.scrollContent}\n              showsVerticalScrollIndicator={false}\n              contentContainerStyle={styles.gridContainer}\n            >\n              <Pressable\n                onPress={handleUploadCustom}\n                style={[\n                  styles.imageCard,\n                  { \n                    width: IMAGE_SIZE, \n                    height: IMAGE_SIZE,\n                    backgroundColor: theme.backgroundSecondary,\n                  }\n                ]}\n              >\n                <Feather name=\"upload\" size={32} color={theme.textMuted} />\n                <ThemedText type=\"small\" muted style={styles.uploadText}>Upload custom</ThemedText>\n              </Pressable>\n\n              {PRESET_IMAGES.map((preset) => (\n                <Pressable\n                  key={preset.id}\n                  onPress={() => handleSelectPreset(preset.id)}\n                  style={[\n                    styles.imageCard,\n                    { \n                      width: IMAGE_SIZE, \n                      height: IMAGE_SIZE,\n                      backgroundColor: theme.backgroundSecondary,\n                    }\n                  ]}\n                >\n                  <Image \n                    source={preset.image} \n                    style={styles.presetImage}\n                    resizeMode=\"contain\"\n                  />\n                </Pressable>\n              ))}\n            </ScrollView>\n          </Animated.View>\n        {/* </GestureDetector> */}\n      </View>\n      </GestureHandlerRootView>\n    </Modal>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    flex: 1,\n    justifyContent: \"flex-end\",\n  },\n  backdrop: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n  },\n  modalContent: {\n    borderTopLeftRadius: BorderRadius.xl,\n    borderTopRightRadius: BorderRadius.xl,\n  },\n  handleContainer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing.md,\n  },\n  handle: {\n    width: 40,\n    height: 4,\n    borderRadius: 2,\n  },\n  title: {\n    textAlign: \"center\",\n    marginBottom: Spacing.lg,\n  },\n  scrollContent: {\n    paddingHorizontal: Spacing.xl,\n  },\n  gridContainer: {\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    gap: Spacing.md,\n    paddingBottom: Spacing.xl,\n  },\n  imageCard: {\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  uploadText: {\n    textAlign: \"center\",\n    marginTop: Spacing.sm,\n  },\n  presetImage: {\n    width: \"85%\",\n    height: \"85%\",\n  },\n});\n","path":null,"size_bytes":7705,"size_tokens":null},"components/CaffeineGraphNew.tsx":{"content":"import React, { useMemo, useRef, useCallback, useState, useEffect } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Text,\n  ScrollView,\n  NativeSyntheticEvent,\n  NativeScrollEvent,\n  useWindowDimensions,\n  Pressable,\n} from \"react-native\";\nimport Svg, {\n  Path,\n  Line,\n  Defs,\n  LinearGradient,\n  Stop,\n  Circle,\n  Text as SvgText,\n  G,\n  Image as SvgImage,\n  ClipPath,\n} from \"react-native-svg\";\nimport { Feather } from \"@expo/vector-icons\";\nimport {\n  CaffeineEvent,\n  buildSampleTimes,\n  computeActiveCurve,\n  getActiveAtTime,\n  formatTimeLabel,\n  formatCurrentTime,\n  generateSmoothPath,\n  getMaxCaffeineInSleepWindowForDisplay,\n  getSleepWindowStatusMessage,\n  parseBedtimeToMs,\n} from \"@/utils/graphUtils\";\n\ninterface GraphColors {\n  bg: string;\n  bgSecondary: string;\n  accentGold: string;\n  darkBrown: string;\n  darkBrown2: string;\n  green: string;\n  blue: string;\n  mutedGrey: string;\n  dangerRed: string;\n  areaFill: string;\n  areaFillEnd: string;\n}\n\nconst LIGHT_GRAPH_COLORS: GraphColors = {\n  bg: \"#FFFFFF\",\n  bgSecondary: \"#F5F5F5\",\n  accentGold: \"#C9A36A\",\n  darkBrown: \"#5C4A3B\",\n  darkBrown2: \"#6A513B\",\n  green: \"#53A451\",\n  blue: \"#4DA3FF\",\n  mutedGrey: \"#9E9E9E\",\n  dangerRed: \"#D9534F\",\n  areaFill: \"#E8DFD0\",\n  areaFillEnd: \"#F5F0E8\",\n};\n\nconst DARK_GRAPH_COLORS: GraphColors = {\n  bg: \"#1F1815\",\n  bgSecondary: \"#2A2420\",\n  accentGold: \"#C9A36A\",\n  darkBrown: \"#F5EBDD\",\n  darkBrown2: \"#E8DFD4\",\n  green: \"#53A451\",\n  blue: \"#4DA3FF\",\n  mutedGrey: \"#A0A0A0\",\n  dangerRed: \"#D9534F\",\n  areaFill: \"#3D3530\",\n  areaFillEnd: \"#2A2420\",\n};\n\ninterface CaffeineGraphProps {\n  events: CaffeineEvent[];\n  now?: string;\n  halfLifeHours?: number;\n  sampleResolutionMinutes?: number;\n  yMax?: number;\n  sleepThresholdMg?: number;\n  optimalCaffeineMg?: number;\n  bedtime: string;\n  onScrollOffsetChange?: (isOffCenter: boolean, direction: 'left' | 'right' | null) => void;\n  scrollViewRef?: React.RefObject<ScrollView | null>;\n  isDark?: boolean;\n  dayWindowStart: number;\n  dayWindowEnd: number;\n  onExtendDays?: (direction: 'left' | 'right') => void;\n  resetKey?: number;\n  onEventClick?: (event: CaffeineEvent) => void;\n  onStackedEventsClick?: (events: CaffeineEvent[], position: { x: number; y: number }) => void;\n}\n\nconst Y_AXIS_WIDTH = 24;\nconst LEFT_PADDING = 0;\nconst RIGHT_PADDING = 0;\nconst X_AXIS_HEIGHT = 22;\nconst GRAPH_PADDING_TOP = 8;\nconst GRAPH_PADDING_BOTTOM = 8;\nconst MARKER_SIZE = 18;\nconst MARKER_IMAGE_SIZE = 14;\nconst HOURS_VISIBLE = 12;\nconst GROUP_PROXIMITY_PX = 15;\nconst HOURS_PER_DAY = 24;\nconst EDGE_THRESHOLD = 50;\n\ninterface EventGroup {\n  events: CaffeineEvent[];\n  x: number;\n  y: number;\n  iconY: number;\n  category: string;\n  imageUri?: string;\n}\n\nconst CATEGORY_IMAGES: Record<string, any> = {\n  coffee: require(\"@/assets/CaffeineSourceImages/coffee.png\"),\n  tea: require(\"@/assets/CaffeineSourceImages/tea.jpg\"),\n  energy: require(\"@/assets/CaffeineSourceImages/energy.png\"),\n  soda: require(\"@/assets/CaffeineSourceImages/soda.png\"),\n  chocolate: require(\"@/assets/CaffeineSourceImages/chocolate.png\"),\n};\n\nconst resolveImageSource = (imageUri: string | undefined): any => {\n  if (!imageUri) return null;\n  if (imageUri.startsWith(\"category:\")) {\n    const category = imageUri.replace(\"category:\", \"\");\n    return CATEGORY_IMAGES[category];\n  }\n  if (imageUri.startsWith(\"preset:\")) {\n    const { PRESET_IMAGES } = require(\"@/components/ImagePickerModal\");\n    const preset = PRESET_IMAGES.find((p: any) => p.id === imageUri.replace(\"preset:\", \"\"));\n    return preset?.image;\n  }\n  return imageUri;\n};\n\nexport function CaffeineGraphNew({\n  events,\n  now = new Date().toISOString(),\n  halfLifeHours = 5.5,\n  sampleResolutionMinutes = 5,\n  yMax = 450,\n  sleepThresholdMg = 100,\n  optimalCaffeineMg = 200,\n  bedtime,\n  onScrollOffsetChange,\n  scrollViewRef,\n  isDark = false,\n  dayWindowStart,\n  dayWindowEnd,\n  onExtendDays,\n  resetKey = 0,\n  onEventClick,\n  onStackedEventsClick,\n}: CaffeineGraphProps) {\n  const GRAPH_COLORS = isDark ? DARK_GRAPH_COLORS : LIGHT_GRAPH_COLORS;\n  const { width: windowWidth, height: windowHeight } = useWindowDimensions();\n  \n  const viewWindowHours = (dayWindowEnd - dayWindowStart + 1) * HOURS_PER_DAY;\n  const graphHeight = windowHeight * 0.32;\n  const chartHeight = graphHeight - X_AXIS_HEIGHT - GRAPH_PADDING_TOP - GRAPH_PADDING_BOTTOM;\n  const scrollContentWidth = windowWidth * (viewWindowHours / HOURS_VISIBLE);\n  const chartWidth = scrollContentWidth;\n\n  const [realTimeNow, setRealTimeNow] = useState(Date.now());\n  \n  useEffect(() => {\n    const interval = setInterval(() => {\n      setRealTimeNow(Date.now());\n    }, 60000);\n    return () => clearInterval(interval);\n  }, []);\n\n  const nowMs = realTimeNow;\n  const nowDate = new Date(nowMs);\n\n  const { startMs, endMs } = useMemo(() => {\n    const todayStart = new Date(nowMs);\n    todayStart.setHours(0, 0, 0, 0);\n    const start = todayStart.getTime() + dayWindowStart * HOURS_PER_DAY * 3600000;\n    const end = todayStart.getTime() + (dayWindowEnd + 1) * HOURS_PER_DAY * 3600000;\n    return { startMs: start, endMs: end };\n  }, [nowMs, dayWindowStart, dayWindowEnd]);\n\n  const sampleTimesMs = useMemo(() => {\n    const samples: number[] = [];\n    const stepMs = sampleResolutionMinutes * 60000;\n    for (let t = startMs; t <= endMs; t += stepMs) {\n      samples.push(t);\n    }\n    return samples;\n  }, [startMs, endMs, sampleResolutionMinutes]);\n\n  const curveData = useMemo(() => {\n    return computeActiveCurve(events, sampleTimesMs, halfLifeHours);\n  }, [events, sampleTimesMs, halfLifeHours]);\n\n  const currentActiveMg = useMemo(() => {\n    return getActiveAtTime(events, nowMs, halfLifeHours);\n  }, [events, nowMs, halfLifeHours]);\n\n  const bedtimeMs = useMemo(() => {\n    return parseBedtimeToMs(bedtime, nowDate);\n  }, [bedtime, nowMs]);\n\n  const timeToX = useCallback(\n    (ms: number): number => {\n      const ratio = (ms - startMs) / (endMs - startMs);\n      return ratio * chartWidth;\n    },\n    [startMs, endMs, chartWidth]\n  );\n\n  const mgToY = useCallback(\n    (mg: number): number => {\n      const ratio = mg / yMax;\n      return GRAPH_PADDING_TOP + chartHeight * (1 - ratio);\n    },\n    [yMax, chartHeight]\n  );\n\n  const curvePoints = useMemo(() => {\n    return curveData.map((pt) => ({\n      x: timeToX(pt.t),\n      y: mgToY(pt.mg),\n    }));\n  }, [curveData, timeToX, mgToY]);\n\n  const curvePath = useMemo(() => {\n    return generateSmoothPath(curvePoints, 0.2);\n  }, [curvePoints]);\n\n  const areaPath = useMemo(() => {\n    if (curvePoints.length < 2) return \"\";\n    const baseY = mgToY(0);\n    let path = `M ${curvePoints[0].x} ${baseY}`;\n    path += ` L ${curvePoints[0].x} ${curvePoints[0].y}`;\n    path += curvePath.substring(curvePath.indexOf(\"C\") - 1);\n    path += ` L ${curvePoints[curvePoints.length - 1].x} ${baseY}`;\n    path += \" Z\";\n    return path;\n  }, [curvePoints, curvePath, mgToY]);\n\n  const yAxisTicks = useMemo(() => {\n    const ticks = [50];\n    const step = yMax <= 200 ? 50 : 100;\n    for (let mg = step; mg <= yMax; mg += step) {\n      if (mg !== 50) ticks.push(mg);\n    }\n    return ticks.sort((a, b) => a - b);\n  }, [yMax]);\n\n  const xAxisTicks = useMemo(() => {\n    const ticks = [];\n    const startHour = new Date(startMs);\n    startHour.setMinutes(0, 0, 0);\n    let currentMs = startHour.getTime();\n    if (currentMs < startMs) {\n      currentMs += 3600000;\n    }\n    while (currentMs <= endMs) {\n      ticks.push(currentMs);\n      currentMs += 3600000;\n    }\n    return ticks;\n  }, [startMs, endMs]);\n\n  const dateMarkers = useMemo(() => {\n    const markers: { ms: number; label: string }[] = [];\n    const startDate = new Date(startMs);\n    startDate.setHours(0, 0, 0, 0);\n    let currentMs = startDate.getTime();\n    if (currentMs < startMs) {\n      currentMs += 24 * 3600000;\n    }\n    while (currentMs <= endMs) {\n      const date = new Date(currentMs);\n      const day = date.getDate();\n      const month = date.toLocaleDateString(\"en-US\", { month: \"short\" });\n      const year = date.getFullYear().toString().slice(-2);\n      markers.push({ ms: currentMs, label: `${day} ${month}, ${year}` });\n      currentMs += 24 * 3600000;\n    }\n    return markers;\n  }, [startMs, endMs]);\n\n\n  const nowX = timeToX(nowMs);\n  const bedtimeX = timeToX(bedtimeMs);\n  const sleepThresholdY = mgToY(sleepThresholdMg);\n  const optimalCaffeineY = mgToY(optimalCaffeineMg);\n  \n  const [showLegend, setShowLegend] = useState(false);\n\n  const maxCaffeineInSleepWindow = useMemo(() => {\n    return getMaxCaffeineInSleepWindowForDisplay(events, bedtime, nowMs, halfLifeHours, 6);\n  }, [events, bedtime, nowMs, halfLifeHours]);\n\n  const { message: sleepMessage, color: sleepColor } = getSleepWindowStatusMessage(\n    maxCaffeineInSleepWindow\n  );\n\n  const statusTextColor =\n    sleepColor === \"green\"\n      ? GRAPH_COLORS.green\n      : sleepColor === \"brown\"\n        ? GRAPH_COLORS.accentGold\n        : GRAPH_COLORS.darkBrown;\n\n  const defaultScrollX = useMemo(() => {\n    if (nowMs >= startMs && nowMs <= endMs) {\n      const nowPosition = ((nowMs - startMs) / (endMs - startMs)) * scrollContentWidth;\n      return Math.max(0, nowPosition - windowWidth / 2);\n    }\n    return scrollContentWidth / 2 - windowWidth / 2;\n  }, [nowMs, startMs, endMs, scrollContentWidth, windowWidth]);\n\n  const lastExtendRef = useRef<number>(0);\n  const hasInitialScrolled = useRef<boolean>(false);\n  const prevDayWindowStartRef = useRef<number>(dayWindowStart);\n  const currentScrollXRef = useRef<number>(defaultScrollX);\n\n  useEffect(() => {\n    if (scrollViewRef?.current && !hasInitialScrolled.current) {\n      hasInitialScrolled.current = true;\n      setTimeout(() => {\n        scrollViewRef.current?.scrollTo({ x: defaultScrollX, y: 0, animated: false });\n      }, 0);\n    }\n  }, []);\n\n  useEffect(() => {\n    if (!hasInitialScrolled.current) return;\n    \n    const daysDelta = prevDayWindowStartRef.current - dayWindowStart;\n    if (daysDelta !== 0 && scrollViewRef?.current) {\n      const pixelsPerDay = (windowWidth * HOURS_PER_DAY) / HOURS_VISIBLE;\n      const offsetAdjustment = daysDelta * pixelsPerDay;\n      const newScrollX = currentScrollXRef.current + offsetAdjustment;\n      \n      setTimeout(() => {\n        scrollViewRef.current?.scrollTo({ x: Math.max(0, newScrollX), y: 0, animated: false });\n      }, 0);\n    }\n    prevDayWindowStartRef.current = dayWindowStart;\n  }, [dayWindowStart, dayWindowEnd, windowWidth]);\n\n  useEffect(() => {\n    if (resetKey > 0 && scrollViewRef?.current) {\n      prevDayWindowStartRef.current = dayWindowStart;\n      currentScrollXRef.current = defaultScrollX;\n      setTimeout(() => {\n        scrollViewRef.current?.scrollTo({ x: defaultScrollX, y: 0, animated: true });\n      }, 50);\n    }\n  }, [resetKey]);\n\n  const handleScroll = useCallback(\n    (event: NativeSyntheticEvent<NativeScrollEvent>) => {\n      const scrollX = event.nativeEvent.contentOffset.x;\n      const contentWidth = event.nativeEvent.contentSize.width;\n      const viewportWidth = event.nativeEvent.layoutMeasurement.width;\n      const maxScrollX = contentWidth - viewportWidth;\n\n      currentScrollXRef.current = scrollX;\n\n      if (onScrollOffsetChange) {\n        const centerX = scrollX + windowWidth / 2;\n        const nowPosition = nowMs >= startMs && nowMs <= endMs \n          ? ((nowMs - startMs) / (endMs - startMs)) * scrollContentWidth \n          : -1;\n        const isOffCenter = nowPosition < 0 || Math.abs(centerX - nowPosition) > windowWidth * 0.1;\n        const direction: 'left' | 'right' | null = isOffCenter \n          ? (nowPosition < 0 ? (dayWindowEnd < 1 ? 'right' : 'left') : (centerX < nowPosition ? 'right' : 'left')) \n          : null;\n        onScrollOffsetChange(isOffCenter, direction);\n      }\n\n      const now = Date.now();\n      if (now - lastExtendRef.current < 300) return;\n\n      if (onExtendDays) {\n        if (scrollX <= EDGE_THRESHOLD) {\n          lastExtendRef.current = now;\n          onExtendDays('left');\n        } else if (scrollX >= maxScrollX - EDGE_THRESHOLD) {\n          lastExtendRef.current = now;\n          onExtendDays('right');\n        }\n      }\n    },\n    [onScrollOffsetChange, onExtendDays, nowMs, startMs, endMs, scrollContentWidth, windowWidth, dayWindowEnd]\n  );\n\n  const gradientId = isDark ? \"curveGradientDark\" : \"curveGradientLight\";\n\n  const eventGroups = useMemo(() => {\n    const visibleEvents = events\n      .map(evt => {\n        const eventMs = Date.parse(evt.timestampISO);\n        if (eventMs < startMs || eventMs > endMs) return null;\n        const x = timeToX(eventMs);\n        const y = mgToY(getActiveAtTime(events, eventMs, halfLifeHours));\n        return { evt, x, y, eventMs };\n      })\n      .filter((e): e is NonNullable<typeof e> => e !== null)\n      .sort((a, b) => a.eventMs - b.eventMs);\n\n    const groups: EventGroup[] = [];\n    let lastX = -Infinity;\n    for (const item of visibleEvents) {\n      const lastGroup = groups[groups.length - 1];\n      if (lastGroup && Math.abs(item.x - lastX) <= GROUP_PROXIMITY_PX) {\n        lastGroup.events.push(item.evt);\n        lastX = item.x;\n      } else {\n        const iconY = Math.max(GRAPH_PADDING_TOP + MARKER_IMAGE_SIZE / 2, item.y - MARKER_IMAGE_SIZE / 2 - 6);\n        groups.push({\n          events: [item.evt],\n          x: item.x,\n          y: item.y,\n          iconY,\n          category: item.evt.category || 'coffee',\n          imageUri: item.evt.imageUri,\n        });\n        lastX = item.x;\n      }\n    }\n\n    return { visibleEvents, groups };\n  }, [events, startMs, endMs, timeToX, mgToY, halfLifeHours]);\n\n  const handleMarkerPress = useCallback((group: EventGroup, pageX: number, pageY: number) => {\n    if (group.events.length === 1) {\n      onEventClick?.(group.events[0]);\n    } else {\n      onStackedEventsClick?.(group.events, { x: pageX, y: pageY });\n    }\n  }, [onEventClick, onStackedEventsClick]);\n\n  return (\n    <View style={[styles.container, { height: graphHeight, backgroundColor: GRAPH_COLORS.bg }]}>\n      <View style={[styles.yAxisContainer]}>\n        {yAxisTicks.map((mg) => (\n          <View\n            key={mg}\n            style={[\n              styles.yAxisTickRow,\n              { top: mgToY(mg) - 4 },\n            ]}\n          >\n            <Text style={[styles.yAxisLabel, { color: GRAPH_COLORS.mutedGrey }]}>{mg}</Text>\n          </View>\n        ))}\n        <Pressable \n          style={styles.infoButton} \n          onPress={() => setShowLegend(true)}\n          hitSlop={{ top: 8, bottom: 8, left: 8, right: 8 }}\n        >\n          <Feather name=\"info\" size={14} color={GRAPH_COLORS.mutedGrey} />\n        </Pressable>\n      </View>\n      \n      {showLegend && (\n        <>\n          <Pressable style={styles.legendOverlay} onPress={() => setShowLegend(false)} />\n          <View style={[styles.legendCard, { backgroundColor: GRAPH_COLORS.bg }]}>\n            {/* <Text style={[styles.legendTitle, { color: GRAPH_COLORS.darkBrown2 }]}>Graph Legend</Text> */}\n            <View style={styles.legendRow}>\n              <View style={[styles.legendLine, { backgroundColor: GRAPH_COLORS.green }]} />\n              <Text style={[styles.legendText, { color: GRAPH_COLORS.darkBrown }]}>Sleep threshold - caffeine below this won't affect sleep</Text>\n            </View>\n            <View style={styles.legendRow}>\n              <View style={[styles.legendLineDashed, { borderColor: GRAPH_COLORS.accentGold }]} />\n              <Text style={[styles.legendText, { color: GRAPH_COLORS.darkBrown }]}>Your optimal daily caffeine level</Text>\n            </View>\n          </View>\n        </>\n      )}\n\n      <ScrollView\n        ref={scrollViewRef}\n        horizontal\n        showsHorizontalScrollIndicator={false}\n        contentOffset={{ x: defaultScrollX, y: 0 }}\n        onScroll={handleScroll}\n        scrollEventThrottle={16}\n        style={styles.scrollView}\n        contentContainerStyle={{ width: scrollContentWidth, flexDirection: 'column' }}\n      >\n        <Svg\n          width={scrollContentWidth}\n          height={graphHeight - X_AXIS_HEIGHT}\n          style={styles.svgChart}\n        >\n          <Defs>\n            <LinearGradient id={gradientId} x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\n              <Stop offset=\"0%\" stopColor={GRAPH_COLORS.areaFill} stopOpacity=\"0.9\" />\n              <Stop offset=\"100%\" stopColor={GRAPH_COLORS.areaFillEnd} stopOpacity=\"0.2\" />\n            </LinearGradient>\n          </Defs>\n\n          {yAxisTicks.map((mg) => (\n            <Line\n              key={`grid-${mg}`}\n              x1={0}\n              y1={mgToY(mg)}\n              x2={scrollContentWidth}\n              y2={mgToY(mg)}\n              stroke={GRAPH_COLORS.darkBrown}\n              strokeOpacity={isDark ? 0.12 : 0.06}\n              strokeWidth={0.5}\n            />\n          ))}\n\n          <Line\n            x1={0}\n            y1={sleepThresholdY}\n            x2={scrollContentWidth}\n            y2={sleepThresholdY}\n            stroke={GRAPH_COLORS.green}\n            strokeWidth={1}\n          />\n\n          <Line\n            x1={0}\n            y1={optimalCaffeineY}\n            x2={scrollContentWidth}\n            y2={optimalCaffeineY}\n            stroke={GRAPH_COLORS.accentGold}\n            strokeWidth={1}\n            strokeDasharray=\"4,3\"\n          />\n\n          {dateMarkers.map((marker) => {\n            const x = timeToX(marker.ms);\n            return (\n              <G key={`date-${marker.ms}`}>\n                <Line\n                  x1={x}\n                  y1={GRAPH_PADDING_TOP}\n                  x2={x}\n                  y2={chartHeight + GRAPH_PADDING_TOP}\n                  stroke={GRAPH_COLORS.mutedGrey}\n                  strokeWidth={0.5}\n                  strokeDasharray=\"3,3\"\n                  strokeOpacity={0.4}\n                />\n                <SvgText\n                  x={x + 4}\n                  y={GRAPH_PADDING_TOP + 8}\n                  fontSize={7}\n                  fill={GRAPH_COLORS.mutedGrey}\n                  textAnchor=\"start\"\n                >\n                  {marker.label}\n                </SvgText>\n              </G>\n            );\n          })}\n\n          {bedtimeMs >= startMs && bedtimeMs <= endMs && (\n            <>\n              <Line\n                x1={bedtimeX}\n                y1={GRAPH_PADDING_TOP}\n                x2={bedtimeX}\n                y2={chartHeight + GRAPH_PADDING_TOP}\n                stroke={GRAPH_COLORS.blue}\n                strokeWidth={1.5}\n                strokeDasharray=\"4,3\"\n              />\n              <SvgText\n                x={bedtimeX}\n                y={GRAPH_PADDING_TOP - 2}\n                fontSize={10}\n                fill={GRAPH_COLORS.blue}\n                textAnchor=\"middle\"\n              >\n                \n              </SvgText>\n            </>\n          )}\n\n          {nowMs >= startMs && nowMs <= endMs && (\n            <Line\n              x1={nowX}\n              y1={GRAPH_PADDING_TOP}\n              x2={nowX}\n              y2={chartHeight + GRAPH_PADDING_TOP}\n              stroke={GRAPH_COLORS.darkBrown2}\n              strokeWidth={1.5}\n            />\n          )}\n\n          <Path d={areaPath} fill={`url(#${gradientId})`} />\n\n          <Path\n            d={curvePath}\n            stroke={GRAPH_COLORS.darkBrown2}\n            strokeWidth={2}\n            fill=\"none\"\n          />\n\n          {eventGroups.visibleEvents.map(item => (\n            <Circle\n              key={`dot-${item.evt.id}`}\n              cx={item.x}\n              cy={item.y}\n              r={3}\n              fill={GRAPH_COLORS.accentGold}\n            />\n          ))}\n          {eventGroups.groups.map((group, idx) => {\n            const { x, iconY, category, imageUri, events: groupEvents } = group;\n            const categoryImage = CATEGORY_IMAGES[category];\n            const resolvedImage = resolveImageSource(imageUri) || categoryImage;\n            const hasImage = !!resolvedImage;\n            const clipId = `clip-group-${idx}`;\n            const count = groupEvents.length;\n\n            return (\n              <G key={`group-${idx}`}>\n                <Defs>\n                  <ClipPath id={clipId}>\n                    <Circle cx={x} cy={iconY} r={MARKER_IMAGE_SIZE / 2} />\n                  </ClipPath>\n                </Defs>\n                <Circle\n                  cx={x}\n                  cy={iconY}\n                  r={MARKER_IMAGE_SIZE / 2 + 2}\n                  fill={GRAPH_COLORS.bgSecondary}\n                  stroke={GRAPH_COLORS.mutedGrey}\n                  strokeWidth={0.5}\n                  strokeOpacity={0.3}\n                />\n                {hasImage ? (\n                  <SvgImage\n                    x={x - MARKER_IMAGE_SIZE / 2}\n                    y={iconY - MARKER_IMAGE_SIZE / 2}\n                    width={MARKER_IMAGE_SIZE}\n                    height={MARKER_IMAGE_SIZE}\n                    href={resolvedImage}\n                    clipPath={`url(#${clipId})`}\n                    preserveAspectRatio=\"xMidYMid slice\"\n                  />\n                ) : (\n                  <SvgText\n                    x={x}\n                    y={iconY + 3}\n                    fontSize={8}\n                    textAnchor=\"middle\"\n                    fill={GRAPH_COLORS.darkBrown}\n                  >\n                    \n                  </SvgText>\n                )}\n                {count > 1 && (\n                  <>\n                    <Circle\n                      cx={x + MARKER_IMAGE_SIZE / 2}\n                      cy={iconY - MARKER_IMAGE_SIZE / 2}\n                      r={6}\n                      fill={GRAPH_COLORS.accentGold}\n                    />\n                    <SvgText\n                      x={x + MARKER_IMAGE_SIZE / 2}\n                      y={iconY - MARKER_IMAGE_SIZE / 2 + 3}\n                      fontSize={8}\n                      fontWeight=\"bold\"\n                      textAnchor=\"middle\"\n                      fill=\"#FFFFFF\"\n                    >\n                      {count}\n                    </SvgText>\n                  </>\n                )}\n              </G>\n            );\n          })}\n        </Svg>\n\n        <View style={styles.markerOverlayContainer} pointerEvents=\"box-none\">\n          {eventGroups.groups.map((group, idx) => {\n            const { x, iconY } = group;\n            const hitSize = MARKER_SIZE + 8;\n            return (\n              <Pressable\n                key={`marker-press-${idx}`}\n                style={[\n                  styles.markerPressable,\n                  {\n                    left: x - hitSize / 2,\n                    top: iconY - hitSize / 2,\n                    width: hitSize,\n                    height: hitSize,\n                  },\n                ]}\n                onPress={(e) => {\n                  const { pageX, pageY } = e.nativeEvent;\n                  handleMarkerPress(group, pageX, pageY);\n                }}\n              />\n            );\n          })}\n        </View>\n\n        <View style={[styles.xAxisContainer, { width: scrollContentWidth }]}>\n          {xAxisTicks.map((tickMs) => {\n            const x = timeToX(tickMs);\n            return (\n              <View key={tickMs} style={[styles.xAxisTick, { left: x - 12 }]}>\n                <Text style={[styles.xAxisLabel, { color: GRAPH_COLORS.mutedGrey }]}>{formatTimeLabel(tickMs)}</Text>\n              </View>\n            );\n          })}\n          {nowMs >= startMs && nowMs <= endMs && (\n            <View style={[styles.currentTimeLabel, { left: nowX - 18 }]}>\n              <Text style={[styles.currentTimeLabelText, { color: GRAPH_COLORS.darkBrown2 }]}>\n                {formatCurrentTime(nowMs)}\n              </Text>\n            </View>\n          )}\n        </View>\n      </ScrollView>\n\n      <View style={styles.activeValueContainer}>\n        <Text style={[styles.activeValueText, { color: GRAPH_COLORS.darkBrown2 }]}>\n          {currentActiveMg.toFixed(1)} mg\n        </Text>\n        <Text style={[styles.activeValueSubtitle, { color: statusTextColor }]}>\n          {sleepMessage}\n        </Text>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    position: \"relative\",\n  },\n  yAxisContainer: {\n    position: \"absolute\",\n    left: 0,\n    top: 0,\n    width: Y_AXIS_WIDTH,\n    height: \"100%\",\n    zIndex: 10,\n    // backgroundColor:\"transparent\",\n  },\n  yAxisTickRow: {\n    position: \"absolute\",\n    left: 0,\n    width: Y_AXIS_WIDTH - 4,\n    alignItems: \"flex-end\",\n  },\n  yAxisLabel: {\n    fontSize: 8,\n    fontWeight: \"500\",\n    backgroundColor: \"transparent\",\n  },\n  scrollView: {\n    flex: 1,\n  },\n  svgChart: {\n    backgroundColor: \"transparent\",\n  },\n  markerOverlayContainer: {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: X_AXIS_HEIGHT,\n  },\n  markerPressable: {\n    position: \"absolute\",\n    borderRadius: 12,\n  },\n  xAxisContainer: {\n    height: X_AXIS_HEIGHT,\n    position: \"relative\",\n    marginTop: 2,\n  },\n  xAxisTick: {\n    position: \"absolute\",\n    width: 24,\n    alignItems: \"center\",\n    top: 0,\n  },\n  xAxisLabel: {\n    fontSize: 7,\n    fontWeight: \"500\",\n  },\n  currentTimeLabel: {\n    position: \"absolute\",\n    width: 36,\n    alignItems: \"center\",\n    top: 8,\n  },\n  currentTimeLabelText: {\n    fontSize: 8,\n    fontWeight: \"600\",\n  },\n  activeValueContainer: {\n    position: \"absolute\",\n    top: GRAPH_PADDING_TOP + 12,\n    right: 8,\n    alignItems: \"flex-end\",\n    zIndex: 20,\n  },\n  activeValueText: {\n    fontSize: 28,\n    fontWeight: \"700\",\n  },\n  activeValueSubtitle: {\n    fontSize: 10,\n    fontWeight: \"500\",\n    marginTop: 2,\n    maxWidth: 140,\n    textAlign: \"right\",\n  },\n  infoButton: {\n    position: \"absolute\",\n    top: GRAPH_PADDING_TOP,\n    left: Y_AXIS_WIDTH + 4,\n    padding: 4,\n  },\n  legendOverlay: {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    zIndex: 19,\n  },\n  legendCard: {\n    position: \"absolute\",\n    top: GRAPH_PADDING_TOP + 24,\n    left: Y_AXIS_WIDTH + 8,\n    padding: 12,\n    borderRadius: 8,\n    width: \"55%\",\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.15,\n    shadowRadius: 4,\n    elevation: 5,\n    zIndex: 20,\n  },\n  legendTitle: {\n    fontSize: 16,\n    fontWeight: \"600\",\n    marginBottom: 12,\n  },\n  legendRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    marginBottom: 10,\n  },\n  legendLine: {\n    width: 24,\n    height: 2,\n    marginRight: 10,\n  },\n  legendLineDashed: {\n    width: 24,\n    height: 0,\n    borderTopWidth: 2,\n    borderStyle: \"dashed\",\n    marginRight: 10,\n  },\n  legendText: {\n    fontSize: 13,\n    flex: 1,\n  },\n});\n\nexport default CaffeineGraphNew;\n","path":null,"size_bytes":26511,"size_tokens":null},"components/DateRangePickerModal.tsx":{"content":"import React, { useState, useEffect, useMemo } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Modal,\n  Pressable,\n  useWindowDimensions,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  withTiming,\n  runOnJS,\n} from \"react-native-reanimated\";\nimport { Gesture, GestureDetector } from \"react-native-gesture-handler\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { Calendar, registerTranslation, en } from \"react-native-paper-dates\";\nimport { Button, Provider as PaperProvider, MD3DarkTheme, MD3LightTheme } from \"react-native-paper\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\n\nregisterTranslation('en', en);\n\nconst BOTTOM_SHEET_HEIGHT_RATIO = 0.55;\nconst CALENDAR_HEADER_OFFSET = 100;\n\nexport type DateRangeOption = \"today\" | \"yesterday\" | \"last30\" | \"last90\" | \"custom\";\n\ninterface DateRange {\n  start: Date;\n  end: Date;\n}\n\ninterface DateRangePickerModalProps {\n  visible: boolean;\n  onClose: () => void;\n  onSelectRange: (option: DateRangeOption, range: DateRange) => void;\n  selectedOption: DateRangeOption;\n  customRange?: DateRange;\n}\n\nconst QUICK_OPTIONS: { label: string; value: DateRangeOption }[] = [\n  { label: \"Today\", value: \"today\" },\n  { label: \"Yesterday\", value: \"yesterday\" },\n  { label: \"Last 30 days\", value: \"last30\" },\n  { label: \"Last 90 days\", value: \"last90\" },\n  { label: \"Custom\", value: \"custom\" },\n];\n\nfunction getDateRange(option: DateRangeOption, customRange?: DateRange): DateRange {\n  const now = new Date();\n  \n  switch (option) {\n    case \"today\": {\n      const start = new Date(now);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(now);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    }\n    case \"yesterday\": {\n      const start = new Date(now);\n      start.setDate(start.getDate() - 1);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    }\n    case \"last30\": {\n      const start = new Date(now);\n      start.setDate(start.getDate() - 30);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(now);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    }\n    case \"last90\": {\n      const start = new Date(now);\n      start.setDate(start.getDate() - 90);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(now);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    }\n    case \"custom\":\n      return customRange || { start: now, end: now };\n    default:\n      return { start: now, end: now };\n  }\n}\n\nexport function DateRangePickerModal({ \n  visible, \n  onClose, \n  onSelectRange, \n  selectedOption,\n  customRange \n}: DateRangePickerModalProps) {\n  const { theme, isDark } = useTheme();\n  const insets = useSafeAreaInsets();\n  const { width: windowWidth, height: windowHeight } = useWindowDimensions();\n\n  const [localOption, setLocalOption] = useState<DateRangeOption>(selectedOption);\n  const [fromDate, setFromDate] = useState<Date>(customRange?.start || new Date());\n  const [toDate, setToDate] = useState<Date>(customRange?.end || new Date());\n  const [showFromDatePicker, setShowFromDatePicker] = useState(false);\n  const [showToDatePicker, setShowToDatePicker] = useState(false);\n  const [selectedCalendarDate, setSelectedCalendarDate] = useState<Date | undefined>(undefined);\n  const [editingField, setEditingField] = useState<\"from\" | \"to\">(\"from\");\n\n  const MODAL_HEIGHT = windowHeight * BOTTOM_SHEET_HEIGHT_RATIO;\n  const translateY = useSharedValue(MODAL_HEIGHT);\n  const startY = useSharedValue(0);\n\n  const calendarModalWidth = Math.min(windowWidth * 0.9, 400);\n  const calendarCellSize = calendarModalWidth / 7;\n  const calendarFixedHeight = (calendarCellSize * 6) + CALENDAR_HEADER_OFFSET;\n\n  const accentColor = isDark ? Colors.dark.accent : Colors.light.accent;\n  \n  const paperTheme = useMemo(() => {\n    const baseTheme = isDark ? MD3DarkTheme : MD3LightTheme;\n    const themeColors = isDark ? Colors.dark : Colors.light;\n    return {\n      ...baseTheme,\n      colors: {\n        ...baseTheme.colors,\n        primary: accentColor,\n        primaryContainer: isDark ? themeColors.backgroundSecondary : `${accentColor}20`,\n        onPrimaryContainer: isDark ? themeColors.text : accentColor,\n        secondary: accentColor,\n        secondaryContainer: isDark ? themeColors.backgroundSecondary : `${accentColor}15`,\n        onSecondaryContainer: themeColors.text,\n        surface: themeColors.backgroundRoot,\n        surfaceVariant: isDark ? themeColors.backgroundSecondary : themeColors.backgroundTertiary,\n        onSurface: themeColors.text,\n        onSurfaceVariant: themeColors.textMuted,\n        outline: themeColors.divider,\n        background: themeColors.backgroundRoot,\n        onBackground: themeColors.text,\n        elevation: {\n          level0: \"transparent\",\n          level1: themeColors.backgroundDefault,\n          level2: themeColors.backgroundSecondary,\n          level3: themeColors.backgroundTertiary,\n          level4: themeColors.backgroundTertiary,\n          level5: themeColors.backgroundTertiary,\n        },\n      },\n    };\n  }, [isDark, accentColor]);\n\n  useEffect(() => {\n    if (visible) {\n      setLocalOption(selectedOption);\n      if (customRange) {\n        setFromDate(customRange.start);\n        setToDate(customRange.end);\n      } else {\n        const now = new Date();\n        const thirtyDaysAgo = new Date(now);\n        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 7);\n        setFromDate(thirtyDaysAgo);\n        setToDate(now);\n      }\n      translateY.value = MODAL_HEIGHT;\n      setTimeout(() => {\n        translateY.value = withSpring(0, { damping: 16, stiffness: 200 });\n      }, 50);\n    } else {\n      translateY.value = MODAL_HEIGHT;\n    }\n  }, [visible, translateY, selectedOption, customRange]);\n\n  const closeModal = () => {\n    translateY.value = withTiming(MODAL_HEIGHT, { duration: 200 }, () => {\n      runOnJS(onClose)();\n    });\n  };\n\n  const panGesture = Gesture.Pan()\n    .onStart(() => {\n      startY.value = translateY.value;\n    })\n    .onUpdate((event) => {\n      const nextY = Math.max(0, startY.value + event.translationY);\n      translateY.value = nextY;\n    })\n    .onEnd((event) => {\n      const shouldClose = translateY.value > MODAL_HEIGHT * 0.35 || event.velocityY > 800;\n      if (shouldClose) {\n        translateY.value = withTiming(MODAL_HEIGHT, { duration: 200 }, () => {\n          runOnJS(onClose)();\n        });\n      } else {\n        translateY.value = withSpring(0, { damping: 16, stiffness: 200 });\n      }\n    });\n\n  const sheetStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: translateY.value }],\n  }));\n\n  const handleQuickSelect = (option: DateRangeOption) => {\n    setLocalOption(option);\n    if (option !== \"custom\") {\n      const range = getDateRange(option);\n      onSelectRange(option, range);\n      closeModal();\n    }\n  };\n\n  const handleFromDatePress = () => {\n    setEditingField(\"from\");\n    setSelectedCalendarDate(fromDate);\n    setShowFromDatePicker(true);\n  };\n\n  const handleToDatePress = () => {\n    setEditingField(\"to\");\n    setSelectedCalendarDate(toDate);\n    setShowToDatePicker(true);\n  };\n\n  const onCalendarChange = (params: { date: Date | undefined }) => {\n    if (params.date) {\n      setSelectedCalendarDate(params.date);\n    }\n  };\n\n  const onFromDateConfirm = () => {\n    setShowFromDatePicker(false);\n    if (selectedCalendarDate) {\n      const newFromDate = new Date(selectedCalendarDate);\n      newFromDate.setHours(0, 0, 0, 0);\n      setFromDate(newFromDate);\n      if (newFromDate > toDate) {\n        setToDate(newFromDate);\n      }\n    }\n  };\n\n  const onToDateConfirm = () => {\n    setShowToDatePicker(false);\n    if (selectedCalendarDate) {\n      const newToDate = new Date(selectedCalendarDate);\n      newToDate.setHours(23, 59, 59, 999);\n      setToDate(newToDate);\n      if (newToDate < fromDate) {\n        setFromDate(newToDate);\n      }\n    }\n  };\n\n  const handleApplyCustomRange = () => {\n    const range = { start: fromDate, end: toDate };\n    onSelectRange(\"custom\", range);\n    closeModal();\n  };\n\n  const formatDate = (date: Date) => {\n    return date.toLocaleDateString(\"en-US\", {\n      month: \"2-digit\",\n      day: \"2-digit\",\n      year: \"numeric\",\n    });\n  };\n\n  if (!visible) return null;\n\n  return (\n    <PaperProvider theme={paperTheme}>\n      <Modal\n        visible={visible}\n        transparent\n        statusBarTranslucent\n        animationType=\"fade\"\n        onRequestClose={closeModal}\n      >\n        <View style={styles.overlay}>\n          <Pressable style={styles.backdrop} onPress={closeModal} />\n\n          <GestureDetector gesture={panGesture}>\n            <Animated.View\n              style={[\n                styles.modalContent,\n                sheetStyle,\n                {\n                  backgroundColor: theme.backgroundRoot,\n                  paddingBottom: insets.bottom + Spacing.lg,\n                  maxHeight: MODAL_HEIGHT,\n                },\n              ]}\n            >\n              <View style={styles.handleContainer}>\n                <View style={[styles.handle, { backgroundColor: accentColor }]} />\n              </View>\n\n              <View style={styles.content}>\n                <ThemedText type=\"body\" style={styles.sectionTitle}>Quick select</ThemedText>\n                \n                <View style={styles.quickSelectContainer}>\n                  {QUICK_OPTIONS.map((option) => (\n                    <Pressable\n                      key={option.value}\n                      onPress={() => handleQuickSelect(option.value)}\n                      style={[\n                        styles.quickSelectChip,\n                        localOption === option.value\n                          ? { backgroundColor: accentColor }\n                          : { backgroundColor: theme.backgroundSecondary },\n                      ]}\n                    >\n                      <ThemedText\n                        type=\"body\"\n                        style={[\n                          styles.quickSelectText,\n                          localOption === option.value && { color: \"#FFFFFF\" },\n                        ]}\n                      >\n                        {option.label}\n                      </ThemedText>\n                    </Pressable>\n                  ))}\n                </View>\n\n                <ThemedText type=\"body\" style={styles.sectionTitle}>Custom range</ThemedText>\n\n                <View style={styles.customRangeContainer}>\n                  <ThemedText type=\"caption\" muted style={styles.fieldLabel}>From</ThemedText>\n                  <Pressable\n                    onPress={handleFromDatePress}\n                    style={[styles.dateButton, { borderColor: theme.divider }]}\n                  >\n                    <Feather name=\"calendar\" size={18} color={theme.textMuted} />\n                    <ThemedText type=\"body\">{formatDate(fromDate)}</ThemedText>\n                  </Pressable>\n\n                  <ThemedText type=\"caption\" muted style={styles.fieldLabel}>To</ThemedText>\n                  <Pressable\n                    onPress={handleToDatePress}\n                    style={[styles.dateButton, { borderColor: theme.divider }]}\n                  >\n                    <Feather name=\"calendar\" size={18} color={theme.textMuted} />\n                    <ThemedText type=\"body\">{formatDate(toDate)}</ThemedText>\n                  </Pressable>\n\n                  <Pressable\n                    onPress={handleApplyCustomRange}\n                    style={[styles.applyButton, { backgroundColor: accentColor }]}\n                  >\n                    <ThemedText type=\"body\" style={styles.applyButtonText}>Apply</ThemedText>\n                  </Pressable>\n                </View>\n              </View>\n            </Animated.View>\n          </GestureDetector>\n        </View>\n\n        {showFromDatePicker && (\n          <Modal\n            visible={showFromDatePicker}\n            transparent\n            statusBarTranslucent\n            animationType=\"fade\"\n            onRequestClose={() => setShowFromDatePicker(false)}\n          >\n            <View style={styles.centeredOverlay}>\n              <Pressable style={styles.backdrop} onPress={() => setShowFromDatePicker(false)} />\n              <View style={[styles.calendarModal, { backgroundColor: theme.backgroundRoot }]}>\n                <View style={styles.calendarHeader}>\n                  <ThemedText type=\"h4\" style={styles.calendarTitle}>Select Start Date</ThemedText>\n                </View>\n                <View style={[styles.calendarWrapper, { height: calendarFixedHeight }]}>\n                  <Calendar\n                    locale=\"en\"\n                    mode=\"single\"\n                    date={selectedCalendarDate || fromDate}\n                    onChange={onCalendarChange}\n                  />\n                </View>\n                <View style={styles.calendarActions}>\n                  <Button\n                    mode=\"text\"\n                    onPress={() => setShowFromDatePicker(false)}\n                    textColor={theme.textMuted}\n                  >\n                    Cancel\n                  </Button>\n                  <Button\n                    mode=\"contained\"\n                    onPress={onFromDateConfirm}\n                    buttonColor={accentColor}\n                  >\n                    Confirm\n                  </Button>\n                </View>\n              </View>\n            </View>\n          </Modal>\n        )}\n\n        {showToDatePicker && (\n          <Modal\n            visible={showToDatePicker}\n            transparent\n            statusBarTranslucent\n            animationType=\"fade\"\n            onRequestClose={() => setShowToDatePicker(false)}\n          >\n            <View style={styles.centeredOverlay}>\n              <Pressable style={styles.backdrop} onPress={() => setShowToDatePicker(false)} />\n              <View style={[styles.calendarModal, { backgroundColor: theme.backgroundRoot }]}>\n                <View style={styles.calendarHeader}>\n                  <ThemedText type=\"h4\" style={styles.calendarTitle}>Select End Date</ThemedText>\n                </View>\n                <View style={[styles.calendarWrapper, { height: calendarFixedHeight }]}>\n                  <Calendar\n                    locale=\"en\"\n                    mode=\"single\"\n                    date={selectedCalendarDate || toDate}\n                    onChange={onCalendarChange}\n                  />\n                </View>\n                <View style={styles.calendarActions}>\n                  <Button\n                    mode=\"text\"\n                    onPress={() => setShowToDatePicker(false)}\n                    textColor={theme.textMuted}\n                  >\n                    Cancel\n                  </Button>\n                  <Button\n                    mode=\"contained\"\n                    onPress={onToDateConfirm}\n                    buttonColor={accentColor}\n                  >\n                    Confirm\n                  </Button>\n                </View>\n              </View>\n            </View>\n          </Modal>\n        )}\n      </Modal>\n    </PaperProvider>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    flex: 1,\n    justifyContent: \"flex-end\",\n  },\n  centeredOverlay: {\n    flex: 1,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  backdrop: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n  },\n  calendarModal: {\n    borderRadius: BorderRadius.xl,\n    overflow: \"hidden\",\n    maxWidth: 400,\n    width: \"90%\",\n    elevation: 5,\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.25,\n    shadowRadius: 3.84,\n    paddingBottom: Spacing.md,\n  },\n  calendarWrapper: {\n    overflow: \"visible\",\n    paddingBottom: Spacing.sm,\n  },\n  calendarHeader: {\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.lg,\n    paddingBottom: Spacing.sm,\n  },\n  calendarTitle: {\n    fontWeight: \"600\",\n  },\n  calendarActions: {\n    flexDirection: \"row\",\n    justifyContent: \"flex-end\",\n    gap: Spacing.sm,\n    paddingHorizontal: Spacing.lg,\n    paddingTop: Spacing.md,\n  },\n  modalContent: {\n    borderTopLeftRadius: BorderRadius.xl,\n    borderTopRightRadius: BorderRadius.xl,\n  },\n  handleContainer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing.md,\n  },\n  handle: {\n    width: 40,\n    height: 4,\n    borderRadius: 2,\n  },\n  content: {\n    paddingHorizontal: Spacing.xl,\n  },\n  sectionTitle: {\n    fontWeight: \"600\",\n    marginBottom: Spacing.md,\n  },\n  quickSelectContainer: {\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.xl,\n  },\n  quickSelectChip: {\n    paddingVertical: Spacing.sm,\n    paddingHorizontal: Spacing.lg,\n    borderRadius: BorderRadius.xl,\n  },\n  quickSelectText: {\n    fontWeight: \"500\",\n  },\n  customRangeContainer: {\n    marginBottom: Spacing.lg,\n  },\n  fieldLabel: {\n    marginBottom: Spacing.xs,\n  },\n  dateButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n    paddingVertical: Spacing.md,\n    paddingHorizontal: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    borderWidth: 1,\n    marginBottom: Spacing.md,\n  },\n  applyButton: {\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.md,\n    alignItems: \"center\",\n    marginTop: Spacing.sm,\n  },\n  applyButtonText: {\n    color: \"#FFFFFF\",\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":17640,"size_tokens":null},"components/ScreenScrollView.tsx":{"content":"import { ScrollView, ScrollViewProps, StyleSheet, View, ReactNode } from \"react-native\";\nimport { SafeAreaView, useSafeAreaInsets } from \"react-native-safe-area-context\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useScreenInsets } from \"@/hooks/useScreenInsets\";\nimport { Spacing } from \"@/constants/theme\";\n\ninterface ScreenScrollViewProps extends ScrollViewProps {\n  header?: ReactNode;\n}\n\nexport function ScreenScrollView({\n  children,\n  contentContainerStyle,\n  style,\n  header,\n  ...scrollViewProps\n}: ScreenScrollViewProps) {\n  const { theme } = useTheme();\n  const { paddingTop, paddingBottom, scrollInsetBottom } = useScreenInsets();\n  const insets = useSafeAreaInsets();\n\n  return (\n    <View\n      style={[\n        styles.outerContainer,\n        { backgroundColor: theme.backgroundRoot },\n      ]}\n    >\n      <SafeAreaView\n        style={[\n          styles.safeArea,\n          {\n            paddingTop: insets.top,\n            paddingBottom: insets.bottom,\n          },\n        ]}\n        edges={[]}\n      >\n        {header}\n        <ScrollView\n          style={[\n            styles.container,\n            style,\n          ]}\n          contentContainerStyle={[\n            {\n              paddingTop,\n              paddingBottom,\n            },\n            styles.contentContainer,\n            contentContainerStyle,\n          ]}\n          scrollIndicatorInsets={{ bottom: scrollInsetBottom }}\n          {...scrollViewProps}\n        >\n          {children}\n        </ScrollView>\n      </SafeAreaView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  outerContainer: {\n    flex: 1,\n  },\n  safeArea: {\n    flex: 1,\n  },\n  container: {\n    flex: 1,\n  },\n  contentContainer: {\n    paddingHorizontal: Spacing.xl,\n  },\n});\n","path":null,"size_bytes":1748,"size_tokens":null},"screens/DrinkDatabaseScreen.tsx":{"content":"import React, { useState, useMemo } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  TextInput,\n  Pressable,\n  ScrollView,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  FadeIn,\n} from \"react-native-reanimated\";\nimport { ScreenScrollView } from \"@/components/ScreenScrollView\";\nimport { ScreenHeader } from \"@/components/ScreenHeader\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { useCaffeineStore, DrinkItem, DRINK_DATABASE } from \"@/store/caffeineStore\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\ntype Category = \"all\" | \"coffee\" | \"tea\" | \"energy\" | \"soda\" | \"chocolate\";\n\nconst CATEGORIES: { key: Category; label: string; icon: keyof typeof Feather.glyphMap }[] = [\n  { key: \"all\", label: \"All\", icon: \"grid\" },\n  { key: \"coffee\", label: \"Coffee\", icon: \"coffee\" },\n  { key: \"tea\", label: \"Tea\", icon: \"droplet\" },\n  { key: \"energy\", label: \"Energy\", icon: \"zap\" },\n  { key: \"soda\", label: \"Soda\", icon: \"droplet\" },\n  { key: \"chocolate\", label: \"Chocolate\", icon: \"square\" },\n];\n\nexport default function DrinkDatabaseScreen() {\n  const { theme } = useTheme();\n  const { addEntry, getAllDrinks, favorites, toggleFavorite } = useCaffeineStore();\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [selectedCategory, setSelectedCategory] = useState<Category>(\"all\");\n  const [addedDrinkId, setAddedDrinkId] = useState<string | null>(null);\n\n  const allDrinks = getAllDrinks();\n\n  const filteredDrinks = useMemo(() => {\n    let drinks = allDrinks;\n\n    if (selectedCategory !== \"all\") {\n      drinks = drinks.filter((d) => d.category === selectedCategory);\n    }\n\n    if (searchQuery.trim()) {\n      const query = searchQuery.toLowerCase();\n      drinks = drinks.filter(\n        (d) =>\n          d.name.toLowerCase().includes(query) ||\n          d.category.toLowerCase().includes(query),\n      );\n    }\n\n    return drinks;\n  }, [allDrinks, selectedCategory, searchQuery]);\n\n  const groupedDrinks = useMemo(() => {\n    const groups: { [key: string]: DrinkItem[] } = {};\n\n    filteredDrinks.forEach((drink) => {\n      const category = drink.category.charAt(0).toUpperCase() + drink.category.slice(1);\n      if (!groups[category]) {\n        groups[category] = [];\n      }\n      groups[category].push(drink);\n    });\n\n    return Object.entries(groups).sort((a, b) => a[0].localeCompare(b[0]));\n  }, [filteredDrinks]);\n\n  const handleQuickAdd = (drink: DrinkItem) => {\n    addEntry(drink, drink.defaultServingMl);\n    setAddedDrinkId(drink.id);\n    setTimeout(() => setAddedDrinkId(null), 1500);\n  };\n\n  const getCategoryIcon = (category: string): keyof typeof Feather.glyphMap => {\n    switch (category) {\n      case \"coffee\":\n        return \"coffee\";\n      case \"tea\":\n        return \"droplet\";\n      case \"energy\":\n        return \"zap\";\n      case \"soda\":\n        return \"droplet\";\n      case \"chocolate\":\n        return \"square\";\n      default:\n        return \"circle\";\n    }\n  };\n\n  return (\n    <ScreenScrollView header={<ScreenHeader title=\"Drink Database\" showBackButton={true} />}>\n      <View style={styles.searchContainer}>\n        <View\n          style={[styles.searchBox, { backgroundColor: theme.backgroundDefault }]}\n        >\n          <Feather name=\"search\" size={20} color={theme.textMuted} />\n          <TextInput\n            style={[styles.searchInput, { color: theme.text }]}\n            placeholder=\"Search drinks...\"\n            placeholderTextColor={theme.textMuted}\n            value={searchQuery}\n            onChangeText={setSearchQuery}\n          />\n          {searchQuery.length > 0 && (\n            <Pressable onPress={() => setSearchQuery(\"\")}>\n              <Feather name=\"x\" size={20} color={theme.textMuted} />\n            </Pressable>\n          )}\n        </View>\n      </View>\n\n      <ScrollView\n        horizontal\n        showsHorizontalScrollIndicator={false}\n        style={styles.categoriesScroll}\n        contentContainerStyle={styles.categoriesContent}\n      >\n        {CATEGORIES.map((cat) => (\n          <CategoryChip\n            key={cat.key}\n            label={cat.label}\n            icon={cat.icon}\n            isActive={selectedCategory === cat.key}\n            onPress={() => setSelectedCategory(cat.key)}\n          />\n        ))}\n      </ScrollView>\n\n      {filteredDrinks.length === 0 ? (\n        <ThemedView elevation={1} style={styles.emptyState}>\n          <Feather name=\"search\" size={32} color={theme.textMuted} />\n          <ThemedText muted style={styles.emptyText}>\n            No drinks found\n          </ThemedText>\n          <ThemedText type=\"small\" muted>\n            Try a different search term\n          </ThemedText>\n        </ThemedView>\n      ) : (\n        groupedDrinks.map(([category, drinks]) => (\n          <View key={category} style={styles.categorySection}>\n            <ThemedText type=\"small\" muted style={styles.categoryLabel}>\n              {category.toUpperCase()}\n            </ThemedText>\n            <ThemedView elevation={1} style={styles.drinksCard}>\n              {drinks.map((drink, index) => (\n                <React.Fragment key={drink.id}>\n                  {index > 0 && <View style={styles.divider} />}\n                  <DrinkListItem\n                    drink={drink}\n                    isFavorite={favorites.includes(drink.id)}\n                    isAdded={addedDrinkId === drink.id}\n                    onAdd={() => handleQuickAdd(drink)}\n                    onToggleFavorite={() => toggleFavorite(drink.id)}\n                  />\n                </React.Fragment>\n              ))}\n            </ThemedView>\n          </View>\n        ))\n      )}\n    </ScreenScrollView>\n  );\n}\n\ninterface CategoryChipProps {\n  label: string;\n  icon: keyof typeof Feather.glyphMap;\n  isActive: boolean;\n  onPress: () => void;\n}\n\nfunction CategoryChip({ label, icon, isActive, onPress }: CategoryChipProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={() => {\n        scale.value = withSpring(0.95);\n      }}\n      onPressOut={() => {\n        scale.value = withSpring(1);\n      }}\n      style={[\n        styles.categoryChip,\n        {\n          backgroundColor: isActive\n            ? Colors.light.accent\n            : theme.backgroundDefault,\n        },\n        animatedStyle,\n      ]}\n    >\n      <Feather\n        name={icon}\n        size={16}\n        color={isActive ? \"#FFFFFF\" : theme.text}\n      />\n      <ThemedText\n        type=\"small\"\n        style={[\n          styles.categoryChipLabel,\n          { color: isActive ? \"#FFFFFF\" : theme.text },\n        ]}\n      >\n        {label}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\ninterface DrinkListItemProps {\n  drink: DrinkItem;\n  isFavorite: boolean;\n  isAdded: boolean;\n  onAdd: () => void;\n  onToggleFavorite: () => void;\n}\n\nfunction DrinkListItem({\n  drink,\n  isFavorite,\n  isAdded,\n  onAdd,\n  onToggleFavorite,\n}: DrinkListItemProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const caffeineMg = Math.round(\n    (drink.caffeinePer100ml * drink.defaultServingMl) / 100,\n  );\n\n  return (\n    <View style={styles.drinkItem}>\n      <Pressable onPress={onToggleFavorite} style={styles.favoriteButton}>\n        <Feather\n          name={isFavorite ? \"heart\" : \"heart\"}\n          size={18}\n          color={isFavorite ? Colors.light.danger : theme.textMuted}\n          style={{ opacity: isFavorite ? 1 : 0.4 }}\n        />\n      </Pressable>\n\n      <View style={styles.drinkInfo}>\n        <ThemedText type=\"body\" style={styles.drinkName}>\n          {drink.name}\n        </ThemedText>\n        <ThemedText type=\"caption\" muted>\n          {caffeineMg}mg per {drink.defaultServingMl}ml\n        </ThemedText>\n      </View>\n\n      <AnimatedPressable\n        onPress={onAdd}\n        onPressIn={() => {\n          scale.value = withSpring(0.9);\n        }}\n        onPressOut={() => {\n          scale.value = withSpring(1);\n        }}\n        style={[\n          styles.addButton,\n          {\n            backgroundColor: isAdded\n              ? Colors.light.success\n              : Colors.light.accent,\n          },\n          animatedStyle,\n        ]}\n      >\n        <Feather\n          name={isAdded ? \"check\" : \"plus\"}\n          size={18}\n          color=\"#FFFFFF\"\n        />\n      </AnimatedPressable>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  searchContainer: {\n    marginBottom: Spacing.md,\n  },\n  searchBox: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.sm,\n  },\n  searchInput: {\n    flex: 1,\n    fontSize: 16,\n    paddingVertical: Spacing.xs,\n  },\n  categoriesScroll: {\n    marginBottom: Spacing.lg,\n    marginHorizontal: -Spacing.xl,\n  },\n  categoriesContent: {\n    paddingHorizontal: Spacing.xl,\n    gap: Spacing.sm,\n  },\n  categoryChip: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.full,\n    gap: Spacing.xs,\n  },\n  categoryChipLabel: {\n    fontWeight: \"500\",\n  },\n  categorySection: {\n    marginBottom: Spacing.lg,\n  },\n  categoryLabel: {\n    marginBottom: Spacing.sm,\n    marginLeft: Spacing.xs,\n    fontWeight: \"600\",\n    letterSpacing: 0.5,\n  },\n  drinksCard: {\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n  },\n  divider: {\n    height: 1,\n    backgroundColor: Colors.light.divider,\n    marginLeft: 50,\n  },\n  drinkItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.md,\n    gap: Spacing.md,\n  },\n  favoriteButton: {\n    padding: Spacing.xs,\n  },\n  drinkInfo: {\n    flex: 1,\n  },\n  drinkName: {\n    fontWeight: \"500\",\n    marginBottom: 2,\n  },\n  addButton: {\n    width: 36,\n    height: 36,\n    borderRadius: 18,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  emptyState: {\n    alignItems: \"center\",\n    padding: Spacing[\"3xl\"],\n    borderRadius: BorderRadius.md,\n    gap: Spacing.sm,\n  },\n  emptyText: {\n    marginTop: Spacing.sm,\n    textAlign: \"center\",\n  },\n});\n","path":null,"size_bytes":10600,"size_tokens":null},"screens/CustomDrinkScreen.tsx":{"content":"import React, { useState } from \"react\";\nimport { View, StyleSheet, TextInput, Pressable, Alert } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n} from \"react-native-reanimated\";\nimport { ScreenKeyboardAwareScrollView } from \"@/components/ScreenKeyboardAwareScrollView\";\nimport { ScreenHeader } from \"@/components/ScreenHeader\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { useCaffeineStore, DrinkItem } from \"@/store/caffeineStore\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\nimport type { SettingsStackParamList } from \"@/navigation/SettingsStackNavigator\";\n\ntype CustomDrinkScreenProps = {\n  navigation: NativeStackNavigationProp<SettingsStackParamList, \"CustomDrink\">;\n};\n\ntype Category = \"coffee\" | \"tea\" | \"energy\" | \"soda\" | \"chocolate\" | \"custom\";\n\nconst CATEGORIES: { key: Category; label: string; icon: keyof typeof Feather.glyphMap }[] = [\n  { key: \"coffee\", label: \"Coffee\", icon: \"coffee\" },\n  { key: \"tea\", label: \"Tea\", icon: \"droplet\" },\n  { key: \"energy\", label: \"Energy\", icon: \"zap\" },\n  { key: \"soda\", label: \"Soda\", icon: \"droplet\" },\n  { key: \"chocolate\", label: \"Chocolate\", icon: \"square\" },\n  { key: \"custom\", label: \"Other\", icon: \"circle\" },\n];\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport default function CustomDrinkScreen({\n  navigation,\n}: CustomDrinkScreenProps) {\n  const { theme } = useTheme();\n  const { addCustomDrink } = useCaffeineStore();\n\n  const [name, setName] = useState(\"\");\n  const [category, setCategory] = useState<Category>(\"coffee\");\n  const [caffeinePer100ml, setCaffeinePer100ml] = useState(\"\");\n  const [defaultServingMl, setDefaultServingMl] = useState(\"\");\n\n  const caffeineMg = caffeinePer100ml && defaultServingMl\n    ? Math.round((parseInt(caffeinePer100ml) * parseInt(defaultServingMl)) / 100)\n    : 0;\n\n  const handleSave = () => {\n    if (!name.trim()) {\n      Alert.alert(\"Missing Name\", \"Please enter a name for your drink.\");\n      return;\n    }\n    if (!caffeinePer100ml || parseInt(caffeinePer100ml) <= 0) {\n      Alert.alert(\n        \"Invalid Caffeine\",\n        \"Please enter a valid caffeine amount per 100ml.\",\n      );\n      return;\n    }\n    if (!defaultServingMl || parseInt(defaultServingMl) <= 0) {\n      Alert.alert(\"Invalid Serving Size\", \"Please enter a valid serving size.\");\n      return;\n    }\n\n    const selectedCat = CATEGORIES.find((c) => c.key === category);\n\n    addCustomDrink({\n      name: name.trim(),\n      category,\n      caffeinePer100ml: parseInt(caffeinePer100ml),\n      defaultServingMl: parseInt(defaultServingMl),\n      icon: selectedCat?.icon || \"circle\",\n    });\n\n    navigation.goBack();\n  };\n\n  return (\n    <ScreenKeyboardAwareScrollView header={<ScreenHeader title=\"Add Custom Drink\" showBackButton={true} />}>\n      <View style={styles.section}>\n        <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n          DRINK NAME\n        </ThemedText>\n        <ThemedView elevation={1} style={styles.card}>\n          <TextInput\n            style={[styles.textInput, { color: theme.text }]}\n            placeholder=\"e.g., Homemade Espresso\"\n            placeholderTextColor={theme.textMuted}\n            value={name}\n            onChangeText={setName}\n          />\n        </ThemedView>\n      </View>\n\n      <View style={styles.section}>\n        <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n          CATEGORY\n        </ThemedText>\n        <View style={styles.categoriesGrid}>\n          {CATEGORIES.map((cat) => (\n            <CategoryButton\n              key={cat.key}\n              label={cat.label}\n              icon={cat.icon}\n              isActive={category === cat.key}\n              onPress={() => setCategory(cat.key)}\n            />\n          ))}\n        </View>\n      </View>\n\n      <View style={styles.section}>\n        <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n          CAFFEINE CONTENT\n        </ThemedText>\n        <ThemedView elevation={1} style={styles.card}>\n          <View style={styles.inputRow}>\n            <ThemedText type=\"body\">Caffeine per 100ml</ThemedText>\n            <View style={styles.inputWithUnit}>\n              <TextInput\n                style={[styles.numberInput, { color: theme.text }]}\n                placeholder=\"0\"\n                placeholderTextColor={theme.textMuted}\n                value={caffeinePer100ml}\n                onChangeText={setCaffeinePer100ml}\n                keyboardType=\"number-pad\"\n              />\n              <ThemedText muted>mg</ThemedText>\n            </View>\n          </View>\n          <View style={styles.divider} />\n          <View style={styles.inputRow}>\n            <ThemedText type=\"body\">Default serving size</ThemedText>\n            <View style={styles.inputWithUnit}>\n              <TextInput\n                style={[styles.numberInput, { color: theme.text }]}\n                placeholder=\"0\"\n                placeholderTextColor={theme.textMuted}\n                value={defaultServingMl}\n                onChangeText={setDefaultServingMl}\n                keyboardType=\"number-pad\"\n              />\n              <ThemedText muted>ml</ThemedText>\n            </View>\n          </View>\n        </ThemedView>\n      </View>\n\n      <View style={styles.section}>\n        <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n          PREVIEW\n        </ThemedText>\n        <ThemedView elevation={1} style={styles.previewCard}>\n          <View style={styles.previewIcon}>\n            <Feather\n              name={CATEGORIES.find((c) => c.key === category)?.icon || \"circle\"}\n              size={24}\n              color={Colors.light.accent}\n            />\n          </View>\n          <View style={styles.previewInfo}>\n            <ThemedText type=\"body\" style={styles.previewName}>\n              {name || \"Your Drink Name\"}\n            </ThemedText>\n            <ThemedText type=\"small\" muted>\n              {caffeineMg}mg per {defaultServingMl || \"0\"}ml serving\n            </ThemedText>\n          </View>\n        </ThemedView>\n      </View>\n\n      <Pressable\n        onPress={handleSave}\n        style={({ pressed }) => [\n          styles.saveButton,\n          { opacity: pressed ? 0.9 : 1 },\n        ]}\n      >\n        <ThemedText type=\"body\" style={styles.saveButtonText}>\n          Save Custom Drink\n        </ThemedText>\n      </Pressable>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\ninterface CategoryButtonProps {\n  label: string;\n  icon: keyof typeof Feather.glyphMap;\n  isActive: boolean;\n  onPress: () => void;\n}\n\nfunction CategoryButton({\n  label,\n  icon,\n  isActive,\n  onPress,\n}: CategoryButtonProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={() => {\n        scale.value = withSpring(0.95);\n      }}\n      onPressOut={() => {\n        scale.value = withSpring(1);\n      }}\n      style={[\n        styles.categoryButton,\n        {\n          backgroundColor: isActive\n            ? Colors.light.accent\n            : theme.backgroundDefault,\n        },\n        animatedStyle,\n      ]}\n    >\n      <Feather\n        name={icon}\n        size={20}\n        color={isActive ? \"#FFFFFF\" : theme.text}\n      />\n      <ThemedText\n        type=\"small\"\n        style={[\n          styles.categoryButtonLabel,\n          { color: isActive ? \"#FFFFFF\" : theme.text },\n        ]}\n      >\n        {label}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  section: {\n    marginBottom: Spacing.xl,\n  },\n  sectionLabel: {\n    marginBottom: Spacing.sm,\n    marginLeft: Spacing.xs,\n    fontWeight: \"600\",\n    letterSpacing: 0.5,\n  },\n  card: {\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n  },\n  textInput: {\n    fontSize: 16,\n    padding: Spacing.lg,\n  },\n  categoriesGrid: {\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    gap: Spacing.sm,\n  },\n  categoryButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.xs,\n    gap: Spacing.xs,\n  },\n  categoryButtonLabel: {\n    fontWeight: \"500\",\n  },\n  inputRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n  },\n  inputWithUnit: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.xs,\n  },\n  numberInput: {\n    fontSize: 16,\n    textAlign: \"right\",\n    minWidth: 60,\n    padding: Spacing.xs,\n  },\n  divider: {\n    height: 1,\n    backgroundColor: Colors.light.divider,\n    marginLeft: Spacing.lg,\n  },\n  previewCard: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    gap: Spacing.md,\n  },\n  previewIcon: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    backgroundColor: Colors.light.backgroundDefault,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  previewInfo: {\n    flex: 1,\n  },\n  previewName: {\n    fontWeight: \"600\",\n    marginBottom: 2,\n  },\n  saveButton: {\n    backgroundColor: Colors.light.accent,\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.xs,\n    alignItems: \"center\",\n    marginTop: Spacing.lg,\n  },\n  saveButtonText: {\n    color: \"#FFFFFF\",\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":9699,"size_tokens":null},"utils/infocardLogic.ts":{"content":"import { CaffeineEvent, getActiveAtTime, getMaxCaffeineInSleepWindow } from './graphUtils';\n\nexport interface InfoCardResult {\n  status: 'RECOMMENDED' | 'NO_MORE_CAFFEINE_TODAY';\n  focusDose?: number;\n  bestTimeStart?: Date;\n  bestTimeEnd?: Date;\n}\n\ninterface InfoCardInputs {\n  now: Date;\n  wakeTime: Date;\n  sleepTime: Date;\n  optimalDailyCaffeine: number;\n  totalConsumedCaffeine: number;\n  caffeineEntries: CaffeineEvent[];\n  halfLifeHours?: number;\n}\n\n// Constants\nconst MIN_DOSE = 30;\nconst MAX_DOSE = 75;\nconst MIN_GAP_BETWEEN_DOSES = 90; // minutes\nconst SIMULATION_STEP = 15; // minutes\nconst SLEEP_UNDISRUPTED_THRESHOLD = 30; // mg\nconst MAX_SAFE_MULTIPLIER = 0.6;\n\n/**\n * Helper: Convert hours to milliseconds\n */\nfunction hoursToMs(hours: number): number {\n  return hours * 60 * 60 * 1000;\n}\n\n/**\n * Helper: Get hours between two dates\n */\nfunction hoursBetween(startDate: Date, endDate: Date): number {\n  return (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60);\n}\n\n/**\n * Helper: Add minutes to a date\n */\nfunction addMinutes(date: Date, minutes: number): Date {\n  return new Date(date.getTime() + minutes * 60 * 1000);\n}\n\n/**\n * Helper: Find most recent caffeine entry within the 24-hour sleep window\n */\nfunction getLastDoseTimeInWindow(\n  caffeineEntries: CaffeineEvent[],\n  wakeTime: Date,\n  sleepTime: Date\n): Date|null {\n  // Window is 24-hour cycle from last sleep to next sleep\n  const lastSleepTime = new Date(sleepTime.getTime() - 24 * 3600000);\n  \n  const windowEntries = caffeineEntries.filter((entry) => {\n    const entryTime = Date.parse(entry.timestampISO);\n    return entryTime >= lastSleepTime.getTime() && entryTime < sleepTime.getTime();\n  });\n\n  if (windowEntries.length === 0) {\n    return null;\n  }\n\n  const sorted = [...windowEntries].sort(\n    (a, b) => Date.parse(b.timestampISO) - Date.parse(a.timestampISO)\n  );\n\n  return new Date(Date.parse(sorted[0].timestampISO));\n}\n\n/**\n * Helper: Check if adding a dose at a specific time keeps sleep undisrupted\n */\nfunction isSleepSafe(\n  caffeineEntries: CaffeineEvent[],\n  dose: number,\n  doseTimeMs: number,\n  sleepTimeMs: number,\n  halfLifeHours: number\n): boolean {\n  const maxCaffeineInWindow = getMaxCaffeineInSleepWindow(\n    caffeineEntries,\n    dose,\n    doseTimeMs,\n    sleepTimeMs,\n    halfLifeHours,\n    6 // windowHours\n  );\n\n  return maxCaffeineInWindow < SLEEP_UNDISRUPTED_THRESHOLD;\n}\n\n/**\n * Helper: Check if adding a dose at a specific time stays within safe peak\n */\nfunction isPeakSafe(\n  caffeineEntries: CaffeineEvent[],\n  dose: number,\n  doseTimeMs: number,\n  maxSafeCaffeineCap: number,\n  halfLifeHours: number\n): boolean {\n  // Simulate peak with new dose using the same logic as getPeakCaffeineWithNewEntry\n  const tempEvent: CaffeineEvent = {\n    id: 'temp',\n    name: 'temp',\n    mg: dose,\n    timestampISO: new Date(doseTimeMs).toISOString(),\n  };\n\n  const allEvents = [...caffeineEntries, tempEvent];\n  const stepMs = SIMULATION_STEP * 60 * 1000;\n  const endMs = doseTimeMs + 24 * 3600000;\n  let peak = 0;\n\n  for (let t = doseTimeMs; t <= endMs; t += stepMs) {\n    const mg = getActiveAtTime(allEvents, t, halfLifeHours);\n    if (mg > peak) peak = mg;\n  }\n\n  return peak <= maxSafeCaffeineCap;\n}\n\n/**\n * Find the best time to take a dose\n */\nfunction findBestTime(\n  caffeineEntries: CaffeineEvent[],\n  earliestCandidateTime: Date,\n  cutoffTime: Date,\n  targetDose: number,\n  maxSafeCaffeineCap: number,\n  halfLifeHours: number\n): Date | null {\n  const stepMs = SIMULATION_STEP * 60 * 1000;\n\n  for (\n    let t = earliestCandidateTime.getTime();\n    t <= cutoffTime.getTime();\n    t += stepMs\n  ) {\n    const isPeakOk = isPeakSafe(\n      caffeineEntries,\n      targetDose,\n      t,\n      maxSafeCaffeineCap,\n      halfLifeHours\n    );\n\n    const isSleepOk = isSleepSafe(\n      caffeineEntries,\n      targetDose,\n      t,\n      cutoffTime.getTime() + 6 * 3600000,\n      halfLifeHours\n    );\n\n    if (isPeakOk && isSleepOk) {\n      return new Date(t);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Main function: Calculate info card recommendations\n */\nexport function calculateInfoCard(\n  inputs: InfoCardInputs\n): InfoCardResult {\n  const {\n    now,\n    wakeTime,\n    sleepTime,\n    optimalDailyCaffeine,\n    totalConsumedCaffeine,\n    caffeineEntries,\n    halfLifeHours = 5.5,\n  } = inputs;\n\n  const maxSafeCaffeineCap = MAX_SAFE_MULTIPLIER * optimalDailyCaffeine;\n  \n  // RESET LOGIC: Check if we've passed sleep time (fresh day)\n  console.log('sleepTime',sleepTime);\n  const hasPassed = wakeTime.getTime() < sleepTime.getTime();\n  let effectiveEntries = caffeineEntries;\n  let effectiveConsumed = totalConsumedCaffeine;\n  let effectiveWakeTime = wakeTime;\n  console.log('effectiveWakeTime',effectiveWakeTime);\n  if(sleepTime.getTime()<wakeTime.getTime()){\n    effectiveWakeTime=new Date(wakeTime.getTime()-24*3600000);\n  }\n  console.log('effectiveWakeTime',effectiveWakeTime);\n  let effectiveSleepTime = sleepTime;\n  \n  // if (hasPassed) {\n  //   // Past sleep time - use current sleep window boundary\n  //   const lastSleepTime = new Date(sleepTime.getTime() - 24 * 3600000);;\n  //   const nextSleepTime = sleepTime;\n  //   console.log('lastSleepTime', lastSleepTime, 'nextSleepTime', nextSleepTime);\n  //   // Count entries within 24-hour window: last sleep to next sleep\n  //   effectiveEntries = caffeineEntries.filter((entry) => {\n  //     const entryTime = Date.parse(entry.timestampISO);\n  //     return entryTime >= lastSleepTime.getTime() && entryTime < nextSleepTime.getTime();\n  //   });\n  //   effectiveConsumed = effectiveEntries.reduce((sum, e) => sum + e.mg, 0);\n  //   effectiveSleepTime = nextSleepTime;\n  // }\n\n  const cutoffTime = new Date(\n    sleepTime.getTime() - 6 * 3600000\n  );\n\n  // Step 1: Find last relevant dose time within the sleep window\n  const lastDoseTime = getLastDoseTimeInWindow(\n    effectiveEntries,\n    effectiveWakeTime,\n    effectiveSleepTime\n  );\n\n  // Step 2: Recommendation window always starts 60 minutes after actual wake time\n  const recommendationStartTime = addMinutes(effectiveWakeTime, 60);\n  \n  // Step 3: Enforce minimum spacing (only if there are previous doses)\n  const hasPreviousDose = effectiveEntries.length > 0;\n  console.log('hasPreviousDose', hasPreviousDose, 'lastDoseTime', lastDoseTime, \"now\", now);\n  const earliestCandidateTime = new Date(\n    Math.max(\n      now.getTime(),\n      hasPreviousDose\n        ? lastDoseTime.getTime() + MIN_GAP_BETWEEN_DOSES * 60 * 1000\n        : recommendationStartTime.getTime()\n    )\n  );\n console.log('earliestCandidateTime',earliestCandidateTime);\n  // Step 3: Hard stop conditions\n  const remainingSafeMg = optimalDailyCaffeine - effectiveConsumed;\n\n  if (\n    earliestCandidateTime.getTime() > cutoffTime.getTime() ||\n    remainingSafeMg < MIN_DOSE\n  ) {\n    return { status: 'NO_MORE_CAFFEINE_TODAY' };\n  }\n\n  // Step 4: Calculate dose distribution\n  const X = lastDoseTime\n  ? lastDoseTime\n  : new Date(Math.max(now.getTime(), effectiveWakeTime.getTime()));\n  console.log('X',X);\n  const availableHours = hoursBetween(X, cutoffTime);\n  const doseSlots = Math.max(1, Math.floor(availableHours / 3));\n  console.log('doseSlots',doseSlots);\n  console.log('remainingSafeMg',remainingSafeMg);\n  const nextDose = Math.max(\n    MIN_DOSE,\n    Math.min(\n      remainingSafeMg / doseSlots,\n      MAX_DOSE\n    )\n  );\n\n  // Step 5: Find best time using peak-aware simulation\n  for (let dose = nextDose; dose >= MIN_DOSE; dose -= 5) {\n    const bestTime = findBestTime(\n      effectiveEntries,\n      earliestCandidateTime,\n      cutoffTime,\n      dose,\n      maxSafeCaffeineCap,\n      halfLifeHours\n    );\n\n    if (bestTime) {\n      return {\n        status: 'RECOMMENDED',\n        focusDose: Math.round(dose),\n        bestTimeStart: bestTime,\n        bestTimeEnd: cutoffTime,\n      };\n    }\n  }\n\n  // Step 7: Final fallback\n  return { status: 'NO_MORE_CAFFEINE_TODAY' };\n}\n","path":null,"size_bytes":7882,"size_tokens":null},"components/CaffeineDecayCurve.tsx":{"content":"import React, { useMemo } from \"react\";\nimport { View, StyleSheet, Dimensions } from \"react-native\";\nimport Svg, { Path, Line, Circle, Text as SvgText, Defs, LinearGradient, Stop } from \"react-native-svg\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing } from \"@/constants/theme\";\nimport type { DrinkEntry } from \"@/store/caffeineStore\";\n\ninterface CaffeineDecayCurveProps {\n  entries: DrinkEntry[];\n  showHalfLife: boolean;\n  sleepTime: string;\n}\n\nconst CHART_HEIGHT = 180;\nconst CAFFEINE_HALF_LIFE_HOURS = 5;\nconst HOURS_TO_SHOW = 12;\n\nexport function CaffeineDecayCurve({\n  entries,\n  showHalfLife,\n  sleepTime,\n}: CaffeineDecayCurveProps) {\n  const { theme } = useTheme();\n  const chartWidth = Dimensions.get(\"window\").width - Spacing.xl * 4;\n\n  const curveData = useMemo(() => {\n    const now = new Date();\n    const points: { hour: number; mg: number }[] = [];\n\n    for (let h = 0; h <= HOURS_TO_SHOW; h += 0.5) {\n      const checkTime = new Date(now.getTime() + h * 60 * 60 * 1000);\n      let caffeine = 0;\n\n      entries.forEach((entry) => {\n        const entryTime = new Date(entry.timestamp);\n        if (entryTime <= checkTime) {\n          const hoursElapsed =\n            (checkTime.getTime() - entryTime.getTime()) / (1000 * 60 * 60);\n          const remainingFactor = Math.pow(\n            0.5,\n            hoursElapsed / CAFFEINE_HALF_LIFE_HOURS,\n          );\n          caffeine += entry.caffeineAmount * remainingFactor;\n        }\n      });\n\n      points.push({ hour: h, mg: Math.round(caffeine) });\n    }\n\n    return points;\n  }, [entries]);\n\n  const maxMg = Math.max(...curveData.map((p) => p.mg), 100);\n  const currentMg = curveData[0]?.mg || 0;\n  const halfMg = currentMg / 2;\n\n  const getY = (mg: number) => {\n    return CHART_HEIGHT - (mg / maxMg) * (CHART_HEIGHT - 20);\n  };\n\n  const getX = (hour: number) => {\n    return (hour / HOURS_TO_SHOW) * chartWidth;\n  };\n\n  const pathData = curveData\n    .map((point, i) => {\n      const x = getX(point.hour);\n      const y = getY(point.mg);\n      return i === 0 ? `M ${x} ${y}` : `L ${x} ${y}`;\n    })\n    .join(\" \");\n\n  const areaPathData =\n    pathData +\n    ` L ${chartWidth} ${CHART_HEIGHT} L 0 ${CHART_HEIGHT} Z`;\n\n  const sleepHour = parseInt(sleepTime.split(\":\")[0]);\n  const now = new Date();\n  const currentHour = now.getHours();\n  let hoursUntilSleep = sleepHour - currentHour;\n  if (hoursUntilSleep <= 0) hoursUntilSleep += 24;\n  const sleepX = hoursUntilSleep <= HOURS_TO_SHOW ? getX(hoursUntilSleep) : null;\n\n  let halfLifeHour: number | null = null;\n  if (showHalfLife && currentMg > 0) {\n    for (const point of curveData) {\n      if (point.mg <= halfMg) {\n        halfLifeHour = point.hour;\n        break;\n      }\n    }\n  }\n\n  if (entries.length === 0) {\n    return (\n      <View style={[styles.emptyContainer, { height: CHART_HEIGHT }]}>\n        <ThemedText type=\"small\" muted>\n          Add drinks to see your caffeine curve\n        </ThemedText>\n      </View>\n    );\n  }\n\n  return (\n    <View style={styles.container}>\n      <Svg width={chartWidth} height={CHART_HEIGHT + 30}>\n        <Defs>\n          <LinearGradient id=\"gradient\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\n            <Stop offset=\"0\" stopColor={Colors.light.accent} stopOpacity=\"0.3\" />\n            <Stop offset=\"1\" stopColor={Colors.light.accent} stopOpacity=\"0\" />\n          </LinearGradient>\n        </Defs>\n\n        <Path d={areaPathData} fill=\"url(#gradient)\" />\n\n        <Path\n          d={pathData}\n          stroke={Colors.light.accent}\n          strokeWidth={3}\n          fill=\"none\"\n          strokeLinecap=\"round\"\n          strokeLinejoin=\"round\"\n        />\n\n        {sleepX && (\n          <>\n            <Line\n              x1={sleepX}\n              y1={0}\n              x2={sleepX}\n              y2={CHART_HEIGHT}\n              stroke={Colors.light.warning}\n              strokeWidth={1}\n              strokeDasharray=\"4,4\"\n            />\n            <SvgText\n              x={sleepX}\n              y={12}\n              fontSize={10}\n              fill={Colors.light.warning}\n              textAnchor=\"middle\"\n            >\n              Sleep\n            </SvgText>\n          </>\n        )}\n\n        {showHalfLife && halfLifeHour !== null && (\n          <>\n            <Line\n              x1={0}\n              y1={getY(halfMg)}\n              x2={chartWidth}\n              y2={getY(halfMg)}\n              stroke={theme.textMuted}\n              strokeWidth={1}\n              strokeDasharray=\"4,4\"\n              opacity={0.5}\n            />\n            <Circle\n              cx={getX(halfLifeHour)}\n              cy={getY(halfMg)}\n              r={5}\n              fill={Colors.light.accent}\n            />\n            <SvgText\n              x={getX(halfLifeHour) + 10}\n              y={getY(halfMg) + 4}\n              fontSize={10}\n              fill={theme.text}\n            >\n              {Math.round(halfMg)}mg\n            </SvgText>\n          </>\n        )}\n\n        <Circle cx={0} cy={getY(currentMg)} r={6} fill={Colors.light.accent} />\n\n        {[0, 3, 6, 9, 12].map((hour) => (\n          <SvgText\n            key={hour}\n            x={getX(hour)}\n            y={CHART_HEIGHT + 20}\n            fontSize={10}\n            fill={theme.textMuted}\n            textAnchor=\"middle\"\n          >\n            {hour === 0 ? \"Now\" : `+${hour}h`}\n          </SvgText>\n        ))}\n      </Svg>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    alignItems: \"center\",\n  },\n  emptyContainer: {\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n});\n","path":null,"size_bytes":5605,"size_tokens":null},"components/Card.tsx":{"content":"import React, { ReactNode } from \"react\";\nimport { StyleSheet, Pressable, ViewStyle, StyleProp } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface CardProps {\n  children?: ReactNode;\n  elevation?: 1 | 2 | 3;\n  onPress?: () => void;\n  style?: StyleProp<ViewStyle>;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst getBackgroundColorForElevation = (\n  elevation: number,\n  theme: any,\n): string => {\n  switch (elevation) {\n    case 1:\n      return theme.backgroundDefault;\n    case 2:\n      return theme.backgroundSecondary;\n    case 3:\n      return theme.backgroundTertiary;\n    default:\n      return theme.backgroundRoot;\n  }\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Card({ children, elevation = 1, onPress, style }: CardProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const cardBackgroundColor = getBackgroundColorForElevation(elevation, theme);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    if (onPress) {\n      scale.value = withSpring(0.98, springConfig);\n    }\n  };\n\n  const handlePressOut = () => {\n    if (onPress) {\n      scale.value = withSpring(1, springConfig);\n    }\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      disabled={!onPress}\n      style={[\n        styles.card,\n        {\n          backgroundColor: cardBackgroundColor,\n        },\n        style,\n        animatedStyle,\n      ]}\n    >\n      {children}\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  card: {\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.md,\n  },\n});\n","path":null,"size_bytes":2045,"size_tokens":null},"replit.md":{"content":"# Caffi - Offline Caffeine Tracker\n\n## Overview\nCaffi is a privacy-first, offline caffeine tracking mobile app built with Expo React Native. It helps users monitor their daily caffeine intake, understand caffeine metabolism, and optimize sleep quality.\n\n## Current State\n- **Status**: MVP Complete - Functional prototype with all core features\n- **Last Updated**: December 17, 2025\n- **Platform**: Expo React Native (iOS, Android, Web)\n\n## Project Architecture\n\n### Directory Structure\n```\n/\n App.tsx              # App entry with navigation & error boundary\n app.json             # Expo configuration\n navigation/          # React Navigation setup\n    MainTabNavigator.tsx     # Bottom tabs with FAB\n    HomeStackNavigator.tsx   # Home tab screens\n    HistoryStackNavigator.tsx # History tab screens\n    SettingsStackNavigator.tsx # Settings tab screens\n    StatsStackNavigator.tsx  # Stats tab screens\n screens/             # Screen components\n    HomeScreen.tsx           # Dashboard with caffeine ring\n    HistoryScreen.tsx        # Timeline and stats\n    SettingsScreen.tsx       # Profile & preferences\n    StatisticsScreen.tsx     # Analytics overview\n    CaffeineIntakeDetailScreen.tsx # Caffeine intake bar chart\n    DrinkDatabaseScreen.tsx  # Drink browser\n    CustomDrinkScreen.tsx    # Add custom drinks\n    AddDrinkModal.tsx        # Quick add drink modal\n components/          # Reusable UI components\n    CaffeineRing.tsx        # Circular progress visualization\n    CaffeineChart.tsx       # Bar chart for history\n    CaffeineDecayCurve.tsx  # Half-life decay curve\n    QuickStatCard.tsx       # Dashboard stat cards\n    DrinkTimelineItem.tsx   # Drink entry with delete icon\n    EditDrinkModal.tsx      # Edit drink modal\n    Button.tsx              # Primary/secondary/tertiary buttons\n    Card.tsx                # Elevation-based cards\n    ThemedText.tsx          # Typography component\n    ThemedView.tsx          # Themed container\n    ErrorBoundary.tsx       # App crash recovery\n    ErrorFallback.tsx       # Error UI\n store/               # State management\n    caffeineStore.ts        # AsyncStorage-backed caffeine data store\n constants/           # Design tokens\n    theme.ts                # Colors, spacing, typography\n hooks/               # Custom hooks\n     useTheme.ts             # Theme access\n     useScreenInsets.ts      # Safe area calculations\n     useColorScheme.ts       # System color scheme\n```\n\n## Key Features\n\n### Core Functionality\n1. **Dashboard** - Circular caffeine ring showing daily intake vs limit\n2. **Quick Stats** - Active caffeine, last drink, sleep impact badges\n3. **Add Drink** - Modal with searchable drink database, size selection\n4. **History** - Day/week view with timeline and bar charts\n5. **Statistics** - Caffeine decay curve with half-life visualization\n6. **Drink Database** - 20+ pre-loaded drinks with categories\n7. **Custom Drinks** - Create personal caffeine entries\n8. **Settings** - Profile, daily limit, sleep/wake times\n\n### Design System\n- **Theme**: Coffee-inspired warm tones\n  - Background: #FFFFFF (white)\n  - Light Coffee: #F5EBDD (cards)\n  - Coffee Accent: #C69C6D (brand)\n  - Dark Coffee: #6B4C3B (text)\n  - Status colors: Success #2F9E44, Warning #F2A43A, Danger #E85D4E\n- **Typography**: System fonts, sizes 12-32px\n- **Spacing**: 8pt grid system\n- **Radius**: 8-16px for cards and buttons\n\n### Caffeine Logic\n- Half-life model: 5 hours\n- Decay calculation: `remaining = initial * 0.5^(hours/5)`\n- Sleep impact: Based on predicted caffeine at sleep time\n- Daily limit: Default 400mg (customizable)\n\n## User Preferences\n- Age selection: Simple 3-option choice instead of precise age slider\n- Weight input: Numeric keyboard input instead of slider\n- Caffeine sensitivity: \"Normal\" preferred over \"Medium\" label\n- Alcohol intake: \"Never\" preferred over \"Rare\" label\n\n## Recent Changes\n- December 18, 2025: Graph marker click functionality\n  - Single marker click opens CaffeineLogPopup to view/edit/delete entry\n  - Stacked markers (multiple drinks at similar times) show StackedEntriesModal\n  - StackedEntriesModal displays list with image, name, time, and mg for each entry\n  - Clicking an entry in the stacked modal opens its CaffeineLogPopup\n  - Added StackedEntriesModal component in components/StackedEntriesModal.tsx\n  - Updated CaffeineGraphNew.tsx with Pressable overlays for marker clicks\n  - Updated HomeGraphController.tsx to pass click handlers through\n\n- December 17, 2025: Sleep impact indicator fix for past entries\n  - Fixed CustomDrinkModal sleep impact indicator to only show changes for current/future entries\n  - Past date entries (before today's midnight) now always show \"safe\" status\n  - Prevents retroactive color changes when logging historical caffeine intake\n\n- December 17, 2025: Sleep window status message in graph\n  - Updated graph subtitle text to show sleep disruption status based on max caffeine in sleep window\n  - Calculates max caffeine from user's sleep time to +6 hours\n  - Text thresholds: <30mg = \"sleep undisrupted.\", 30-40mg = \"May disrupt sleep for some people.\", >40mg = \"More likely to disrupt sleep.\"\n  - Edge case: After passing user's bedtime, automatically calculates for next day's sleep time\n  - Added getMaxCaffeineInSleepWindowForDisplay() and getSleepWindowStatusMessage() in graphUtils.ts\n\n- December 17, 2025: Graph legend and optimal caffeine line\n  - Added horizontal dashed line showing user's optimal caffeine level (gold/accent color)\n  - Removed \"Sleep unaffected\" text from graph\n  - Added info icon (i) at top left of graph that opens legend modal\n  - Legend explains: green line = sleep threshold, gold dashed line = optimal daily caffeine\n  - Passes optimalCaffeineMg through HomeScreen -> HomeGraphController -> CaffeineGraphNew\n\n- December 17, 2025: Infinite scrolling for home screen caffeine graph\n  - Added CaffeineGraphNew component with virtualized day-window rendering\n  - Shows 5 days at a time (prev 3 days, current day, next day) for performance\n  - Edge detection extends window by 5 days when user scrolls to boundaries\n  - Scroll position preserved when day window extends (no jumping)\n  - Arrow buttons appear when scrolled away from current time, clicking returns to now\n  - Date labels shown below x-axis only at midnight (day boundaries)\n  - HomeGraphController manages day window state and reset functionality\n\n- December 16, 2025: Improved sleep impact indicator logic and explanatory text cards\n  - Sleep impact now checks maximum caffeine level during 6-hour sleep window (not just at exact sleep time)\n  - Added getMaxCaffeineInSleepWindow() function in graphUtils.ts\n  - Added explanatory text cards below Caffeine Limit and Sleep Impact indicators\n  - Text dynamically shows meaning based on indicator color (green/orange/red)\n  - Caffeine Limit: \"Supports alertness and focus\" / \"May cause mild restlessness\" / \"Side effects more likely\"\n  - Sleep Impact: \"Unlikely to disrupt sleep\" / \"May disrupt sleep for some\" / \"More likely to disrupt sleep\"\n\n- December 11, 2025: Caffeine Intake Analytics Detail Screen\n  - Added CaffeineIntakeDetailScreen with interactive bar chart\n  - Week/Month/Year period selector for viewing consumption patterns\n  - Date range navigator with arrows to browse previous/next periods\n  - Bar graph shows daily intake (week), weekly totals (month), or monthly totals (year)\n  - Average calculation displayed below chart\n  - Created StatsStackNavigator for navigation from StatisticsScreen\n  - Clickable \"Daily caffeine intake\" card in Analytics navigates to detail view\n\n- December 5, 2025: Real-time updates and edit functionality\n  - Fixed HomeScreen not updating in real-time when drinks are added/deleted\n  - Added visible delete icon on each drink entry (red trash icon)\n  - Simplified DrinkTimelineItem component for better touch handling\n  - Added EditDrinkModal for editing existing drink logs\n  - Added updateEntry function to caffeineStore for modifying entries\n  - Tapping a drink entry now opens edit modal to modify serving size, caffeine amount, or notes\n  - All changes (add, edit, delete) now reflect instantly on both Home and History screens\n\n- December 4, 2025: Data persistence and schedule step\n  - Added AsyncStorage persistence for all app data\n  - Added non-skippable schedule step (wake/sleep times) to onboarding\n  - Home screen caffeine ring now shows personalized optimal limit\n\n- December 4, 2025: Custom onboarding flow\n  - Replaced age slider with 3 options: Under 18, 18-60, Over 60\n  - Changed weight input from slider to numeric text keyboard\n  - Changed \"Medium\" sensitivity to \"Normal\"\n  - Changed \"Rare\" alcohol to \"Never\"\n  - Removed gender and sleep goal steps entirely\n  - Updated medications with 6 specific conditions + None option:\n    - Anxiety/Panic (0.6x reduction)\n    - Depression treatment (0.7x reduction)\n    - ADHD medication (0.6x reduction)\n    - High blood pressure (0.7x reduction)\n    - Insomnia medication (0.6x reduction)\n    - Acid reflux (0.75x reduction)\n  - Age-based caffeine limits:\n    - Under 18: optimal=80mg, safe=100mg fixed\n    - 18-60: full calculated amount\n    - Over 60: optimal multiplied by 0.8x\n\n- December 4, 2025: Initial MVP build\n  - Created complete UI with 7 screens\n  - Implemented caffeine ring with animated progress\n  - Built drink database with 20+ items\n  - Added swipe-to-delete for drink entries\n  - Created decay curve visualization\n  - Implemented FAB for quick drink adding\n\n## Technical Notes\n- **State Management**: Custom hook-based store with global state and listeners\n- **Data Persistence**: AsyncStorage for profile, entries, custom drinks, favorites\n- **Navigation**: React Navigation 7 with bottom tabs\n- **Animations**: React Native Reanimated for smooth interactions\n- **Charts**: Custom SVG-based visualizations with react-native-svg\n\n## Next Steps (Future)\n1. Add dark mode support\n2. Create local backup/export feature\n3. Add notification system for limit warnings\n","path":null,"size_bytes":10405,"size_tokens":null},"components/StickyConsumptionTitle.tsx":{"content":"import React from \"react\";\nimport { StyleSheet, Text, View } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  interpolate,\n  Extrapolation,\n} from \"react-native-reanimated\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing } from \"@/constants/theme\";\n\ninterface StickyConsumptionTitleProps {\n  scrollY: Animated.SharedValue<number>;\n  collapseThreshold: number;\n  stickyOffset: number;\n  onHeight?: (height: number) => void;\n}\n\nexport function StickyConsumptionTitle({\n  scrollY,\n  collapseThreshold,\n  stickyOffset,\n  onHeight,\n}: StickyConsumptionTitleProps) {\n  const { theme } = useTheme();\n\n  const stickyStyle = useAnimatedStyle(() => {\n    const progress = Math.min(scrollY.value / collapseThreshold, 1);\n    const isSticky = scrollY.value >= collapseThreshold;\n    \n    return {\n      opacity: isSticky\n        ? interpolate(progress, [0.8, 1], [0, 1], Extrapolation.CLAMP)\n        : 0,\n      pointerEvents: isSticky ? \"auto\" : \"none\",\n    } as any;\n  });\n\n  return (\n    <Animated.View\n      style={[\n        styles.container,\n        { top: stickyOffset, backgroundColor: theme.bg },\n        stickyStyle,\n      ]}\n      onLayout={(event) => onHeight?.(event.nativeEvent.layout.height)}\n    >\n      <Text style={[styles.title, { color: theme.darkBrown }]}>\n        My consumption\n      </Text>\n    </Animated.View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    position: \"absolute\",\n    left: 0,\n    right: 0,\n    zIndex: 10,\n    paddingTop: Spacing.xs,\n    paddingBottom: 0,\n    paddingHorizontal: Spacing.lg,\n  },\n  title: {\n    fontSize: 22,\n    fontWeight: \"700\",\n  },\n});\n","path":null,"size_bytes":1628,"size_tokens":null},"components/ErrorBoundary.tsx":{"content":"import React, { Component, ComponentType, PropsWithChildren } from \"react\";\nimport { ErrorFallback, ErrorFallbackProps } from \"@/components/ErrorFallback\";\n\nexport type ErrorBoundaryProps = PropsWithChildren<{\n  FallbackComponent?: ComponentType<ErrorFallbackProps>;\n  onError?: (error: Error, stackTrace: string) => void;\n}>;\n\ntype ErrorBoundaryState = { error: Error | null };\n\n/**\n * This is a special case for for using the class components. Error boundaries must be class components because React only provides error boundary functionality through lifecycle methods (componentDidCatch and getDerivedStateFromError) which are not available in functional components.\n * https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary\n */\n\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  state: ErrorBoundaryState = { error: null };\n\n  static defaultProps: {\n    FallbackComponent: ComponentType<ErrorFallbackProps>;\n  } = {\n    FallbackComponent: ErrorFallback,\n  };\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { error };\n  }\n\n  componentDidCatch(error: Error, info: { componentStack: string }): void {\n    if (typeof this.props.onError === \"function\") {\n      this.props.onError(error, info.componentStack);\n    }\n  }\n\n  resetError = (): void => {\n    this.setState({ error: null });\n  };\n\n  render() {\n    const { FallbackComponent } = this.props;\n\n    return this.state.error && FallbackComponent ? (\n      <FallbackComponent\n        error={this.state.error}\n        resetError={this.resetError}\n      />\n    ) : (\n      this.props.children\n    );\n  }\n}\n","path":null,"size_bytes":1674,"size_tokens":null},"components/HomeGraphController.tsx":{"content":"import React, { useState, useRef, useCallback, useMemo } from \"react\";\nimport { View, StyleSheet, Pressable, ScrollView } from \"react-native\";\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n  withSequence,\n  withTiming,\n} from \"react-native-reanimated\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { CaffeineGraphNew } from \"./CaffeineGraphNew\";\nimport { CaffeineEvent } from \"@/utils/graphUtils\";\n\ninterface HomeGraphControllerProps {\n  events: CaffeineEvent[];\n  bedtime: string;\n  halfLifeHours?: number;\n  sleepThresholdMg?: number;\n  optimalCaffeineMg?: number;\n  isDark?: boolean;\n  onHeight?: (height: number) => void;\n  onEventClick?: (event: CaffeineEvent) => void;\n  onStackedEventsClick?: (events: CaffeineEvent[], position: { x: number; y: number }) => void;\n}\n\nconst LIGHT_COLORS = {\n  bg: \"#FFFFFF\",\n  darkBrown: \"#5C4A3B\",\n};\n\nconst DARK_COLORS = {\n  bg: \"#2A2420\",\n  darkBrown: \"#F5EBDD\",\n};\n\nconst INITIAL_START_DAY = -3;\nconst INITIAL_END_DAY = 1;\nconst DAYS_TO_EXTEND = 5;\n\nexport function HomeGraphController({\n  events,\n  bedtime,\n  halfLifeHours = 5.5,\n  sleepThresholdMg = 100,\n  optimalCaffeineMg = 200,\n  isDark = false,\n  onHeight,\n  onEventClick,\n  onStackedEventsClick,\n}: HomeGraphControllerProps) {\n  const [isOffCenter, setIsOffCenter] = useState(false);\n  const [scrollDirection, setScrollDirection] = useState<'left' | 'right' | null>(null);\n  const [dayWindowStart, setDayWindowStart] = useState(INITIAL_START_DAY);\n  const [dayWindowEnd, setDayWindowEnd] = useState(INITIAL_END_DAY);\n  const [resetKey, setResetKey] = useState(0);\n  const scrollViewRef = useRef<ScrollView>(null);\n  const buttonScale = useSharedValue(1);\n\n  const colors = isDark ? DARK_COLORS : LIGHT_COLORS;\n\n  const now = useMemo(() => new Date().toISOString(), []);\n\n  const handleScrollOffsetChange = useCallback((offCenter: boolean, direction: 'left' | 'right' | null) => {\n    setIsOffCenter(offCenter);\n    setScrollDirection(direction);\n  }, []);\n\n  const handleExtendDays = useCallback((direction: 'left' | 'right') => {\n    if (direction === 'left') {\n      setDayWindowStart(prev => prev - DAYS_TO_EXTEND);\n    } else {\n      setDayWindowEnd(prev => prev + DAYS_TO_EXTEND);\n    }\n  }, []);\n\n  const handleJumpToNow = useCallback(() => {\n    buttonScale.value = withSequence(\n      withTiming(0.9, { duration: 100 }),\n      withSpring(1, { damping: 10, stiffness: 400 })\n    );\n\n    setDayWindowStart(INITIAL_START_DAY);\n    setDayWindowEnd(INITIAL_END_DAY);\n    setIsOffCenter(false);\n    setScrollDirection(null);\n    setResetKey(prev => prev + 1);\n  }, [buttonScale]);\n\n  const jumpButtonStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: buttonScale.value }],\n  }));\n\n  return (\n    <View\n      style={styles.container}\n      onLayout={(e) => onHeight?.(e.nativeEvent.layout.height)}\n    >\n      <CaffeineGraphNew\n        events={events}\n        now={now}\n        bedtime={bedtime}\n        halfLifeHours={halfLifeHours}\n        sleepThresholdMg={sleepThresholdMg}\n        optimalCaffeineMg={optimalCaffeineMg}\n        onScrollOffsetChange={handleScrollOffsetChange}\n        scrollViewRef={scrollViewRef}\n        isDark={isDark}\n        dayWindowStart={dayWindowStart}\n        dayWindowEnd={dayWindowEnd}\n        onExtendDays={handleExtendDays}\n        resetKey={resetKey}\n        onEventClick={onEventClick}\n        onStackedEventsClick={onStackedEventsClick}\n      />\n\n      {isOffCenter && scrollDirection === 'right' && (\n        <Animated.View style={[styles.arrowButtonRight, jumpButtonStyle]}>\n          <Pressable \n            style={[\n              styles.arrowButton, \n              { \n                backgroundColor: colors.bg,\n                shadowColor: \"#000\",\n              }\n            ]} \n            onPress={handleJumpToNow}\n          >\n            <Feather name=\"chevron-right\" size={18} color={colors.darkBrown} />\n          </Pressable>\n        </Animated.View>\n      )}\n\n      {isOffCenter && scrollDirection === 'left' && (\n        <Animated.View style={[styles.arrowButtonLeft, jumpButtonStyle]}>\n          <Pressable \n            style={[\n              styles.arrowButton, \n              { \n                backgroundColor: colors.bg,\n                shadowColor: \"#000\",\n              }\n            ]} \n            onPress={handleJumpToNow}\n          >\n            <Feather name=\"chevron-left\" size={18} color={colors.darkBrown} />\n          </Pressable>\n        </Animated.View>\n      )}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    position: \"relative\",\n  },\n  arrowButtonRight: {\n    position: \"absolute\",\n    right: 8,\n    top: \"50%\",\n    marginTop: -16,\n    zIndex: 100,\n  },\n  arrowButtonLeft: {\n    position: \"absolute\",\n    left: 8,\n    top: \"50%\",\n    marginTop: -16,\n    zIndex: 100,\n  },\n  arrowButton: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    width: 32,\n    height: 32,\n    borderRadius: 16,\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.15,\n    shadowRadius: 4,\n    elevation: 4,\n  },\n});\n\nexport default HomeGraphController;\n","path":null,"size_bytes":5094,"size_tokens":null},"screens/AddDrinkModal.tsx":{"content":"import React, { useState, useMemo, useEffect, useCallback, useLayoutEffect, useRef, memo } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Modal,\n  TextInput,\n  Pressable,\n  ScrollView,\n  useWindowDimensions,\n  NativeScrollEvent,\n  NativeSyntheticEvent,\n  LayoutChangeEvent,\n  ActivityIndicator,\n  Image,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  withTiming,\n  runOnJS,\n  interpolate,\n  Extrapolation,\n  useAnimatedScrollHandler,\n} from \"react-native-reanimated\";\nimport { Gesture, GestureDetector, GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { CustomDrinkModal } from \"@/components/CustomDrinkModal\";\nimport { useCaffeineStore, DrinkItem, DrinkEntry } from \"@/store/caffeineStore\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\nconst SEARCH_BAR_HEIGHT = 60;\n\nconst getCategoryImageSource = (category: string) => {\n  const imageMap: Record<string, any> = {\n    coffee: require(\"@/assets/CaffeineSourceImages/coffee.png\"),\n    tea: require(\"@/assets/CaffeineSourceImages/tea.jpg\"),\n    energy: require(\"@/assets/CaffeineSourceImages/energy.png\"),\n    soda: require(\"@/assets/CaffeineSourceImages/soda.png\"),\n    chocolate: require(\"@/assets/CaffeineSourceImages/chocolate.png\"),\n  };\n  return imageMap[category] || imageMap.coffee;\n};\n\nconst getImageSourceForDrinkModal = (item: DrinkItem | DrinkEntry): { uri?: string; source?: any } => {\n  const imgUri = (item as any).imageUri;\n  if (imgUri) {\n    if (imgUri.startsWith(\"preset:\")) {\n      const { PRESET_IMAGES } = require(\"@/components/ImagePickerModal\");\n      const preset = PRESET_IMAGES.find((p: any) => p.id === imgUri.replace(\"preset:\", \"\"));\n      return preset ? { source: preset.image } : { source: getCategoryImageSource((item as any).category) };\n    }\n    return { uri: imgUri };\n  }\n  return { source: getCategoryImageSource((item as any).category) };\n};\n\ninterface AddDrinkModalProps {\n  visible: boolean;\n  onClose: () => void;\n  onNavigateToCustomDrink?: () => void;\n}\n\ntype Category = \"coffee\" | \"tea\" | \"energy\" | \"soda\" | \"chocolate\" | \"custom\";\n\nconst QUICK_CATEGORIES: { key: Category; label: string; icon: keyof typeof Feather.glyphMap }[] = [\n  { key: \"coffee\", label: \"Coffee\", icon: \"coffee\" },\n  { key: \"tea\", label: \"Tea\", icon: \"droplet\" },\n  { key: \"energy\", label: \"Energy\", icon: \"zap\" },\n  { key: \"soda\", label: \"Soda\", icon: \"droplet\" },\n  { key: \"chocolate\", label: \"Chocolate\", icon: \"square\" },\n];\n\nexport default function AddDrinkModal({ visible, onClose, onNavigateToCustomDrink }: AddDrinkModalProps) {\n  const { theme, isDark } = useTheme();\n  const insets = useSafeAreaInsets();\n  const { height: windowHeight } = useWindowDimensions();\n  const { addEntry, deleteEntry, getAllDrinks, getFavoriteDrinks, profile, entries, customDrinks } = useCaffeineStore();\n\n  const INITIAL_HEIGHT = windowHeight * 0.8;\n  const maxExpandedHeight = windowHeight;\n  \n  const [showCustomDrinkModal, setShowCustomDrinkModal] = useState(false);\n  const [prefillDrink, setPrefillDrink] = useState<DrinkItem | null>(null);\n  const [editingCustomDrink, setEditingCustomDrink] = useState<DrinkItem | null>(null);\n\n  const handleAddCustomDrink = () => {\n    setPrefillDrink(null);\n    setShowCustomDrinkModal(true);\n  };\n\n  const handleCustomDrinkAdded = () => {\n    setShowCustomDrinkModal(false);\n    setPrefillDrink(null);\n    setEditingCustomDrink(null);\n    handleCloseAnimated();\n  };\n\n  const handleEditCustomDrink = (drink: DrinkItem) => {\n    setEditingCustomDrink(drink);\n    setPrefillDrink(null);\n    setShowCustomDrinkModal(true);\n  };\n\n  const handleSaveCustomDrink = () => {\n    setEditingCustomDrink(null);\n  };\n\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [selectedCategory, setSelectedCategory] = useState<Category | null>(\"coffee\");\n  const [selectedDrink, setSelectedDrink] = useState<DrinkItem | null>(null);\n  const [selectedSize, setSelectedSize] = useState<number | null>(null);\n  const [notes, setNotes] = useState(\"\");\n  const [isFavorite, setIsFavorite] = useState(false);\n\n  const scrollY = useSharedValue(0);\n  const quickAddY = useSharedValue(0);\n  const customDrinksY = useSharedValue(0);\n  const categoryHeaderY = useSharedValue(0);\n  const activeSectionY = useSharedValue(0);\n  const [currentStickyLabel, setCurrentStickyLabel] = useState<string>(\"\");\n\n  const allDrinks = getAllDrinks();\n  const favoriteDrinks = getFavoriteDrinks();\n\n  const recentEntries = useMemo(() => {\n    const sorted = [...entries].sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n    const seen = new Set<string>();\n    return sorted.filter(entry => {\n      if (seen.has(entry.name)) return false;\n      seen.add(entry.name);\n      return true;\n    }).slice(0, 5);\n  }, [entries]);\n\n  const filteredDrinks = useMemo(() => {\n    let drinks = allDrinks;\n\n    if (selectedCategory) {\n      drinks = drinks.filter((d) => d.category === selectedCategory);\n    }\n\n    if (searchQuery.trim()) {\n      const query = searchQuery.toLowerCase();\n      drinks = drinks.filter(\n        (d) =>\n          d.name.toLowerCase().includes(query) ||\n          d.category.toLowerCase().includes(query),\n      );\n    }\n\n    return drinks;\n  }, [allDrinks, selectedCategory, searchQuery]);\n\n  // Pagination for infinite scroll\n  const PAGE_SIZE = 25;\n  const [displayedCount, setDisplayedCount] = useState(PAGE_SIZE);\n  const isLoadingMore = useRef(false);\n\n  // Reset pagination when filters change or modal reopens\n  useEffect(() => {\n    setDisplayedCount(PAGE_SIZE);\n  }, [selectedCategory, searchQuery, visible]);\n\n  const displayedDrinks = useMemo(() => {\n    return filteredDrinks.slice(0, displayedCount);\n  }, [filteredDrinks, displayedCount]);\n\n  const hasMoreDrinks = displayedCount < filteredDrinks.length;\n\n  const loadMoreDrinks = useCallback(() => {\n    if (isLoadingMore.current || !hasMoreDrinks) return;\n    isLoadingMore.current = true;\n    setTimeout(() => {\n      setDisplayedCount(prev => Math.min(prev + PAGE_SIZE, filteredDrinks.length));\n      isLoadingMore.current = false;\n    }, 100);\n  }, [hasMoreDrinks, filteredDrinks.length]);\n\n  const caffeineMg = selectedDrink && selectedSize\n    ? Math.round((selectedDrink.caffeinePer100ml * selectedSize) / 100)\n    : 0;\n\n  const warningLevel = useMemo(() => {\n    if (!caffeineMg) return null;\n    const todayTotal = 0;\n    const projectedTotal = todayTotal + caffeineMg;\n    const percentage = (projectedTotal / profile.dailyLimit) * 100;\n\n    if (percentage > 100) return \"danger\";\n    if (percentage > 80) return \"warning\";\n    return null;\n  }, [caffeineMg, profile.dailyLimit]);\n\n  const handleSelectDrink = (drink: DrinkItem) => {\n    setPrefillDrink(drink);\n    setShowCustomDrinkModal(true);\n  };\n\n  const handleQuickAdd = (entry: DrinkEntry) => {\n    const drink = allDrinks.find(d => d.id === entry.drinkId) || {\n      id: entry.drinkId,\n      name: entry.name,\n      category: entry.category as Category,\n      caffeinePer100ml: (entry.caffeineAmount / entry.servingSize) * 100,\n      defaultServingMl: entry.servingSize,\n      icon: \"coffee\",\n      sizes: [],\n    };\n    addEntry(drink, entry.servingSize, entry.notes, entry.isFavorite, new Date());\n    handleCloseAnimated();\n  };\n\n  const handleAdd = () => {\n    if (selectedDrink && selectedSize) {\n      addEntry(selectedDrink, selectedSize, notes || undefined, isFavorite);\n      handleCloseAnimated();\n    }\n  };\n\n  const resetState = () => {\n    setSearchQuery(\"\");\n    setSelectedCategory(\"coffee\");\n    setSelectedDrink(null);\n    setSelectedSize(null);\n    setNotes(\"\");\n    setIsFavorite(false);\n    scrollY.value = 0;\n    quickAddY.value = 0;\n    customDrinksY.value = 0;\n    categoryHeaderY.value = 0;\n    activeSectionY.value = 0;\n    setCurrentStickyLabel(\"\");\n  };\n\n  const handleScroll = useAnimatedScrollHandler({\n    onScroll: (e) => {\n      scrollY.value = e.contentOffset.y;\n      const currentY = e.contentOffset.y;\n      \n      let activeLabel = \"\";\n      let activeY = 0;\n      if (categoryHeaderY.value > 0 && currentY >= categoryHeaderY.value) {\n        activeLabel = searchQuery ? \"RESULTS\" : selectedCategory!.toUpperCase();\n        activeY = categoryHeaderY.value;\n      } else if (customDrinksY.value > 0 && currentY >= customDrinksY.value) {\n        activeLabel = \"MY CUSTOM DRINKS\";\n        activeY = customDrinksY.value;\n      } else if (quickAddY.value > 0 && currentY >= quickAddY.value) {\n        activeLabel = \"QUICK ADD\";\n        activeY = quickAddY.value;\n      }\n      activeSectionY.value = activeY;\n      runOnJS(setCurrentStickyLabel)(activeLabel);\n    },\n  });\n\n  const handleInfiniteScroll = (event: NativeSyntheticEvent<NativeScrollEvent>) => {\n    const { contentOffset, layoutMeasurement, contentSize } = event.nativeEvent;\n    const distanceFromBottom = contentSize.height - layoutMeasurement.height - contentOffset.y;\n    if (distanceFromBottom < 200 && hasMoreDrinks) {\n      loadMoreDrinks();\n    }\n  };\n\n  const translateY = useSharedValue(INITIAL_HEIGHT);\n  const sheetHeight = useSharedValue(INITIAL_HEIGHT);\n  const startY = useSharedValue(0);\n  const startHeight = useSharedValue(INITIAL_HEIGHT);\n  const borderRadius = useSharedValue(BorderRadius.lg);\n  const [isClosing, setIsClosing] = useState(false);\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  const handleCloseAnimated = useCallback(\n    (after?: () => void) => {\n      if (isClosing) return;\n      setIsClosing(true);\n      translateY.value = withTiming(INITIAL_HEIGHT, { duration: 180 }, () => {\n        runOnJS(resetState)();\n        runOnJS(onClose)();\n        runOnJS(setIsClosing)(false);\n        runOnJS(setIsExpanded)(false);\n        if (after) runOnJS(after)();\n      });\n      sheetHeight.value = withTiming(INITIAL_HEIGHT, { duration: 180 });\n      borderRadius.value = withTiming(BorderRadius.lg, { duration: 180 });\n    },\n    [isClosing, onClose, translateY, sheetHeight, borderRadius],\n  );\n\n  const collapseToNormal = useCallback(() => {\n    sheetHeight.value = withSpring(INITIAL_HEIGHT, { damping: 18, stiffness: 200 });\n    translateY.value = withSpring(0, { damping: 18, stiffness: 200 });\n    borderRadius.value = withSpring(BorderRadius.lg, { damping: 18, stiffness: 200 });\n    setIsExpanded(false);\n  }, [sheetHeight, translateY, borderRadius]);\n\n  useLayoutEffect(() => {\n    if (visible) {\n      setIsExpanded(false);\n      translateY.value = withSpring(0);\n    } else {\n      translateY.value = INITIAL_HEIGHT;\n      sheetHeight.value = INITIAL_HEIGHT;\n    }\n  }, [visible, translateY, sheetHeight]);\n\n  const panGesture = Gesture.Pan()\n    .onStart(() => {\n      startY.value = translateY.value;\n      startHeight.value = sheetHeight.value;\n    })\n    .onUpdate((event) => {\n      const { translationY } = event;\n      \n      if (translationY > 0) {\n        const nextY = Math.min(startY.value + translationY, INITIAL_HEIGHT);\n        translateY.value = nextY;\n      } else {\n        const heightIncrease = Math.abs(translationY);\n        const newHeight = Math.min(startHeight.value + heightIncrease, maxExpandedHeight);\n        sheetHeight.value = newHeight;\n        \n        const progress = (newHeight - INITIAL_HEIGHT) / (maxExpandedHeight - INITIAL_HEIGHT);\n        borderRadius.value = interpolate(progress, [0, 1], [BorderRadius.lg, 0], Extrapolation.CLAMP);\n      }\n    })\n    .onEnd((event) => {\n      const { translationY, velocityY } = event;\n      \n      if (translationY > 0) {\n        const shouldClose = translateY.value > INITIAL_HEIGHT * 0.4 || velocityY > 800;\n        if (shouldClose) {\n          translateY.value = withTiming(INITIAL_HEIGHT, { duration: 180 }, () => {\n            runOnJS(resetState)();\n            runOnJS(onClose)();\n            runOnJS(setIsClosing)(false);\n            runOnJS(setIsExpanded)(false);\n          });\n          sheetHeight.value = withTiming(INITIAL_HEIGHT, { duration: 180 });\n        } else {\n          translateY.value = withSpring(0, { damping: 16, stiffness: 200 });\n        }\n      } else {\n        const shouldExpand = sheetHeight.value > INITIAL_HEIGHT + 60 || velocityY < -600;\n        if (shouldExpand) {\n          sheetHeight.value = withSpring(maxExpandedHeight, { damping: 18, stiffness: 200 });\n          borderRadius.value = withSpring(0, { damping: 18, stiffness: 200 });\n          runOnJS(setIsExpanded)(true);\n        } else {\n          sheetHeight.value = withSpring(INITIAL_HEIGHT, { damping: 18, stiffness: 200 });\n          borderRadius.value = withSpring(BorderRadius.lg, { damping: 18, stiffness: 200 });\n          runOnJS(setIsExpanded)(false);\n        }\n      }\n    });\n\n  const sheetStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: translateY.value }],\n    height: sheetHeight.value,\n    borderTopLeftRadius: borderRadius.value,\n    borderTopRightRadius: borderRadius.value,\n  }));\n\n  const animatedStickyStyle = useAnimatedStyle(() => {\n    if (activeSectionY.value <= 0) return { opacity: 0 };\n    const opacity = interpolate(\n      scrollY.value,\n      [activeSectionY.value - 4, activeSectionY.value + 12],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n    return { opacity };\n  });\n\n  const handleClose = () => handleCloseAnimated();\n\n  return (\n    <Modal\n      visible={visible || isClosing}\n      transparent\n      statusBarTranslucent\n      animationType=\"none\"\n      onRequestClose={() => handleCloseAnimated()}\n    >\n      <GestureHandlerRootView style={{ flex: 1 }}>\n\n      <View style={styles.modalOverlay}>\n        <Pressable style={[styles.backdrop, { backgroundColor: isExpanded ? \"transparent\" : \"rgba(0, 0, 0, 0.5)\" }]} onPress={() => handleCloseAnimated()} />\n\n        {/* <GestureDetector gesture={panGesture}> */}\n          <Animated.View\n            style={[\n              styles.modalContent,\n              sheetStyle,\n              {\n                backgroundColor: theme.backgroundRoot,\n                paddingBottom: insets.bottom + Spacing.lg,\n                paddingTop: isExpanded ? insets.top : Spacing.sm,\n              },\n            ]}\n          >\n            {!isExpanded && <View style={styles.handle} />}\n            <GestureDetector gesture={panGesture}>\n            <View style={styles.header}>\n              {isExpanded ? (\n                <Pressable onPress={handleClose} style={styles.backButton}>\n                  <Feather name=\"arrow-left\" size={24} color={theme.text} />\n                </Pressable>\n              ) : null}\n              <ThemedText type=\"h4\" style={isExpanded ? styles.expandedTitle : undefined}>Add Drink</ThemedText>\n              {onNavigateToCustomDrink && !isExpanded && (\n                <Pressable onPress={handleAddCustomDrink} style={styles.addCustomButton}>\n                  <Feather name=\"plus\" size={24} color={Colors.light.accent} />\n                </Pressable>\n              )}\n              {isExpanded && onNavigateToCustomDrink && (\n                <Pressable onPress={handleAddCustomDrink} style={styles.addCustomButton}>\n                  <Feather name=\"plus\" size={24} color={Colors.light.accent} />\n                </Pressable>\n              )}\n            </View>\n            </GestureDetector>\n            {!selectedDrink ? (\n              <View style={styles.drinkListContainer}>\n                {/* Fixed Search Bar - Always Visible */}\n                <View style={[styles.fixedHeader, { backgroundColor: theme.backgroundRoot, position: \"relative\" }]}>\n                  <View style={styles.searchRow}>\n                    <View style={[styles.searchBox, { backgroundColor: theme.backgroundDefault }]}>\n                      <Feather name=\"search\" size={20} color={theme.textMuted} />\n                      <TextInput\n                        style={[styles.searchInput, { color: theme.text }]}\n                        placeholder=\"Search drinks or brands...\"\n                        placeholderTextColor={theme.textMuted}\n                        value={searchQuery}\n                        onChangeText={setSearchQuery}\n                      />\n                      {searchQuery.length > 0 && (\n                        <Pressable onPress={() => setSearchQuery(\"\")}>\n                          <Feather name=\"x\" size={20} color={theme.textMuted} />\n                        </Pressable>\n                      )}\n                    </View>\n                  </View>\n                  \n                  {/* Sticky Section Header Overlay */}\n                  <Animated.View style={[styles.stickyClone, { backgroundColor: theme.backgroundRoot }, animatedStickyStyle]}>\n                    <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n                      {currentStickyLabel}\n                    </ThemedText>\n                  </Animated.View>\n                </View>\n\n                {/* Scrollable Content - Categories Scroll With Content */}\n                <Animated.ScrollView\n                  style={styles.scrollContent}\n                  showsVerticalScrollIndicator={false}\n                  onScroll={handleScroll}\n                  scrollEventThrottle={16}\n                  onMomentumScrollEnd={handleInfiniteScroll}\n                  onScrollEndDrag={handleInfiniteScroll}\n                >\n                  {/* Categories in ScrollView */}\n                  <View style={styles.categoriesRow}>\n                    {QUICK_CATEGORIES.map((cat) => (\n                      <QuickCategoryCard\n                        key={cat.key}\n                        label={cat.label}\n                        icon={cat.icon}\n                        isActive={selectedCategory === cat.key}\n                        onPress={() =>\n                          setSelectedCategory(selectedCategory === cat.key ? null : cat.key)\n                        }\n                      />\n                    ))}\n                  </View>\n\n                  {recentEntries.length > 0 && !searchQuery && (\n                    <View \n                      style={styles.section}\n                      onLayout={(e) => {\n                        quickAddY.value = e.nativeEvent.layout.y;\n                      }}\n                    >\n                      <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n                        QUICK ADD\n                      </ThemedText>\n                      {recentEntries.map((entry) => (\n                        <RecentEntryItem\n                          key={entry.id}\n                          entry={entry}\n                          onPress={() => handleQuickAdd(entry)}\n                        />\n                      ))}\n                    </View>\n                  )}\n\n                  {customDrinks.length > 0 && !searchQuery && (\n                    <View \n                      style={styles.section}\n                      onLayout={(e) => {\n                        customDrinksY.value = e.nativeEvent.layout.y;\n                      }}\n                    >\n                      <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n                        MY CUSTOM DRINKS\n                      </ThemedText>\n                      {customDrinks.map((drink) => (\n                        <CustomDrinkListItem\n                          key={drink.id}\n                          drink={drink}\n                          onPress={() => handleSelectDrink(drink)}\n                          onEdit={() => handleEditCustomDrink(drink)}\n                        />\n                      ))}\n                    </View>\n                  )}\n\n                  <View \n                    style={styles.section}\n                    onLayout={(e) => {\n                      categoryHeaderY.value = e.nativeEvent.layout.y;\n                    }}>\n                    <ThemedText type=\"small\" muted style={styles.sectionLabel}>\n                      {searchQuery ? \"RESULTS\" : selectedCategory!.toUpperCase()}\n                    </ThemedText>\n                    {displayedDrinks.map((drink) => (\n                      <MemoizedDrinkListItem\n                        key={drink.id}\n                        drink={drink}\n                        onPress={() => handleSelectDrink(drink)}\n                      />\n                    ))}\n                    {hasMoreDrinks && (\n                      <View style={styles.loadingMore}>\n                        <ActivityIndicator size=\"small\" color={Colors.light.accent} />\n                      </View>\n                    )}\n                  </View>\n                </Animated.ScrollView>\n              </View>\n            ) : (\n              <ScrollView\n                style={styles.scrollContent}\n                showsVerticalScrollIndicator={false}\n              >\n              <Pressable\n                onPress={() => setSelectedDrink(null)}\n                style={styles.backToDrinksButton}\n              >\n                <Feather name=\"arrow-left\" size={20} color={Colors.light.accent} />\n                <ThemedText type=\"body\" style={{ color: Colors.light.accent }}>\n                  Back to drinks\n                </ThemedText>\n              </Pressable>\n\n              <ThemedView elevation={1} style={styles.selectedDrinkCard}>\n                <View style={styles.selectedDrinkHeader}>\n                  <View style={styles.drinkIconLarge}>\n                    <Feather\n                      name={selectedDrink.icon as keyof typeof Feather.glyphMap}\n                      size={28}\n                      color={Colors.light.accent}\n                    />\n                  </View>\n                  <View style={styles.selectedDrinkInfo}>\n                    <ThemedText type=\"h4\">{selectedDrink.name}</ThemedText>\n                    <ThemedText type=\"small\" muted>\n                      {selectedDrink.caffeinePer100ml}mg per 100ml\n                    </ThemedText>\n                  </View>\n                </View>\n\n                {selectedDrink.sizes && selectedDrink.sizes.length > 0 && (\n                  <View style={styles.sizesSection}>\n                    <ThemedText type=\"small\" muted style={styles.sizesLabel}>\n                      SIZE\n                    </ThemedText>\n                    <View style={styles.sizesRow}>\n                      {selectedDrink.sizes.map((size) => (\n                        <SizeButton\n                          key={size.name}\n                          label={size.name}\n                          sublabel={`${size.ml}ml`}\n                          isActive={selectedSize === size.ml}\n                          onPress={() => setSelectedSize(size.ml)}\n                        />\n                      ))}\n                    </View>\n                  </View>\n                )}\n\n                <View style={styles.caffeinePreview}>\n                  <ThemedText type=\"caption\" muted>\n                    CAFFEINE\n                  </ThemedText>\n                  <ThemedText\n                    type=\"h2\"\n                    style={{\n                      color:\n                        warningLevel === \"danger\"\n                          ? Colors.light.danger\n                          : warningLevel === \"warning\"\n                            ? Colors.light.warning\n                            : Colors.light.accent,\n                    }}\n                  >\n                    {caffeineMg} mg\n                  </ThemedText>\n                </View>\n\n                {warningLevel && (\n                  <View\n                    style={[\n                      styles.warningBanner,\n                      {\n                        backgroundColor:\n                          warningLevel === \"danger\"\n                            ? `${Colors.light.danger}20`\n                            : `${Colors.light.warning}20`,\n                      },\n                    ]}\n                  >\n                    <Feather\n                      name=\"alert-triangle\"\n                      size={16}\n                      color={\n                        warningLevel === \"danger\"\n                          ? Colors.light.danger\n                          : Colors.light.warning\n                      }\n                    />\n                    <ThemedText\n                      type=\"small\"\n                      style={{\n                        color:\n                          warningLevel === \"danger\"\n                            ? Colors.light.danger\n                            : Colors.light.warning,\n                        flex: 1,\n                      }}\n                    >\n                      {warningLevel === \"danger\"\n                        ? \"This will exceed your daily limit!\"\n                        : \"You're approaching your daily limit. Consider a smaller size.\"}\n                    </ThemedText>\n                  </View>\n                )}\n              </ThemedView>\n\n              <View style={styles.optionsSection}>\n                <View\n                  style={[\n                    styles.notesInput,\n                    { backgroundColor: theme.backgroundDefault },\n                  ]}\n                >\n                  <TextInput\n                    style={[styles.notesTextInput, { color: theme.text }]}\n                    placeholder=\"Add a note (optional)\"\n                    placeholderTextColor={theme.textMuted}\n                    value={notes}\n                    onChangeText={setNotes}\n                  />\n                </View>\n\n                <Pressable\n                  onPress={() => setIsFavorite(!isFavorite)}\n                  style={[\n                    styles.favoriteToggle,\n                    { backgroundColor: theme.backgroundDefault },\n                  ]}\n                >\n                  <View style={styles.favoriteToggleContent}>\n                    <Feather\n                      name=\"heart\"\n                      size={20}\n                      color={isFavorite ? Colors.light.danger : theme.textMuted}\n                    />\n                    <ThemedText type=\"body\">Mark as favorite</ThemedText>\n                  </View>\n                  <View\n                    style={[\n                      styles.checkbox,\n                      {\n                        backgroundColor: isFavorite\n                          ? Colors.light.accent\n                          : \"transparent\",\n                        borderColor: isFavorite\n                          ? Colors.light.accent\n                          : theme.textMuted,\n                      },\n                    ]}\n                  >\n                    {isFavorite && (\n                      <Feather name=\"check\" size={14} color=\"#FFFFFF\" />\n                    )}\n                  </View>\n                </Pressable>\n              </View>\n\n              <View style={styles.actionsRow}>\n                <Pressable\n                  onPress={handleClose}\n                  style={[\n                    styles.cancelButton,\n                    { borderColor: theme.textMuted },\n                  ]}\n                >\n                  <ThemedText type=\"body\" muted>\n                    Cancel\n                  </ThemedText>\n                </Pressable>\n                <Pressable\n                  onPress={handleAdd}\n                  style={[\n                    styles.addButton,\n                    { opacity: caffeineMg > 0 ? 1 : 0.5 },\n                  ]}\n                  disabled={caffeineMg <= 0}\n                >\n                  <ThemedText type=\"body\" style={styles.addButtonText}>\n                    Add to today\n                  </ThemedText>\n                </Pressable>\n              </View>\n            </ScrollView>\n            )}\n          </Animated.View>\n        {/* </GestureDetector> */}\n      </View>\n      </GestureHandlerRootView>\n      <CustomDrinkModal\n        visible={showCustomDrinkModal}\n        onClose={() => { setShowCustomDrinkModal(false); setPrefillDrink(null); setEditingCustomDrink(null); }}\n        onAdd={handleCustomDrinkAdded}\n        prefillDrink={prefillDrink}\n        editCustomDrink={editingCustomDrink}\n        onSaveCustomDrink={handleSaveCustomDrink}\n      />\n    </Modal>\n  );\n}\n\ninterface QuickCategoryCardProps {\n  label: string;\n  icon: keyof typeof Feather.glyphMap;\n  isActive: boolean;\n  onPress: () => void;\n}\n\nfunction QuickCategoryCard({\n  label,\n  icon,\n  isActive,\n  onPress,\n}: QuickCategoryCardProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={() => {\n        scale.value = withSpring(0.95);\n      }}\n      onPressOut={() => {\n        scale.value = withSpring(1);\n      }}\n      style={[\n        styles.quickCategoryCard,\n        {\n          backgroundColor: isActive\n            ? Colors.light.accent\n            : theme.backgroundDefault,\n        },\n        animatedStyle,\n      ]}\n    >\n      <Feather name={icon} size={24} color={isActive ? \"#FFFFFF\" : theme.text} />\n      <ThemedText\n        type=\"small\"\n        style={[\n          styles.quickCategoryLabel,\n          { color: isActive ? \"#FFFFFF\" : theme.text },\n        ]}\n      >\n        {label}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\ninterface DrinkListItemProps {\n  drink: DrinkItem;\n  onPress: () => void;\n}\n\nfunction DrinkListItem({ drink, onPress }: DrinkListItemProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const caffeineMg = Math.round(\n    (drink.caffeinePer100ml * drink.defaultServingMl) / 100,\n  );\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={() => {\n        scale.value = withSpring(0.98);\n      }}\n      onPressOut={() => {\n        scale.value = withSpring(1);\n      }}\n      style={[\n        styles.drinkListItem,\n        { backgroundColor: theme.backgroundDefault },\n        animatedStyle,\n      ]}\n    >\n      <View style={styles.drinkIcon}>\n        <Image\n          source={getCategoryImageSource(drink.category)}\n          style={{ width: 40, height: 40, borderRadius: 20 }}\n          resizeMode=\"cover\"\n        />\n      </View>\n      <View style={styles.drinkInfo}>\n        <ThemedText type=\"body\" style={styles.drinkName}>\n          {drink.name}\n        </ThemedText>\n        <ThemedText type=\"caption\" muted>\n          {caffeineMg}mg / {drink.defaultServingMl}ml\n        </ThemedText>\n      </View>\n      <Feather name=\"chevron-right\" size={20} color={theme.textMuted} />\n    </AnimatedPressable>\n  );\n}\n\nconst MemoizedDrinkListItem = memo(DrinkListItem, (prev, next) => prev.drink.id === next.drink.id);\n\ninterface CustomDrinkListItemProps {\n  drink: DrinkItem;\n  onPress: () => void;\n  onEdit: () => void;\n}\n\nfunction CustomDrinkListItem({ drink, onPress, onEdit }: CustomDrinkListItemProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const caffeineMg = Math.round(\n    (drink.caffeinePer100ml * drink.defaultServingMl) / 100,\n  );\n  const servingLabel = drink.sizes?.[0]?.name || \"cup\";\n  const imageSource = getImageSourceForDrinkModal(drink);\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={() => { scale.value = withSpring(0.98); }}\n      onPressOut={() => { scale.value = withSpring(1); }}\n      style={[styles.drinkListItem, { backgroundColor: theme.backgroundDefault }, animatedStyle]}\n    >\n      <View style={styles.drinkIcon}>\n        <Image\n          source={imageSource.source || { uri: imageSource.uri }}\n          style={{ width: 40, height: 40, borderRadius: 20 }}\n          resizeMode=\"cover\"\n        />\n      </View>\n      <View style={styles.drinkInfo}>\n        <ThemedText type=\"body\" style={styles.drinkName}>\n          {drink.name}\n        </ThemedText>\n        <ThemedText type=\"caption\" muted>\n          {caffeineMg} mg / {servingLabel}\n        </ThemedText>\n      </View>\n      <Pressable \n        onPress={(e) => { e.stopPropagation(); onEdit(); }}\n        style={styles.editButton}\n        hitSlop={8}\n      >\n        <Feather name=\"edit-2\" size={16} color={Colors.light.accent} />\n      </Pressable>\n    </AnimatedPressable>\n  );\n}\n\ninterface RecentEntryItemProps {\n  entry: DrinkEntry;\n  onPress: () => void;\n}\n\nfunction RecentEntryItem({ entry, onPress }: RecentEntryItemProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const formatTime = (date: Date) => {\n    return new Date(date).toLocaleTimeString(\"en-US\", { hour: \"numeric\", minute: \"2-digit\" });\n  };\n\n  const servingLabel = entry.servingSize >= 100 ? `${(entry.servingSize / 100).toFixed(2).replace(/\\.?0+$/, '')} cup` : `${entry.servingSize}ml`;\n  const imageSource = getImageSourceForDrinkModal(entry);\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={() => { scale.value = withSpring(0.98); }}\n      onPressOut={() => { scale.value = withSpring(1); }}\n      style={[styles.drinkListItem, { backgroundColor: theme.backgroundDefault }, animatedStyle]}\n    >\n      <View style={styles.drinkIcon}>\n        <Image\n          source={imageSource.source || { uri: imageSource.uri }}\n          style={{ width: 40, height: 40, borderRadius: 20 }}\n          resizeMode=\"cover\"\n        />\n      </View>\n      <View style={styles.drinkInfo}>\n        <ThemedText type=\"body\" style={styles.drinkName}>\n          {entry.name}, {servingLabel}\n        </ThemedText>\n        <ThemedText type=\"caption\" muted>\n          Recently added: {formatTime(entry.timestamp)}\n        </ThemedText>\n      </View>\n      <ThemedText type=\"body\" style={{ fontWeight: \"600\" }}>\n        {entry.caffeineAmount} mg\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\ninterface SizeButtonProps {\n  label: string;\n  sublabel: string;\n  isActive: boolean;\n  onPress: () => void;\n}\n\nfunction SizeButton({ label, sublabel, isActive, onPress }: SizeButtonProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={() => {\n        scale.value = withSpring(0.95);\n      }}\n      onPressOut={() => {\n        scale.value = withSpring(1);\n      }}\n      style={[\n        styles.sizeButton,\n        {\n          backgroundColor: isActive\n            ? Colors.light.accent\n            : theme.backgroundSecondary,\n        },\n        animatedStyle,\n      ]}\n    >\n      <ThemedText\n        type=\"small\"\n        style={[\n          styles.sizeButtonLabel,\n          { color: isActive ? \"#FFFFFF\" : theme.text },\n        ]}\n      >\n        {label}\n      </ThemedText>\n      <ThemedText\n        type=\"caption\"\n        style={{ color: isActive ? \"#FFFFFF\" : theme.textMuted, opacity: 0.8 }}\n      >\n        {sublabel}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  modalOverlay: {\n    flex: 1,\n    justifyContent: \"flex-end\",\n  },\n  backdrop: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n  },\n  modalContent: {\n    borderTopLeftRadius: BorderRadius.lg,\n    borderTopRightRadius: BorderRadius.lg,\n    paddingTop: Spacing.sm,\n    overflow: \"hidden\",\n  },\n  handle: {\n    width: 36,\n    height: 5,\n    backgroundColor: Colors.light.divider,\n    borderRadius: 2.5,\n    alignSelf: \"center\",\n    marginBottom: Spacing.md,\n  },\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.md,\n  },\n  backButton: {\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginRight: Spacing.sm,\n  },\n  expandedTitle: {\n    flex: 1,\n  },\n  addCustomButton: {\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    backgroundColor: `${Colors.light.accent}15`,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  drinkListContainer: {\n    flex: 1,\n  },\n  fixedHeader: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.sm,\n    zIndex: 10,\n  },\n  searchRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.sm,\n  },\n  stickyClone: {\n    position: \"absolute\",\n    left: Spacing.xl,\n    right: Spacing.xl,\n    top: SEARCH_BAR_HEIGHT,\n    paddingTop: Spacing.xs,\n    paddingBottom: Spacing.xs,\n  },\n  scrollContent: {\n    paddingHorizontal: Spacing.xl,\n    flex: 1,\n  },\n  customDrinkButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    marginBottom: Spacing.lg,\n    gap: Spacing.md,\n  },\n  customDrinkIcon: {\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    backgroundColor: `${Colors.light.accent}20`,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  customDrinkInfo: {\n    flex: 1,\n  },\n  customDrinkLabel: {\n    fontWeight: \"500\",\n    marginBottom: 2,\n  },\n  searchContainer: {\n    marginBottom: Spacing.lg,\n  },\n  searchBox: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.sm,\n  },\n  searchInput: {\n    flex: 1,\n    fontSize: 16,\n    paddingVertical: Spacing.xs,\n  },\n  categoriesRow: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.md,\n    marginHorizontal: Spacing.xl,\n    paddingTop: Spacing.sm,\n  },\n  quickCategoryCard: {\n    flex: 1,\n    alignItems: \"center\",\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.xs,\n  },\n  quickCategoryLabel: {\n    fontWeight: \"500\",\n    textAlign: \"center\",\n    fontSize: 12,\n  },\n  section: {\n    marginBottom: Spacing.lg,\n  },\n  loadingMore: {\n    paddingVertical: Spacing.lg,\n    alignItems: \"center\",\n  },\n  sectionLabel: {\n    marginBottom: Spacing.sm,\n    fontWeight: \"600\",\n    letterSpacing: 0.5,\n  },\n  drinkListItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    marginBottom: Spacing.sm,\n    gap: Spacing.md,\n  },\n  drinkIcon: {\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    backgroundColor: `${Colors.light.accent}20`,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  drinkInfo: {\n    flex: 1,\n  },\n  customDrinkRight: {\n    alignItems: \"flex-end\",\n  },\n  editButton: {\n    padding: Spacing.xs,\n    marginLeft: Spacing.sm,\n  },\n  drinkName: {\n    fontWeight: \"500\",\n    marginBottom: 2,\n  },\n  backToDrinksButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.lg,\n  },\n  selectedDrinkCard: {\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    marginBottom: Spacing.lg,\n  },\n  selectedDrinkHeader: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n    marginBottom: Spacing.lg,\n  },\n  drinkIconLarge: {\n    width: 56,\n    height: 56,\n    borderRadius: 28,\n    backgroundColor: `${Colors.light.accent}20`,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  selectedDrinkInfo: {\n    flex: 1,\n  },\n  sizesSection: {\n    marginBottom: Spacing.lg,\n  },\n  sizesLabel: {\n    marginBottom: Spacing.sm,\n    fontWeight: \"600\",\n  },\n  sizesRow: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n  },\n  sizeButton: {\n    flex: 1,\n    alignItems: \"center\",\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.xs,\n  },\n  sizeButtonLabel: {\n    fontWeight: \"600\",\n  },\n  caffeinePreview: {\n    alignItems: \"center\",\n    paddingVertical: Spacing.lg,\n    borderTopWidth: 1,\n    borderTopColor: Colors.light.divider,\n  },\n  warningBanner: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    padding: Spacing.md,\n    borderRadius: BorderRadius.xs,\n    gap: Spacing.sm,\n    marginTop: Spacing.md,\n  },\n  optionsSection: {\n    gap: Spacing.sm,\n    marginBottom: Spacing.lg,\n  },\n  notesInput: {\n    borderRadius: BorderRadius.sm,\n    padding: Spacing.md,\n  },\n  notesTextInput: {\n    fontSize: 16,\n  },\n  favoriteToggle: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n  },\n  favoriteToggleContent: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n  },\n  checkbox: {\n    width: 24,\n    height: 24,\n    borderRadius: 6,\n    borderWidth: 2,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  actionsRow: {\n    flexDirection: \"row\",\n    gap: Spacing.md,\n    marginBottom: Spacing.lg,\n  },\n  cancelButton: {\n    flex: 1,\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.xs,\n    alignItems: \"center\",\n    borderWidth: 1,\n  },\n  addButton: {\n    flex: 2,\n    backgroundColor: Colors.light.accent,\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.xs,\n    alignItems: \"center\",\n  },\n  addButtonText: {\n    color: \"#FFFFFF\",\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":41454,"size_tokens":null},"screens/CaffeineIntakeDetailScreen.tsx":{"content":"import React, { useMemo, useState, useRef } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Text,\n  Pressable,\n  ScrollView,\n  Platform,\n  Dimensions,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useCaffeineStore } from \"@/store/caffeineStore\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius, Typography } from \"@/constants/theme\";\n\ntype TimePeriod = \"day\" | \"week\" | \"month\";\n\ninterface BarData {\n  label: string;\n  value: number;\n}\n\nexport default function CaffeineIntakeDetailScreen() {\n  const { theme } = useTheme();\n  const navigation = useNavigation();\n  const insets = useSafeAreaInsets();\n  const { entries } = useCaffeineStore();\n  const [selectedPeriod, setSelectedPeriod] = useState<TimePeriod>(\"day\");\n\n  const chartScrollRef = useRef<ScrollView>(null);\n  const CHART_HEIGHT = Dimensions.get(\"window\").height * 0.25;\n  const BAR_WIDTH = 50;\n\n  const { chartData, average } = useMemo(() => {\n    const now = new Date();\n    now.setHours(23, 59, 59, 999);\n    let data: BarData[] = [];\n\n    const getWeekTotal = (endDate: Date): number => {\n      const startOfWeek = new Date(endDate);\n      startOfWeek.setDate(endDate.getDate() - 6);\n      startOfWeek.setHours(0, 0, 0, 0);\n      const endOfWeek = new Date(endDate);\n      endOfWeek.setHours(23, 59, 59, 999);\n      return entries\n        .filter((e) => {\n          const t = new Date(e.timestamp);\n          return t >= startOfWeek && t <= endOfWeek;\n        })\n        .reduce((sum, e) => sum + e.caffeineAmount, 0);\n    };\n\n    const getMonthTotal = (date: Date): number => {\n      const startOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);\n      const endOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0);\n      endOfMonth.setHours(23, 59, 59, 999);\n      return entries\n        .filter((e) => {\n          const t = new Date(e.timestamp);\n          return t >= startOfMonth && t <= endOfMonth;\n        })\n        .reduce((sum, e) => sum + e.caffeineAmount, 0);\n    };\n\n    const getDayTotal = (date: Date): number => {\n      const startOfDay = new Date(date);\n      startOfDay.setHours(0, 0, 0, 0);\n      const endOfDay = new Date(date);\n      endOfDay.setHours(23, 59, 59, 999);\n      return entries\n        .filter((e) => {\n          const t = new Date(e.timestamp);\n          return t >= startOfDay && t <= endOfDay;\n        })\n        .reduce((sum, e) => sum + e.caffeineAmount, 0);\n    };\n\n    if (selectedPeriod === \"day\") {\n      for (let i = 364; i >= 0; i--) {\n        const date = new Date(now);\n        date.setDate(now.getDate() - i);\n        const label = date.toLocaleDateString(\"en-US\", { month: \"short\", day: \"numeric\" });\n        data.push({ label, value: getDayTotal(date) });\n      }\n    } else if (selectedPeriod === \"week\") {\n      for (let i = 51; i >= 0; i--) {\n        const weekEnd = new Date(now);\n        weekEnd.setDate(now.getDate() - i * 7);\n        const label = weekEnd.toLocaleDateString(\"en-US\", { month: \"short\", day: \"numeric\" });\n        data.push({ label, value: getWeekTotal(weekEnd) });\n      }\n    } else if (selectedPeriod === \"month\") {\n      for (let i = 11; i >= 0; i--) {\n        const date = new Date(now.getFullYear(), now.getMonth() - i, 1);\n        const label = date.toLocaleDateString(\"en-US\", { month: \"short\", year: \"2-digit\" });\n        data.push({ label, value: getMonthTotal(date) });\n      }\n    }\n\n    const totalValue = data.reduce((sum, d) => sum + d.value, 0);\n    const bucketCount = data.length;\n    const avg = bucketCount > 0 ? Math.round(totalValue / bucketCount) : 0;\n\n    return {\n      chartData: data,\n      average: avg,\n    };\n  }, [entries, selectedPeriod]);\n\n  const maxValue = Math.max(...chartData.map((d) => d.value), 1);\n\n  const getAverageLabel = () => {\n    switch (selectedPeriod) {\n      case \"day\":\n        return \"Daily average\";\n      case \"week\":\n        return \"Weekly average\";\n      case \"month\":\n        return \"Monthly average\";\n    }\n  };\n\n\n  return (\n    <View style={[styles.container, { backgroundColor: theme.backgroundRoot }]}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.md }]}>\n        <Pressable\n          onPress={() => navigation.goBack()}\n          style={styles.backButton}\n          hitSlop={{ top: 12, bottom: 12, left: 12, right: 12 }}\n        >\n          <Feather name=\"arrow-left\" size={24} color={theme.text} />\n        </Pressable>\n        <Text style={[styles.headerTitle, { color: theme.text }]}>Analytics</Text>\n        <View style={styles.headerSpacer} />\n      </View>\n\n      <ScrollView\n        style={styles.scrollView}\n        contentContainerStyle={styles.scrollContent}\n        showsVerticalScrollIndicator={false}\n      >\n        <View style={styles.titleSection}>\n          <Text style={[styles.title, { color: theme.text }]}>Caffeine intake</Text>\n          <Text style={[styles.description, { color: theme.mutedGrey }]}>\n            Track your caffeine consumption patterns over time. View daily, weekly, or monthly trends to understand your intake habits.\n          </Text>\n        </View>\n\n        <View style={styles.periodSelector}>\n          {([\"day\", \"week\", \"month\"] as TimePeriod[]).map((period) => (\n            <Pressable\n              key={period}\n              style={[\n                styles.periodButton,\n                selectedPeriod === period && {\n                  backgroundColor: theme.accentGold,\n                },\n                selectedPeriod !== period && {\n                  backgroundColor: theme.backgroundSecondary,\n                },\n              ]}\n              onPress={() => setSelectedPeriod(period)}\n            >\n              <Text\n                style={[\n                  styles.periodButtonText,\n                  {\n                    color: selectedPeriod === period ? \"#FFFFFF\" : theme.text,\n                  },\n                ]}\n              >\n                {period.charAt(0).toUpperCase() + period.slice(1)}\n              </Text>\n            </Pressable>\n          ))}\n        </View>\n\n        <View style={[styles.chartSection, { height: CHART_HEIGHT }]}>\n          <ScrollView\n            ref={chartScrollRef}\n            horizontal\n            showsHorizontalScrollIndicator={false}\n            contentContainerStyle={styles.chartScrollContent}\n            onContentSizeChange={() => chartScrollRef.current?.scrollToEnd({ animated: false })}\n          >\n            {chartData.map((item, idx) => (\n              <View key={idx} style={[styles.barColumn, { width: BAR_WIDTH }]}>\n                <View style={styles.barWrapper}>\n                  {item.value > 0 && (\n                    <>\n                      <Text style={[styles.barLabel, { color: theme.text }]}>\n                        {item.value}\n                      </Text>\n                      <View\n                        style={[\n                          styles.bar,\n                          {\n                            height: Math.max((item.value / maxValue) * (CHART_HEIGHT - 50), 4),\n                            backgroundColor: theme.accentGold,\n                          },\n                        ]}\n                      />\n                    </>\n                  )}\n                  {item.value === 0 && (\n                    <View\n                      style={[\n                        styles.barEmpty,\n                        { backgroundColor: theme.divider },\n                      ]}\n                    />\n                  )}\n                </View>\n                <Text style={[styles.xAxisLabel, { color: theme.mutedGrey }]}>\n                  {item.label}\n                </Text>\n              </View>\n            ))}\n          </ScrollView>\n        </View>\n\n        <View style={styles.averageSection}>\n          <Text style={[styles.averageValue, { color: theme.text }]}>{average} mg</Text>\n          <Text style={[styles.averageLabel, { color: theme.mutedGrey }]}>{getAverageLabel()}</Text>\n        </View>\n      </ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing.lg,\n  },\n  backButton: {\n    width: 24,\n  },\n  headerTitle: {\n    fontSize: 18,\n    fontWeight: \"600\",\n    textAlign: \"center\",\n  },\n  headerSpacer: {\n    width: 24,\n  },\n  scrollView: {\n    flex: 1,\n  },\n  scrollContent: {\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing[\"3xl\"],\n  },\n  titleSection: {\n    marginBottom: Spacing.xl,\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: \"700\",\n    marginBottom: Spacing.sm,\n  },\n  description: {\n    fontSize: 14,\n    lineHeight: 20,\n  },\n  periodSelector: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.xl,\n  },\n  periodButton: {\n    paddingHorizontal: Spacing.xl,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.xl,\n  },\n  periodButtonText: {\n    fontSize: 14,\n    fontWeight: \"600\",\n  },\n  chartSection: {\n    marginBottom: Spacing[\"3xl\"],\n  },\n  chartScrollContent: {\n    flexDirection: \"row\",\n    alignItems: \"flex-end\",\n    paddingHorizontal: Spacing.sm,\n  },\n  barColumn: {\n    alignItems: \"center\",\n  },\n  barWrapper: {\n    flex: 1,\n    justifyContent: \"flex-end\",\n    alignItems: \"center\",\n    width: \"100%\",\n  },\n  bar: {\n    width: 28,\n    borderRadius: 4,\n    minHeight: 4,\n  },\n  barEmpty: {\n    width: 28,\n    height: 8,\n    borderRadius: 4,\n  },\n  barLabel: {\n    fontSize: 11,\n    fontWeight: \"600\",\n    marginBottom: 4,\n  },\n  xAxisLabel: {\n    fontSize: 11,\n    marginTop: Spacing.sm,\n  },\n  averageSection: {\n    alignItems: \"flex-start\",\n  },\n  averageValue: {\n    fontSize: 40,\n    fontWeight: \"700\",\n    marginBottom: Spacing.xs,\n  },\n  averageLabel: {\n    fontSize: 14,\n  },\n});\n","path":null,"size_bytes":9968,"size_tokens":null},"components/HeaderTitle.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Image } from \"react-native\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { Colors, Spacing } from \"@/constants/theme\";\n\ninterface HeaderTitleProps {\n  title: string;\n}\n\nexport function HeaderTitle({ title }: HeaderTitleProps) {\n  return (\n    <View style={styles.container}>\n      <Image\n        source={require(\"../assets/images/icon.png\")}\n        style={styles.icon}\n        resizeMode=\"contain\"\n      />\n      <ThemedText style={styles.title}>{title}</ThemedText>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"flex-start\",\n  },\n  icon: {\n    width: 28,\n    height: 28,\n    marginRight: Spacing.sm,\n    borderRadius: 6,\n  },\n  title: {\n    fontSize: 17,\n    fontWeight: \"600\",\n    color: Colors.light.text,\n  },\n});\n","path":null,"size_bytes":888,"size_tokens":null},"screens/SleepTargetScreen.tsx":{"content":"import React, { useMemo, useState } from \"react\";\nimport { View, StyleSheet, Text, Pressable, ScrollView } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useCaffeineStore } from \"@/store/caffeineStore\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface DayData {\n  day: number;\n  caffeineAtSleep: number | null;\n  isBelowOptimal: boolean;\n  isToday: boolean;\n}\n\nconst CAFFEINE_HALF_LIFE_HOURS = 5;\n\nexport default function SleepTargetScreen() {\n  const { theme } = useTheme();\n  const navigation = useNavigation();\n  const insets = useSafeAreaInsets();\n  const { entries, profile } = useCaffeineStore();\n  const [currentMonth, setCurrentMonth] = useState(new Date());\n\n  const optimalCaffeine = profile.optimalCaffeine || 100;\n  const sleepTime = profile.sleepTime || \"23:00\";\n  const [sleepHour, sleepMinute] = sleepTime.split(\":\").map(Number);\n\n  const getCaffeineAtSleepTime = (date: Date): number => {\n    const sleepDateTime = new Date(date);\n    sleepDateTime.setHours(sleepHour, sleepMinute, 0, 0);\n\n    let caffeine = 0;\n    entries.forEach((entry) => {\n      const entryTime = new Date(entry.timestamp);\n      if (entryTime <= sleepDateTime) {\n        const hoursElapsed =\n          (sleepDateTime.getTime() - entryTime.getTime()) / (1000 * 60 * 60);\n        if (hoursElapsed >= 0 && hoursElapsed < 48) {\n          const remainingFactor = Math.pow(0.5, hoursElapsed / CAFFEINE_HALF_LIFE_HOURS);\n          caffeine += entry.caffeineAmount * remainingFactor;\n        }\n      }\n    });\n    return Math.round(caffeine);\n  };\n\n  const monthData = useMemo(() => {\n    const year = currentMonth.getFullYear();\n    const month = currentMonth.getMonth();\n    const firstDay = new Date(year, month, 1);\n    const lastDay = new Date(year, month + 1, 0);\n    const daysInMonth = lastDay.getDate();\n    const startDayOfWeek = firstDay.getDay();\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n\n    const days: (DayData | null)[] = [];\n\n    for (let i = 0; i < startDayOfWeek; i++) {\n      days.push(null);\n    }\n\n    for (let day = 1; day <= daysInMonth; day++) {\n      const date = new Date(year, month, day);\n      const isFuture = date > today;\n      const isToday = date.getTime() === today.getTime();\n\n      if (isFuture) {\n        days.push({ day, caffeineAtSleep: null, isBelowOptimal: false, isToday });\n      } else {\n        const caffeineAtSleep = getCaffeineAtSleepTime(date);\n        days.push({\n          day,\n          caffeineAtSleep,\n          isBelowOptimal: caffeineAtSleep < optimalCaffeine,\n          isToday,\n        });\n      }\n    }\n\n    return days;\n  }, [currentMonth, entries, optimalCaffeine, sleepHour, sleepMinute]);\n\n  const { successDays, currentStreak } = useMemo(() => {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    let streak = 0;\n    let countSuccess = 0;\n    let checkDate = new Date(today);\n\n    for (let i = 0; i < 365; i++) {\n      const caffeine = getCaffeineAtSleepTime(checkDate);\n      const isSuccess = caffeine < optimalCaffeine;\n\n      if (checkDate.getMonth() === currentMonth.getMonth() && \n          checkDate.getFullYear() === currentMonth.getFullYear()) {\n        if (isSuccess) countSuccess++;\n      }\n\n      if (i === 0 || streak > 0) {\n        if (isSuccess) {\n          streak++;\n        } else if (i > 0) {\n          break;\n        }\n      }\n\n      checkDate.setDate(checkDate.getDate() - 1);\n    }\n\n    return { successDays: countSuccess, currentStreak: streak };\n  }, [entries, optimalCaffeine, currentMonth, sleepHour, sleepMinute]);\n\n  const monthLabel = currentMonth.toLocaleDateString(\"en-US\", {\n    month: \"long\",\n    year: \"numeric\",\n  });\n\n  const navigateMonth = (direction: number) => {\n    const newMonth = new Date(currentMonth);\n    newMonth.setMonth(newMonth.getMonth() + direction);\n    setCurrentMonth(newMonth);\n  };\n\n  const weekDays = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"];\n\n  return (\n    <View style={[styles.container, { backgroundColor: theme.backgroundRoot }]}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.md }]}>\n        <Pressable\n          onPress={() => navigation.goBack()}\n          style={styles.backButton}\n          hitSlop={{ top: 12, bottom: 12, left: 12, right: 12 }}\n        >\n          <Feather name=\"arrow-left\" size={24} color={theme.text} />\n        </Pressable>\n        <Text style={[styles.headerTitle, { color: theme.text }]}>Analytic</Text>\n        <View style={styles.headerSpacer} />\n      </View>\n\n      <ScrollView\n        style={styles.scrollView}\n        contentContainerStyle={styles.scrollContent}\n        showsVerticalScrollIndicator={false}\n      >\n        <Text style={[styles.title, { color: theme.text }]}>Sleep target</Text>\n        <Text style={[styles.description, { color: theme.mutedGrey }]}>\n          How often are you going to bed with safe caffeine amounts?\n        </Text>\n\n        <View style={styles.monthNavigator}>\n          <Pressable onPress={() => navigateMonth(-1)} hitSlop={12}>\n            <Feather name=\"chevron-left\" size={20} color={theme.text} />\n          </Pressable>\n          <Text style={[styles.monthLabel, { color: theme.text }]}>{monthLabel}</Text>\n          <Pressable onPress={() => navigateMonth(1)} hitSlop={12}>\n            <Feather name=\"chevron-right\" size={20} color={theme.text} />\n          </Pressable>\n        </View>\n\n        <View style={styles.calendarGrid}>\n          {weekDays.map((d) => (\n            <View key={d} style={styles.weekDayHeader}>\n              <Text style={[styles.weekDayText, { color: theme.mutedGrey }]}>{d}</Text>\n            </View>\n          ))}\n\n          {monthData.map((dayData, idx) => (\n            <View key={idx} style={styles.dayCell}>\n              {dayData ? (\n                <View style={styles.dayCellContent}>\n                  <Text\n                    style={[\n                      styles.dayNumber,\n                      { color: dayData.isToday ? theme.accentGold : theme.text },\n                    ]}\n                  >\n                    {dayData.day}\n                  </Text>\n                  {dayData.caffeineAtSleep !== null && (\n                    <>\n                      {dayData.isBelowOptimal && (\n                        <Feather\n                          name=\"check-circle\"\n                          size={18}\n                          color={theme.blue}\n                          style={styles.checkIcon}\n                        />\n                      )}\n                      <Text style={[styles.caffeineLabel, { color: theme.mutedGrey }]}>\n                        {dayData.caffeineAtSleep} mg\n                      </Text>\n                    </>\n                  )}\n                </View>\n              ) : null}\n            </View>\n          ))}\n        </View>\n\n        <Text style={[styles.summaryText, { color: theme.text }]}>\n          Days where you had less than {optimalCaffeine} mg at your chosen bedtime.\n        </Text>\n\n        <View style={styles.streakSection}>\n          <Text style={[styles.streakLabel, { color: theme.text }]}>Current streak:</Text>\n          <View style={styles.streakValue}>\n            <Feather name=\"check-circle\" size={24} color={theme.blue} />\n            <Text style={[styles.streakNumber, { color: theme.text }]}>\n              {currentStreak} days\n            </Text>\n          </View>\n        </View>\n      </ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing.lg,\n  },\n  backButton: {\n    width: 24,\n  },\n  headerTitle: {\n    fontSize: 18,\n    fontWeight: \"600\",\n    textAlign: \"center\",\n  },\n  headerSpacer: {\n    width: 24,\n  },\n  scrollView: {\n    flex: 1,\n  },\n  scrollContent: {\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing[\"3xl\"],\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: \"700\",\n    marginBottom: Spacing.sm,\n  },\n  description: {\n    fontSize: 14,\n    lineHeight: 20,\n    marginBottom: Spacing.xl,\n  },\n  monthNavigator: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n    marginBottom: Spacing.xl,\n  },\n  monthLabel: {\n    fontSize: 16,\n    fontWeight: \"600\",\n    minWidth: 200,\n    textAlign: \"center\",\n  },\n  calendarGrid: {\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    marginBottom: Spacing.xl,\n  },\n  weekDayHeader: {\n    width: \"14.28%\",\n    alignItems: \"center\",\n    paddingVertical: Spacing.sm,\n  },\n  weekDayText: {\n    fontSize: 14,\n    fontWeight: \"500\",\n  },\n  dayCell: {\n    width: \"14.28%\",\n    aspectRatio: 1,\n    padding: 2,\n  },\n  dayCellContent: {\n    flex: 1,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  dayNumber: {\n    fontSize: 14,\n    fontWeight: \"500\",\n  },\n  checkIcon: {\n    marginTop: 2,\n  },\n  caffeineLabel: {\n    fontSize: 10,\n    marginTop: 2,\n  },\n  summaryText: {\n    fontSize: 16,\n    fontWeight: \"600\",\n    marginBottom: Spacing[\"2xl\"],\n  },\n  streakSection: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n  },\n  streakLabel: {\n    fontSize: 18,\n    fontWeight: \"600\",\n  },\n  streakValue: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n  },\n  streakNumber: {\n    fontSize: 28,\n    fontWeight: \"700\",\n  },\n});\n","path":null,"size_bytes":9567,"size_tokens":null},"components/CaffeineGraph.tsx":{"content":"import React, { useMemo } from \"react\";\nimport { View, StyleSheet, Dimensions, Text } from \"react-native\";\nimport Svg, {\n  Path,\n  Line,\n  Text as SvgText,\n  Defs,\n  LinearGradient,\n  Stop,\n  G,\n} from \"react-native-svg\";\nimport { Colors, Spacing } from \"@/constants/theme\";\nimport {\n  CaffeineEvent,\n  calculateCaffeineAtTime,\n  calculateDecayCurvePoints,\n} from \"@/utils/recommendationEngine\";\n\ninterface CaffeineGraphProps {\n  events: CaffeineEvent[];\n  bedtime: string;\n  optimalSleepThresholdMg?: number;\n  now?: Date;\n  halfLifeHours?: number;\n}\n\nconst { width: SCREEN_WIDTH } = Dimensions.get(\"window\");\nconst GRAPH_WIDTH = SCREEN_WIDTH - 32;\nconst GRAPH_HEIGHT = 200;\nconst PADDING_LEFT = 35;\nconst PADDING_RIGHT = 100;\nconst PADDING_TOP = 20;\nconst PADDING_BOTTOM = 40;\nconst CHART_WIDTH = GRAPH_WIDTH - PADDING_LEFT - PADDING_RIGHT;\nconst CHART_HEIGHT = GRAPH_HEIGHT - PADDING_TOP - PADDING_BOTTOM;\n\nexport function CaffeineGraph({\n  events,\n  bedtime,\n  optimalSleepThresholdMg = 100,\n  now = new Date(),\n  halfLifeHours = 5.5,\n}: CaffeineGraphProps) {\n  const currentCaffeine = useMemo(\n    () => calculateCaffeineAtTime(events, now, halfLifeHours),\n    [events, now, halfLifeHours]\n  );\n\n  const { startTime, endTime, bedtimeDate, timeLabels } = useMemo(() => {\n    const start = new Date(now);\n    start.setHours(start.getHours() - 8, 0, 0, 0);\n    const end = new Date(now);\n    end.setHours(end.getHours() + 16, 0, 0, 0);\n\n    const [bedHours, bedMinutes] = bedtime.split(\":\").map(Number);\n    const bed = new Date(now);\n    bed.setHours(bedHours, bedMinutes, 0, 0);\n    if (bed <= now) {\n      bed.setDate(bed.getDate() + 1);\n    }\n\n    const labels: { time: Date; label: string; x: number }[] = [];\n    const totalHours = (end.getTime() - start.getTime()) / (1000 * 60 * 60);\n    for (let h = 0; h <= totalHours; h += 2) {\n      const t = new Date(start.getTime() + h * 60 * 60 * 1000);\n      const hour = t.getHours();\n      const ampm = hour >= 12 ? \"PM\" : \"AM\";\n      const hour12 = hour % 12 || 12;\n      labels.push({\n        time: t,\n        label: `${hour12}${ampm}`,\n        x: PADDING_LEFT + (h / totalHours) * CHART_WIDTH,\n      });\n    }\n\n    return { startTime: start, endTime: end, bedtimeDate: bed, timeLabels: labels };\n  }, [now, bedtime]);\n\n  const decayPoints = useMemo(\n    () => calculateDecayCurvePoints(events, startTime, endTime, halfLifeHours, 2),\n    [events, startTime, endTime, halfLifeHours]\n  );\n\n  const maxMg = useMemo(() => {\n    const maxFromCurve = Math.max(...decayPoints.map((p) => p.mg), 50);\n    return Math.ceil(maxFromCurve / 50) * 50 + 50;\n  }, [decayPoints]);\n\n  const yScale = (mg: number): number => {\n    return PADDING_TOP + CHART_HEIGHT - (mg / maxMg) * CHART_HEIGHT;\n  };\n\n  const xScale = (time: Date): number => {\n    const totalMs = endTime.getTime() - startTime.getTime();\n    const elapsed = time.getTime() - startTime.getTime();\n    return PADDING_LEFT + (elapsed / totalMs) * CHART_WIDTH;\n  };\n\n  const pathD = useMemo(() => {\n    if (decayPoints.length === 0) return \"\";\n    const points = decayPoints.map((p) => ({\n      x: xScale(p.time),\n      y: yScale(p.mg),\n    }));\n\n    let d = `M ${points[0].x} ${points[0].y}`;\n    for (let i = 1; i < points.length; i++) {\n      const prev = points[i - 1];\n      const curr = points[i];\n      const cpx = (prev.x + curr.x) / 2;\n      d += ` Q ${prev.x + (curr.x - prev.x) * 0.5} ${prev.y}, ${curr.x} ${curr.y}`;\n    }\n    return d;\n  }, [decayPoints, startTime, endTime, maxMg]);\n\n  const nowX = xScale(now);\n  const bedtimeX = xScale(bedtimeDate);\n  const thresholdY = yScale(optimalSleepThresholdMg);\n\n  const sleepAffected = currentCaffeine > optimalSleepThresholdMg;\n  const sleepMessage = sleepAffected\n    ? \"Sleep may be affected.\"\n    : \"Your sleep should be unaffected.\";\n\n  const yAxisLabels = useMemo(() => {\n    const labels: { value: number; y: number }[] = [];\n    const step = maxMg <= 100 ? 25 : 50;\n    for (let v = 0; v <= maxMg; v += step) {\n      labels.push({ value: v, y: yScale(v) });\n    }\n    return labels;\n  }, [maxMg]);\n\n  return (\n    <View style={styles.container}>\n      <Svg width={GRAPH_WIDTH} height={GRAPH_HEIGHT}>\n        <Defs>\n          <LinearGradient id=\"curveGradient\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"0\">\n            <Stop offset=\"0\" stopColor={Colors.light.darkBrown2} stopOpacity=\"1\" />\n            <Stop offset=\"1\" stopColor={Colors.light.darkBrown} stopOpacity=\"1\" />\n          </LinearGradient>\n        </Defs>\n\n        {yAxisLabels.map((label) => (\n          <G key={label.value}>\n            <SvgText\n              x={PADDING_LEFT - 8}\n              y={label.y + 4}\n              fontSize={10}\n              fill={Colors.light.mutedGrey}\n              textAnchor=\"end\"\n            >\n              {label.value}\n            </SvgText>\n            <Line\n              x1={PADDING_LEFT}\n              y1={label.y}\n              x2={PADDING_LEFT + CHART_WIDTH}\n              y2={label.y}\n              stroke={Colors.light.divider}\n              strokeWidth={1}\n              strokeOpacity={0.5}\n            />\n          </G>\n        ))}\n\n        {timeLabels.map((label, index) => (\n          <SvgText\n            key={index}\n            x={label.x}\n            y={GRAPH_HEIGHT - 10}\n            fontSize={9}\n            fill={Colors.light.mutedGrey}\n            textAnchor=\"middle\"\n          >\n            {label.label}\n          </SvgText>\n        ))}\n\n        <Line\n          x1={PADDING_LEFT}\n          y1={thresholdY}\n          x2={PADDING_LEFT + CHART_WIDTH}\n          y2={thresholdY}\n          stroke={Colors.light.green}\n          strokeWidth={2}\n        />\n        <SvgText\n          x={PADDING_LEFT + 4}\n          y={thresholdY - 6}\n          fontSize={9}\n          fill={Colors.light.green}\n        >\n          Sleep unaffected\n        </SvgText>\n\n        <Line\n          x1={bedtimeX}\n          y1={PADDING_TOP}\n          x2={bedtimeX}\n          y2={PADDING_TOP + CHART_HEIGHT}\n          stroke={Colors.light.blue}\n          strokeWidth={1.5}\n          strokeDasharray=\"4,4\"\n        />\n\n        <Line\n          x1={nowX}\n          y1={PADDING_TOP}\n          x2={nowX}\n          y2={PADDING_TOP + CHART_HEIGHT}\n          stroke={Colors.light.darkBrown}\n          strokeWidth={1}\n        />\n        <SvgText\n          x={nowX}\n          y={PADDING_TOP + CHART_HEIGHT + 12}\n          fontSize={10}\n          fill={Colors.light.darkBrown}\n          textAnchor=\"middle\"\n          fontWeight=\"600\"\n        >\n          {now.toLocaleTimeString(\"en-US\", { hour: \"numeric\", minute: \"2-digit\" })}\n        </SvgText>\n\n        {pathD && (\n          <Path\n            d={pathD}\n            stroke=\"url(#curveGradient)\"\n            strokeWidth={3}\n            fill=\"none\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n          />\n        )}\n      </Svg>\n\n      <View style={styles.currentCaffeineContainer}>\n        <Text style={styles.currentCaffeineValue}>\n          {currentCaffeine.toFixed(1)} mg\n        </Text>\n        <Text\n          style={[\n            styles.sleepMessage,\n            { color: sleepAffected ? Colors.light.warning : Colors.light.green },\n          ]}\n        >\n          {sleepMessage}\n        </Text>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    position: \"relative\",\n    backgroundColor: Colors.light.bg,\n  },\n  currentCaffeineContainer: {\n    position: \"absolute\",\n    top: PADDING_TOP,\n    right: 8,\n    alignItems: \"flex-end\",\n  },\n  currentCaffeineValue: {\n    fontSize: 44,\n    fontWeight: \"700\",\n    color: Colors.light.darkBrown2,\n  },\n  sleepMessage: {\n    fontSize: 12,\n    fontWeight: \"500\",\n    marginTop: 4,\n    maxWidth: 100,\n    textAlign: \"right\",\n  },\n});\n","path":null,"size_bytes":7720,"size_tokens":null},"screens/HomeScreen.tsx":{"content":"import React, { useState, useMemo, useRef, useCallback, useEffect } from \"react\";\nimport { View, StyleSheet, Pressable, Text, Image, SectionList, NativeScrollEvent, NativeSyntheticEvent, Dimensions } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport { SafeAreaView, useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport Animated, {\n  useSharedValue,\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n  interpolate,\n  Extrapolation,\n  runOnJS,\n} from \"react-native-reanimated\";\nimport { HomeGraphController } from \"@/components/HomeGraphController\";\nimport { RingProgress } from \"@/components/RingProgress\";\nimport { CollapsibleInfoCards, ExpandButton } from \"@/components/CollapsibleInfoCards\";\nimport { StickyConsumptionTitle } from \"@/components/StickyConsumptionTitle\";\nimport { StickyDateHeader } from \"@/components/StickyDateHeader\";\nimport { CaffeineLogPopup } from \"@/components/CaffeineLogPopup\";\nimport { CustomDrinkModal } from \"@/components/CustomDrinkModal\";\nimport { StackedEntriesModal } from \"@/components/StackedEntriesModal\";\nimport { ScreenHeader } from \"@/components/ScreenHeader\";\nimport { useCaffeineStore, DrinkEntry } from \"@/store/caffeineStore\";\nimport {\n  calculateRecommendations,\n  getHoursUntilBedtime,\n} from \"@/utils/recommendationEngine\";\nimport { CaffeineEvent } from \"@/utils/graphUtils\";\nimport { calculateInfoCard, InfoCardResult } from \"@/utils/infocardLogic\";\nimport { Spacing } from \"@/constants/theme\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport type { HomeStackParamList } from \"@/navigation/HomeStackNavigator\";\nimport { DUMMY_ENTRIES } from \"@/utils/dummy_logs\";\n\ntype HomeScreenProps = {\n  navigation: NativeStackNavigationProp<HomeStackParamList, \"Home\">;\n};\n\ninterface SectionData {\n  title: string;\n  data: DrinkEntry[];\n  dateKey: string;\n}\n\nconst AnimatedSectionList = Animated.createAnimatedComponent(SectionList<DrinkEntry, SectionData>);\n\nfunction formatDateHeader(date: Date): string {\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  const yesterday = new Date(today);\n  yesterday.setDate(yesterday.getDate() - 1);\n  \n  const entryDate = new Date(date);\n  entryDate.setHours(0, 0, 0, 0);\n  \n  if (entryDate.getTime() === today.getTime()) {\n    return \"Today\";\n  } else if (entryDate.getTime() === yesterday.getTime()) {\n    return \"Yesterday\";\n  } else {\n    const days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n    const dayName = days[entryDate.getDay()];\n    const day = entryDate.getDate().toString().padStart(2, \"0\");\n    const month = (entryDate.getMonth() + 1).toString().padStart(2, \"0\");\n    const year = entryDate.getFullYear();\n    return `${dayName.toUpperCase()}, ${day}/${month}/${year}`;\n  }\n}\n\nfunction formatTime(timestamp: Date): string {\n  const date = new Date(timestamp);\n  return date.toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  });\n}\n\nconst CATEGORY_ICONS: Record<string, string> = {\n  coffee: \"\",\n  tea: \"\",\n  energy: \"\",\n  soda: \"\",\n  chocolate: \"\",\n  custom: \"\",\n};\n\nconst CATEGORY_IMAGES: Record<string, any> = {\n  coffee: require(\"@/assets/CaffeineSourceImages/coffee.png\"),\n  tea: require(\"@/assets/CaffeineSourceImages/tea.jpg\"),\n  energy: require(\"@/assets/CaffeineSourceImages/energy.png\"),\n  soda: require(\"@/assets/CaffeineSourceImages/soda.png\"),\n  chocolate: require(\"@/assets/CaffeineSourceImages/chocolate.png\"),\n};\n\nfunction getDrinkImageSource(item: DrinkEntry): { uri?: string; source?: any } {\n  const imageUri = item.imageUri;\n  if (item.category === \"custom\" && imageUri) {\n    if (imageUri.startsWith(\"preset:\")) {\n      const { PRESET_IMAGES } = require(\"@/components/ImagePickerModal\");\n      const preset = PRESET_IMAGES.find((p: any) => p.id === imageUri.replace(\"preset:\", \"\"));\n      return preset ? { source: preset.image } : {};\n    }\n    return { uri: imageUri };\n  }\n  return CATEGORY_IMAGES[item.category] ? { source: CATEGORY_IMAGES[item.category] } : {};\n}\n\nfunction getEntryIcon(category: string): string {\n  return CATEGORY_ICONS[category] || \"\";\n}\n\nexport default function HomeScreen({ navigation }: HomeScreenProps) {\n  const insets = useSafeAreaInsets();\n  const { theme, isDark } = useTheme();\n  const {\n    profile,\n    entries,\n    getTodayEntries,\n    getTodayCaffeine,\n    getActiveCaffeine,\n    deleteEntry,\n    addEntry,\n    getAllDrinks,\n  } = useCaffeineStore();\n\n  const [popupVisible, setPopupVisible] = useState(false);\n  const [editModalVisible, setEditModalVisible] = useState(false);\n  const [selectedEntry, setSelectedEntry] = useState<DrinkEntry | null>(null);\n  const [isEditingFromPopup, setIsEditingFromPopup] = useState(false);\n  const [currentStickyDate, setCurrentStickyDate] = useState<string>(\"\");\n  const [headerHeight, setHeaderHeight] = useState(0);\n  const [graphHeight, setGraphHeight] = useState(0);\n  const [titleHeight, setTitleHeight] = useState(0);\n  const [stackedModalVisible, setStackedModalVisible] = useState(false);\n  const [stackedEvents, setStackedEvents] = useState<CaffeineEvent[]>([]);\n  const [stackedPosition, setStackedPosition] = useState({ x: 0, y: 0 });\n  const [infoCardResult, setInfoCardResult] = useState<InfoCardResult | null>(null);\n  \n  // Scroll animation values\n  const scrollY = useSharedValue(0);\n  const scrollViewRef = useRef<any>(null);\n  const savedScrollOffset = useRef(0);\n  const COLLAPSE_THRESHOLD = 100; // Scroll threshold to trigger collapse\n  const DEFAULT_GRAPH_HEIGHT = Dimensions.get(\"window\").height * 0.36; // Graph height (36% of screen)\n  const HEADER_HEIGHT = 60; // Screen header height\n  const RING_ROW_HEIGHT = 72; // Ring progress row height\n  const GRAPH_BOTTOM_PADDING = Spacing.xl; // Keep sticky content below x-axis labels\n\n  const todayEntries = useMemo(() => getTodayEntries(), [entries]);\n  const todayCaffeine = useMemo(() => getTodayCaffeine(), [entries]);\n  const activeCaffeine = useMemo(() => getActiveCaffeine(), [entries]);\n\n  // Combine real entries with dummy data for testing\n  const allEntries = useMemo(() => {\n    return [...entries, ...DUMMY_ENTRIES].sort(\n      (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n    );\n  }, [entries]);\n\n  const caffeineEvents: CaffeineEvent[] = useMemo(() => {\n    return entries.map((entry) => ({\n      id: entry.id,\n      name: entry.name,\n      mg: entry.caffeineAmount,\n      timestampISO: new Date(entry.timestamp).toISOString(),\n      category: entry.category,\n      imageUri: entry.imageUri,\n    }));\n  }, [entries]);\n\n  // Parse wakeTime and sleepTime strings (format: \"HH:MM\")\n  const parseTimeString = (timeStr: string): Date => {\n    const today = new Date();\n    const [hours, minutes] = timeStr.split(\":\").map(Number);\n    const result = new Date(today);\n    result.setHours(hours, minutes, 0, 0);\n    if (result.getTime() < today.getTime()) {\n      result.setDate(result.getDate() + 1);\n    }\n    return result;\n  };\n\n  const wakeTime = useMemo(() => parseTimeString(profile.wakeTime), [profile.wakeTime]);\n  const sleepTime = useMemo(() => parseTimeString(profile.sleepTime), [profile.sleepTime]);\n\n  const recommendations = useMemo(() => {\n    const hoursUntilBed = getHoursUntilBedtime(profile.sleepTime);\n    return calculateRecommendations({\n      consumedTodayMg: todayCaffeine,\n      upcomingHoursUntilBed: hoursUntilBed,\n      currentCaffeineMg: activeCaffeine,\n      optimalDailyMg: profile.optimalCaffeine,\n      halfLifeHours: 5.5,\n      sleepThresholdMg: 40,\n    });\n  }, [todayCaffeine, activeCaffeine, profile]);\n\n  // Calculate info card recommendations using new logic\n  useEffect(() => {\n    const result = calculateInfoCard({\n      now: new Date(),\n      wakeTime,\n      sleepTime,\n      optimalDailyCaffeine: profile.optimalCaffeine,\n      totalConsumedCaffeine: todayCaffeine,\n      caffeineEntries: caffeineEvents,\n      halfLifeHours: 5.5,\n    });\n    setInfoCardResult(result);\n  }, [wakeTime, sleepTime, todayCaffeine, caffeineEvents, profile.optimalCaffeine]);\n\n  const sections = useMemo(() => {\n    if (allEntries.length === 0) return [];\n\n    // Group entries by date\n    const grouped = new Map<string, DrinkEntry[]>();\n    \n    allEntries.forEach((entry) => {\n      const entryDate = new Date(entry.timestamp);\n      entryDate.setHours(0, 0, 0, 0);\n      const dateKey = entryDate.toISOString();\n      \n      if (!grouped.has(dateKey)) {\n        grouped.set(dateKey, []);\n      }\n      grouped.get(dateKey)!.push(entry);\n    });\n\n    // Convert to sections array and sort by date (newest first)\n    const sectionsArray: SectionData[] = Array.from(grouped.entries())\n      .map(([dateKey, data]) => {\n        // Sort entries within each section by time (newest first)\n        const sortedData = [...data].sort(\n          (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n        );\n        return {\n          title: formatDateHeader(new Date(dateKey)),\n          data: sortedData,\n          dateKey,\n        };\n      })\n      .sort((a, b) => {\n        // Sort sections by date (newest first)\n        return new Date(b.dateKey).getTime() - new Date(a.dateKey).getTime();\n      });\n\n    return sectionsArray;\n  }, [allEntries]);\n\n  // Initialize and update current sticky date when sections change\n  useEffect(() => {\n    if (sections.length > 0) {\n      if (!currentStickyDate) {\n        // Initialize with first section\n        setCurrentStickyDate(sections[0].title);\n      }\n    }\n  }, [sections, currentStickyDate]);\n\n  const handleSelectEntry = (entry: DrinkEntry) => {\n    setSelectedEntry(entry);\n    setPopupVisible(true);\n  };\n\n  const handleClosePopup = () => {\n    setPopupVisible(false);\n    if (!isEditingFromPopup) {\n      setSelectedEntry(null);\n    }\n  };\n\n  const handleCloseEditModal = () => {\n    setEditModalVisible(false);\n    if (isEditingFromPopup) {\n      setPopupVisible(false);\n    }\n    setIsEditingFromPopup(false);\n    setSelectedEntry(null);\n  };\n\n  const handleEditEntry = (entry: DrinkEntry) => {\n    setIsEditingFromPopup(true);\n    setEditModalVisible(true);\n  };\n\n  const handleDuplicateEntry = (entry: DrinkEntry) => {\n    const allDrinks = getAllDrinks();\n    const drink = allDrinks.find((d) => d.id === entry.drinkId);\n    if (drink) {\n      addEntry(drink, entry.servingSize, entry.notes, entry.isFavorite);\n    }\n    setPopupVisible(false);\n    setSelectedEntry(null);\n  };\n\n  const handleDeleteEntry = (entry: DrinkEntry) => {\n    deleteEntry(entry.id);\n    setPopupVisible(false);\n    setSelectedEntry(null);\n  };\n\n  const handleGraphEventClick = useCallback((event: CaffeineEvent) => {\n    const matchingEntry = entries.find(e => e.id === event.id);\n    if (matchingEntry) {\n      setSelectedEntry(matchingEntry);\n      setPopupVisible(true);\n    }\n  }, [entries]);\n\n  const handleGraphStackedEventsClick = useCallback((events: CaffeineEvent[], position: { x: number; y: number }) => {\n    setStackedEvents(events);\n    setStackedPosition(position);\n    setStackedModalVisible(true);\n  }, []);\n\n  const handleStackedModalSelect = useCallback((event: CaffeineEvent) => {\n    const matchingEntry = entries.find(e => e.id === event.id);\n    if (matchingEntry) {\n      setSelectedEntry(matchingEntry);\n      setPopupVisible(true);\n    }\n  }, [entries]);\n\n  const handleStackedModalClose = useCallback(() => {\n    setStackedModalVisible(false);\n    setStackedEvents([]);\n  }, []);\n\n  // Track current visible section for sticky date header\n  const handleViewableItemsChanged = useCallback(({ viewableItems }: any) => {\n    if (viewableItems && viewableItems.length > 0) {\n      // Get the first viewable item's section\n      const firstItem = viewableItems.find((item: any) => item.isViewable) || viewableItems[0];\n      if (firstItem?.section?.title) {\n        setCurrentStickyDate(firstItem.section.title);\n      }\n    }\n  }, []);\n\n  // Also update on scroll to ensure we track the correct section\n  const scrollHandlerWithDateTracking = useAnimatedScrollHandler({\n    onScroll: (event) => {\n      scrollY.value = event.contentOffset.y;\n      // Update current date based on scroll position\n      // This will be handled by onViewableItemsChanged, but we can add fallback logic here if needed\n    },\n  });\n\n  const viewabilityConfig = useRef({\n    itemVisiblePercentThreshold: 10,\n    minimumViewTime: 100,\n  }).current;\n\n\n  // Handle expand button press\n  const handleExpand = () => {\n    // Save current scroll position\n    savedScrollOffset.current = scrollY.value;\n    \n    // Scroll back to top to show info cards\n    if (scrollViewRef.current) {\n      scrollViewRef.current.scrollToLocation({\n        sectionIndex: 0,\n        itemIndex: 0,\n        animated: true,\n        viewOffset: 0,\n      });\n    }\n    \n    // Reset scroll value after animation\n    setTimeout(() => {\n      scrollY.value = 0;\n    }, 300);\n  };\n\n  const renderItem = ({ item }: { item: DrinkEntry }) => {\n    return (\n      <Pressable\n        style={({ pressed }) => [\n          styles.entryRow,\n          {\n            backgroundColor: theme.backgroundSecondary,\n          },\n          pressed && { backgroundColor: theme.backgroundTertiary },\n        ]}\n        onPress={() => handleSelectEntry(item)}\n      >\n        <View style={[styles.iconContainer, { backgroundColor: theme.backgroundTertiary }]}>\n          {(() => {\n            const imageSource = getDrinkImageSource(item);\n            if (imageSource.source || imageSource.uri) {\n              return (\n                <Image\n                  source={imageSource.source || { uri: imageSource.uri }}\n                  style={styles.entryImage}\n                />\n              );\n            }\n            return <Text style={styles.entryEmoji}>{getEntryIcon(item.category)}</Text>;\n          })()}\n        </View>\n\n        <View style={styles.entryInfo}>\n          <Text style={[styles.entryName, { color: theme.darkBrown }]}>\n            {item.name}\n          </Text>\n          <Text style={[styles.entryTime, { color: theme.mutedGrey }]}>\n            {formatTime(item.timestamp)}\n          </Text>\n        </View>\n\n        <Text style={[styles.entryMg, { color: theme.darkBrown }]}>\n          {item.caffeineAmount} mg\n        </Text>\n      </Pressable>\n    );\n  };\n\n  const renderSectionHeader = ({ section }: { section: SectionData }) => {\n    return (\n      <View style={[styles.sectionHeader, { backgroundColor: theme.bg }]}>\n        <Text style={[styles.sectionHeaderText, { color: theme.mutedGrey }]}>\n          {section.title}\n        </Text>\n      </View>\n    );\n  };\n\n  const ListHeaderComponent = () => {\n    const titleOpacity = useAnimatedStyle(() => {\n      const progress = Math.min(scrollY.value / COLLAPSE_THRESHOLD, 1);\n      return {\n        opacity: interpolate(\n          progress,\n          [0.7, 1],\n          [1, 0],\n          Extrapolation.CLAMP\n        ),\n      };\n    });\n\n    return (\n      <>\n        <View style={styles.mainContent}>\n          <CollapsibleInfoCards\n            recommendations={recommendations}\n            infoCard={infoCardResult || undefined}\n            scrollY={scrollY}\n            collapseThreshold={COLLAPSE_THRESHOLD}\n            onExpand={handleExpand}\n            graphHeight={effectiveGraphHeight}\n            headerHeight={effectiveHeaderHeight}\n            topInset={insets.top}\n          />\n\n          <Animated.View style={[styles.consumptionHeader, titleOpacity]}>\n            <Text style={[styles.sectionTitle, { color: theme.darkBrown }]}>My consumption</Text>\n          </Animated.View>\n        </View>\n      </>\n    );\n  };\n\n  if (allEntries.length === 0) {\n    return (\n      <View style={[styles.outerContainer, { backgroundColor: theme.bg }]}>\n        <SafeAreaView\n          style={[\n            styles.safeArea,\n            {\n              paddingTop: insets.top,\n              paddingBottom: insets.bottom,\n            },\n          ]}\n          edges={[]}\n        >\n          <ScreenHeader title=\"Caffi\" showIcon={true} />\n          <View style={styles.container}>\n            <ListHeaderComponent />\n            <View style={[styles.emptyContainer, { backgroundColor: theme.backgroundDefault }]}>\n              <Feather name=\"coffee\" size={32} color={theme.mutedGrey} />\n              <Text style={[styles.emptyText, { color: theme.mutedGrey }]}>No drinks logged</Text>\n              <Text style={[styles.emptySubtext, { color: theme.mutedGrey }]}>Tap + to add your first drink</Text>\n            </View>\n          </View>\n        </SafeAreaView>\n      </View>\n    );\n  }\n\n  const effectiveHeaderHeight = headerHeight || HEADER_HEIGHT;\n  const effectiveGraphHeight = graphHeight || DEFAULT_GRAPH_HEIGHT;\n  // Calculate sticky offset: measured header + measured graph + bottom padding (for x-axis labels)\n  const stickyOffset = effectiveHeaderHeight + effectiveGraphHeight + GRAPH_BOTTOM_PADDING;\n\n  return (\n    <View style={[styles.outerContainer, { backgroundColor: theme.bg }]}>\n      <SafeAreaView\n        style={[\n          styles.safeArea,\n          {\n            paddingTop: insets.top,\n            paddingBottom: insets.bottom,\n          },\n        ]}\n        edges={[]}\n      >\n        <View\n          onLayout={(e) => setHeaderHeight(e.nativeEvent.layout.height)}\n        >\n          <ScreenHeader title=\"Caffi\" showIcon={true} />\n        </View>\n        \n        {/* Fixed Graph Section */}\n        <View\n          style={[\n            styles.fixedGraphContainer,\n            { paddingBottom: GRAPH_BOTTOM_PADDING },\n          ]}\n        >\n          <HomeGraphController\n            events={caffeineEvents}\n            bedtime={profile.sleepTime}\n            sleepThresholdMg={40}\n            optimalCaffeineMg={profile.optimalCaffeine}\n            halfLifeHours={5.5}\n            isDark={isDark}\n            onHeight={setGraphHeight}\n            onEventClick={handleGraphEventClick}\n            onStackedEventsClick={handleGraphStackedEventsClick}\n          />\n        </View>\n\n        {/* Sticky Consumption Title Overlay */}\n        <StickyConsumptionTitle\n          scrollY={scrollY}\n          collapseThreshold={COLLAPSE_THRESHOLD}\n          stickyOffset={stickyOffset}\n          onHeight={setTitleHeight}\n        />\n\n        {/* Sticky Date Header */}\n        <StickyDateHeader\n          scrollY={scrollY}\n          collapseThreshold={COLLAPSE_THRESHOLD}\n          stickyOffset={stickyOffset}\n          currentDate={currentStickyDate}\n          titleHeight={titleHeight}\n        />\n\n        {/* Expand Button - positioned outside scroll view */}\n        <ExpandButton\n          scrollY={scrollY}\n          collapseThreshold={COLLAPSE_THRESHOLD}\n          onExpand={handleExpand}\n          graphHeight={effectiveGraphHeight}\n          headerHeight={effectiveHeaderHeight}\n          topInset={insets.top}\n        />\n\n        {/* Scrollable Content */}\n        <View style={styles.container}>\n          <AnimatedSectionList\n            ref={scrollViewRef}\n            sections={sections}\n            renderItem={renderItem}\n            renderSectionHeader={renderSectionHeader}\n            ListHeaderComponent={ListHeaderComponent}\n            keyExtractor={(item) => item.id}\n            stickySectionHeadersEnabled={false}\n            contentContainerStyle={styles.listContent}\n            style={styles.list}\n            showsVerticalScrollIndicator={false}\n            onScroll={scrollHandlerWithDateTracking}\n            scrollEventThrottle={16}\n            onViewableItemsChanged={handleViewableItemsChanged}\n            viewabilityConfig={viewabilityConfig}\n          />\n        </View>\n      </SafeAreaView>\n\n      <CaffeineLogPopup\n        visible={popupVisible}\n        entry={selectedEntry}\n        onClose={handleClosePopup}\n        onEdit={handleEditEntry}\n        onDuplicate={handleDuplicateEntry}\n        onDelete={handleDeleteEntry}\n      />\n\n      <CustomDrinkModal\n        visible={editModalVisible}\n        editEntry={selectedEntry}\n        onClose={handleCloseEditModal}\n      />\n\n      <StackedEntriesModal\n        visible={stackedModalVisible}\n        events={stackedEvents}\n        position={stackedPosition}\n        onClose={handleStackedModalClose}\n        onSelectEvent={handleStackedModalSelect}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  outerContainer: {\n    flex: 1,\n  },\n  safeArea: {\n    flex: 1,\n  },\n  fixedGraphContainer: {\n    zIndex: 1,\n    backgroundColor: \"transparent\",\n  },\n  container: {\n    flex: 1,\n  },\n  list: {\n    flex: 1,\n  },\n  listContent: {\n    paddingBottom: 120,\n    paddingTop: 0,\n  },\n  sectionHeader: {\n    paddingVertical: Spacing.sm,\n    paddingHorizontal: Spacing.lg,\n  },\n  sectionHeaderText: {\n    fontSize: 12,\n    fontWeight: \"600\",\n    letterSpacing: 0.5,\n  },\n  ringRow: {\n    flexDirection: \"row\",\n    justifyContent: \"flex-end\",\n    paddingHorizontal: Spacing.lg,\n    marginTop: Spacing.md,\n    marginBottom: Spacing.lg,\n  },\n  mainContent: {\n    paddingHorizontal: Spacing.lg,\n  },\n  recommendationsSection: {\n    marginBottom: Spacing.md,\n  },\n  consumptionHeader: {\n    marginTop:-25,\n    marginBottom: Spacing.md,\n  },\n  sectionTitle: {\n    fontSize: 22,\n    fontWeight: \"700\",\n  },\n  entryRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingVertical: Spacing.md,\n    paddingHorizontal: Spacing.lg,\n    width: \"100%\",\n  },\n  iconContainer: {\n    width: 44,\n    height: 44,\n    borderRadius: 8,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginRight: Spacing.md,\n    overflow: \"hidden\",\n  },\n  entryImage: {\n    width: 44,\n    height: 44,\n    borderRadius: 8,\n  },\n  entryEmoji: {\n    fontSize: 22,\n  },\n  entryInfo: {\n    flex: 1,\n  },\n  entryName: {\n    fontSize: 15,\n    fontWeight: \"700\",\n    marginBottom: 2,\n  },\n  entryTime: {\n    fontSize: 12,\n    fontWeight: \"400\",\n  },\n  entryMg: {\n    fontSize: 16,\n    fontWeight: \"700\",\n  },\n  emptyContainer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing[\"3xl\"],\n    gap: Spacing.sm,\n    marginHorizontal: Spacing.lg,\n  },\n  emptyText: {\n    fontSize: 16,\n    marginTop: Spacing.sm,\n  },\n  emptySubtext: {\n    fontSize: 13,\n  },\n});\n","path":null,"size_bytes":22191,"size_tokens":null},"scripts/build.js":{"content":"const fs = require(\"fs\");\nconst path = require(\"path\");\nconst { spawn } = require(\"child_process\");\nconst { Readable } = require(\"stream\");\nconst { pipeline } = require(\"stream/promises\");\n\nlet metroProcess = null;\n\nfunction exitWithError(message) {\n  console.error(message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n}\n\nfunction setupSignalHandlers() {\n  const cleanup = () => {\n    if (metroProcess) {\n      console.log(\"Cleaning up Metro process...\");\n      metroProcess.kill();\n    }\n    process.exit(0);\n  };\n\n  process.on(\"SIGINT\", cleanup);\n  process.on(\"SIGTERM\", cleanup);\n  process.on(\"SIGHUP\", cleanup);\n}\n\nfunction getDeploymentUrl() {\n  if (process.env.REPLIT_INTERNAL_APP_DOMAIN) {\n    const url = `https://${process.env.REPLIT_INTERNAL_APP_DOMAIN}`;\n    console.log(\"Using REPLIT_INTERNAL_APP_DOMAIN:\", url);\n    return url;\n  }\n\n  if (process.env.REPLIT_DEV_DOMAIN) {\n    const url = `https://${process.env.REPLIT_DEV_DOMAIN}`;\n    console.log(\"Using REPLIT_DEV_DOMAIN:\", url);\n    return url;\n  }\n\n  console.error(\n    \"ERROR: REPLIT_INTERNAL_APP_DOMAIN and REPLIT_DEV_DOMAIN not set\",\n  );\n  process.exit(1);\n}\n\nfunction prepareDirectories(timestamp) {\n  console.log(\"Preparing build directories...\");\n\n  if (fs.existsSync(\"static-build\")) {\n    fs.rmSync(\"static-build\", { recursive: true });\n  }\n\n  const dirs = [\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"ios\"),\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"android\"),\n    path.join(\"static-build\", \"ios\"),\n    path.join(\"static-build\", \"android\"),\n  ];\n\n  for (const dir of dirs) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n\n  console.log(\"Build:\", timestamp);\n}\n\nfunction clearMetroCache() {\n  console.log(\"Clearing Metro cache...\");\n\n  const cacheDirs = [\n    ...fs.globSync(\".metro-cache\"),\n    ...fs.globSync(\"node_modules/.cache/metro\"),\n  ];\n\n  for (const dir of cacheDirs) {\n    fs.rmSync(dir, { recursive: true, force: true });\n  }\n\n  console.log(\"Cache cleared\");\n}\n\nasync function checkMetroHealth() {\n  try {\n    const response = await fetch(\"http://localhost:8081/status\");\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\nasync function startMetro() {\n  const isRunning = await checkMetroHealth();\n  if (isRunning) {\n    return;\n  }\n\n  console.log(\"Starting Metro...\");\n  metroProcess = spawn(\"npm\", [\"run\", \"dev\"], {\n    stdio: [\"ignore\", \"ignore\", \"ignore\"],\n    detached: false,\n  });\n\n  for (let i = 0; i < 30; i++) {\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n    const healthy = await checkMetroHealth();\n    if (healthy) {\n      console.log(\"Metro ready\");\n      return;\n    }\n  }\n\n  console.error(\"Metro timeout\");\n  process.exit(1);\n}\n\nasync function downloadFile(url, outputPath) {\n  try {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const file = fs.createWriteStream(outputPath);\n    await pipeline(Readable.fromWeb(response.body), file);\n\n    const fileSize = fs.statSync(outputPath).size;\n\n    if (fileSize === 0) {\n      fs.unlinkSync(outputPath);\n      throw new Error(\"Downloaded file is empty\");\n    }\n  } catch (error) {\n    if (fs.existsSync(outputPath)) {\n      fs.unlinkSync(outputPath);\n    }\n    throw error;\n  }\n}\n\nasync function downloadBundle(platform, timestamp) {\n  const url = new URL(\"http://localhost:8081/index.bundle\");\n  url.searchParams.set(\"platform\", platform);\n  url.searchParams.set(\"dev\", \"false\");\n  url.searchParams.set(\"hot\", \"false\");\n  url.searchParams.set(\"lazy\", \"false\");\n  url.searchParams.set(\"minify\", \"true\");\n\n  const output = path.join(\n    \"static-build\",\n    timestamp,\n    \"_expo\",\n    \"static\",\n    \"js\",\n    platform,\n    \"bundle.js\",\n  );\n\n  try {\n    await downloadFile(url.toString(), output);\n  } catch (error) {\n    exitWithError(`Failed to download ${platform} bundle: ${error.message}`);\n  }\n}\n\nasync function downloadManifest(platform) {\n  const response = await fetch(\"http://localhost:8081/manifest\", {\n    headers: { \"expo-platform\": platform },\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status}`);\n  }\n\n  return await response.json();\n}\n\nasync function downloadBundlesAndManifests(timestamp) {\n  console.log(\"Downloading bundles and manifests...\");\n\n  try {\n    const [, , iosManifest, androidManifest] = await Promise.all([\n      downloadBundle(\"ios\", timestamp),\n      downloadBundle(\"android\", timestamp),\n      downloadManifest(\"ios\"),\n      downloadManifest(\"android\"),\n    ]);\n    console.log(\"Downloaded\");\n    return { ios: iosManifest, android: androidManifest };\n  } catch (error) {\n    exitWithError(`Download failed: ${error.message}`);\n  }\n}\n\nfunction extractAssets(timestamp) {\n  const bundles = {\n    ios: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"ios\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n    android: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"android\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n  };\n\n  const assetsMap = new Map();\n  const assetPattern =\n    /httpServerLocation:\"([^\"]+)\"[^}]*hash:\"([^\"]+)\"[^}]*name:\"([^\"]+)\"[^}]*type:\"([^\"]+)\"/g;\n\n  const extractFromBundle = (bundle, platform) => {\n    for (const match of bundle.matchAll(assetPattern)) {\n      const originalPath = match[1];\n      const filename = match[3] + \".\" + match[4];\n\n      const tempUrl = new URL(`http://localhost:8081${originalPath}`);\n      const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n      if (!unstablePath) {\n        throw new Error(`Asset missing unstable_path: ${originalPath}`);\n      }\n\n      const decodedPath = decodeURIComponent(unstablePath).replace(/^\\.\\//, \"\");\n      const key = path.posix.join(decodedPath, filename);\n\n      if (!assetsMap.has(key)) {\n        const asset = {\n          url: path.posix.join(\"/\", decodedPath, filename),\n          originalPath: originalPath,\n          filename: filename,\n          relativePath: decodedPath,\n          hash: match[2],\n          platforms: new Set(),\n        };\n\n        assetsMap.set(key, asset);\n      }\n      assetsMap.get(key).platforms.add(platform);\n    }\n  };\n\n  extractFromBundle(bundles.ios, \"ios\");\n  extractFromBundle(bundles.android, \"android\");\n\n  return Array.from(assetsMap.values());\n}\n\nasync function downloadAssets(assets, timestamp) {\n  if (assets.length === 0) {\n    return 0;\n  }\n\n  console.log(\"Downloading assets...\");\n  let successCount = 0;\n  const failures = [];\n\n  const downloadPromises = assets.map(async (asset) => {\n    const platform = Array.from(asset.platforms)[0];\n\n    const tempUrl = new URL(`http://localhost:8081${asset.originalPath}`);\n    const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n    if (!unstablePath) {\n      throw new Error(`Asset missing unstable_path: ${asset.originalPath}`);\n    }\n\n    const decodedPath = decodeURIComponent(unstablePath).replace(/^\\./, \"\");\n    const metroUrl = new URL(\n      `http://localhost:8081${path.posix.join(\"/assets\", decodedPath, asset.filename)}`,\n    );\n    metroUrl.searchParams.set(\"platform\", platform);\n    metroUrl.searchParams.set(\"hash\", asset.hash);\n\n    const outputDir = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      asset.relativePath,\n    );\n    fs.mkdirSync(outputDir, { recursive: true });\n    const output = path.join(outputDir, asset.filename);\n\n    try {\n      await downloadFile(metroUrl.toString(), output);\n      successCount++;\n    } catch (error) {\n      failures.push({\n        filename: asset.filename,\n        error: error.message,\n        url: metroUrl.toString(),\n      });\n    }\n  });\n\n  await Promise.all(downloadPromises);\n\n  if (failures.length > 0) {\n    const errorMsg =\n      `Failed to download ${failures.length} asset(s):\\n` +\n      failures\n        .map((f) => `  - ${f.filename}: ${f.error} (${f.url})`)\n        .join(\"\\n\");\n    exitWithError(errorMsg);\n  }\n\n  console.log(`Downloaded ${successCount} assets`);\n  return successCount;\n}\n\nfunction updateBundleUrls(timestamp, baseUrl) {\n  const updateForPlatform = (platform) => {\n    const bundlePath = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      platform,\n      \"bundle.js\",\n    );\n    let bundle = fs.readFileSync(bundlePath, \"utf-8\");\n\n    bundle = bundle.replace(\n      /httpServerLocation:\"(\\/[^\"]+)\"/g,\n      (_match, capturedPath) => {\n        const tempUrl = new URL(`http://localhost:8081${capturedPath}`);\n        const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n        if (!unstablePath) {\n          throw new Error(\n            `Asset missing unstable_path in bundle: ${capturedPath}`,\n          );\n        }\n\n        const decodedPath = decodeURIComponent(unstablePath).replace(\n          /^\\.\\//,\n          \"\",\n        );\n        return `httpServerLocation:\"${baseUrl}/${timestamp}/_expo/static/js/${decodedPath}\"`;\n      },\n    );\n\n    fs.writeFileSync(bundlePath, bundle);\n  };\n\n  updateForPlatform(\"ios\");\n  updateForPlatform(\"android\");\n  console.log(\"Updated bundle URLs\");\n}\n\nfunction updateManifests(manifests, timestamp, baseUrl, assetsByHash) {\n  const updateForPlatform = (platform, manifest) => {\n    if (!manifest.launchAsset || !manifest.extra) {\n      exitWithError(`Malformed manifest for ${platform}`);\n    }\n\n    manifest.launchAsset.url = `${baseUrl}/${timestamp}/_expo/static/js/${platform}/bundle.js`;\n    manifest.launchAsset.key = `bundle-${timestamp}`;\n    manifest.createdAt = new Date(\n      Number(timestamp.split(\"-\")[0]),\n    ).toISOString();\n    manifest.extra.expoClient.hostUri =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.debuggerHost =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.packagerOpts.dev = false;\n\n    if (manifest.assets && manifest.assets.length > 0) {\n      manifest.assets.forEach((asset) => {\n        if (!asset.url) return;\n\n        const hash = asset.hash;\n        if (!hash) return;\n\n        const assetInfo = assetsByHash.get(hash);\n        if (!assetInfo) return;\n\n        asset.url = `${baseUrl}/${timestamp}/_expo/static/js/${assetInfo.relativePath}/${assetInfo.filename}`;\n      });\n    }\n\n    fs.writeFileSync(\n      path.join(\"static-build\", platform, \"manifest.json\"),\n      JSON.stringify(manifest, null, 2),\n    );\n  };\n\n  updateForPlatform(\"ios\", manifests.ios);\n  updateForPlatform(\"android\", manifests.android);\n  console.log(\"Manifests updated\");\n}\n\nfunction createLandingPage(baseUrl) {\n  const expsUrl = baseUrl.replace(\"https://\", \"\");\n  const template = fs.readFileSync(\n    path.join(\"scripts\", \"landing-page-template.html\"),\n    \"utf-8\",\n  );\n\n  const html = template\n    .replace(/BASE_URL_PLACEHOLDER/g, baseUrl)\n    .replace(/EXPS_URL_PLACEHOLDER/g, expsUrl);\n\n  fs.writeFileSync(path.join(\"static-build\", \"index.html\"), html);\n  console.log(\"Complete\");\n}\n\nasync function main() {\n  console.log(\"Building static Expo Go deployment...\");\n\n  setupSignalHandlers();\n\n  const baseUrl = getDeploymentUrl();\n  const timestamp = `${Date.now()}-${process.pid}`;\n\n  prepareDirectories(timestamp);\n  clearMetroCache();\n\n  await startMetro();\n  const manifests = await downloadBundlesAndManifests(timestamp);\n\n  console.log(\"Processing assets...\");\n  const assets = extractAssets(timestamp);\n  console.log(\"Found\", assets.length, \"unique asset(s)\");\n\n  const assetsByHash = new Map();\n  for (const asset of assets) {\n    assetsByHash.set(asset.hash, {\n      relativePath: asset.relativePath,\n      filename: asset.filename,\n    });\n  }\n\n  const assetCount = await downloadAssets(assets, timestamp);\n\n  if (assetCount > 0) {\n    updateBundleUrls(timestamp, baseUrl);\n  }\n\n  console.log(\"Updating manifests and creating landing page...\");\n  updateManifests(manifests, timestamp, baseUrl, assetsByHash);\n  createLandingPage(baseUrl);\n\n  console.log(\"Build complete! Deploy to:\", baseUrl);\n\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(0);\n}\n\nmain().catch((error) => {\n  console.error(\"Build failed:\", error.message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n});\n","path":null,"size_bytes":12348,"size_tokens":null},"navigation/RootNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport MainTabNavigator from \"@/navigation/MainTabNavigator\";\nimport OnboardingScreen from \"@/screens/OnboardingScreen\";\nimport { useCaffeineStore } from \"@/store/caffeineStore\";\n\nexport type RootStackParamList = {\n  Onboarding: undefined;\n  Main: undefined;\n};\n\nconst Stack = createNativeStackNavigator<RootStackParamList>();\n\nexport default function RootNavigator() {\n  const { profile } = useCaffeineStore();\n\n  return (\n    <Stack.Navigator\n      screenOptions={{\n        headerShown: false,\n        animation: \"fade\",\n      }}\n    >\n      {!profile.hasCompletedOnboarding ? (\n        <Stack.Screen name=\"Onboarding\" component={OnboardingScreen} />\n      ) : (\n        <Stack.Screen name=\"Main\" component={MainTabNavigator} />\n      )}\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":874,"size_tokens":null},"design_guidelines.md":{"content":"# Caffi - Design Guidelines\n\n## Architecture\n\n### Authentication\n**No authentication required** - This is an offline-first, privacy-focused app. All data stored locally using AsyncStorage. Display privacy message in Settings: \"Your data never leaves this device.\"\n\n### Navigation Structure\n**Bottom Tab Navigation** with 4 tabs + centered FAB:\n- **Home** (Dashboard) - Main caffeine tracking view\n- **Add** (Centered FAB) - Quick drink entry (64px circular button)\n- **History** - Timeline and statistics\n- **Settings** - Profile and preferences\n\n**Navigation Flow:**\n- Onboarding (3 slides)  Dashboard\n- All modals slide up with backdrop dim\n- Standard back gestures for nested screens\n\n## Visual Design System\n\n### Color Palette\n```\nBackground White: #FFFFFF\nLight Coffee (cards/panels): #F5EBDD\nCoffee Accent (brand): #C69C6D\nDark Coffee (text/icons): #6B4C3B\nMuted Text: #5A5A5A\nSuccess: #2F9E44\nWarning: #F2A43A\nDanger: #E85D4E\nDivider: #EFEFEF\n```\n\n### Typography\n- **Font Family:** Inter (fallback: Poppins)\n- **Sizes:** Title 20-24px, Subtitle 16px, Body 14px, Small 12px\n- **Primary Text:** #6B4C3B (dark coffee)\n- **Secondary Text:** #5A5A5A (muted)\n\n### Spacing & Layout\n- **Grid:** 8pt baseline\n- **Horizontal Padding:** 16px\n- **Card Radius:** 12-16px\n- **Button Radius:** 8px\n- **Elevation:** Subtle shadow (y: 2-4px, blur: 8-12px)\n\n## Screen Specifications\n\n### 1. Onboarding (3 Slides)\n- **Purpose:** Explain privacy, tracking, sleep benefits\n- **Layout:** Full-screen slides with warm coffee gradient strip, simple illustrations\n- **Form:** Optional inputs (age, weight, wake/sleep hours) with \"Skip\" option\n- **CTA:** \"Get started\" primary button\n\n### 2. Home/Dashboard\n- **Header:** Greeting + date (transparent background)\n- **Main Content:** \n  - Large circular caffeine ring (220px diameter, shows mg/limit %)\n  - Ring accent: #C69C6D, track: #EFEFEF\n  - Horizontal chips: Today/24h/Week\n  - Quick stats row: Active caffeine, Last drink, Sleep impact\n- **Bottom:** Mini timeline (today's drinks with time, icon, mg)\n- **Empty State:** Friendly message with FAB prompt\n- **Safe Area:** Top inset = headerHeight + 24px, Bottom = tabBarHeight + 24px\n\n### 3. Add Drink Modal\n- **Trigger:** FAB or Add button\n- **Layout:** Full-screen modal slide-up\n- **Header:** Search box at top\n- **Content:** \n  - Categorized quick-pick cards (Coffee, Tea, Energy, Soda, Chocolate, Custom)\n  - Starbucks size dropdown (Tall, Grande, Venti, Short)\n  - Manual input fields with live mg calculation preview\n  - Toggle: \"Mark as favorite\"\n- **Validation:** Inline warning if mg > 80% daily limit\n- **CTAs:** \"Add to today\" (primary) + \"Cancel\"\n\n### 4. Drink Database\n- **Header:** Search + category filter chips\n- **Content:** Scrollable list grouped by category\n- **List Items:** Icon, name, standard mg/100ml, quick-add plus icon\n- **Interaction:** Long-press for details modal\n- **Empty State:** \"No results. Try different word.\"\n\n### 5. History/Timeline\n- **Header:** Calendar selector (Day/Week toggle)\n- **Graph:** Hourly bar/line chart showing mg over time\n- **List:** Drink entries with swipe actions (left: delete, right: edit)\n- **Weekly View:** Totals, average, sleep correlation card\n\n### 6. Statistics Screen\n- **Content:** Interactive caffeine-in-blood decay curve\n- **Toggle:** Show half-life vs Simplified view\n- **Display:** Predicted safe sleep time\n\n### 7. Custom Drink Editor\n- **Form Fields:** Name, category, caffeine per 100ml/serving, default size\n- **Preview:** Live consumption values\n- **CTA:** Save button\n\n### 8. Settings\n- **Sections:**\n  - Profile: Age, Weight, Pregnancy toggle\n  - Daily Limit: Input (default 400mg)\n  - Notifications: Toggles for alerts, sleep warnings\n  - Data: Export/Reset (local only)\n  - Privacy: Reassurance message\n  - About & Help\n\n## Component Library\n\n### Buttons\n- **Primary:** Filled #C69C6D, height 44-52px, radius 8px\n- **Secondary:** Outlined, same dimensions\n- **Tertiary:** Text only\n- **Disabled:** 50% opacity\n- **Tap Targets:** Minimum 44x44px\n\n### FAB (Floating Action Button)\n- **Size:** 64px circular\n- **Position:** Centered above tab bar\n- **Color:** #C69C6D with white plus icon\n- **Shadow:** y: 2px, opacity: 0.10, radius: 2px\n\n### Cards\n- **Background:** White on #F5EBDD panels\n- **Radius:** 12px\n- **Padding:** 12-16px\n- **Shadow:** Soft elevation\n\n### Input Fields\n- **Height:** 44-56px\n- **Radius:** 10-12px\n- **Left icon support**\n\n### Progress Rings\n- **Dashboard:** 220px diameter\n- **Compact:** 140px diameter\n- **Track:** #EFEFEF, Fill: #C69C6D\n\n### Icons\n- **Style:** Simple line + filled (Feather icons from @expo/vector-icons)\n- **Set:** coffee, tea, energy drink, soda, chocolate, favorite, delete, edit, history, settings, plus\n\n## Interactions & Animations\n\n- **Ring Fill:** Ease-in-out animation\n- **Timeline Entries:** Fade/slide on add\n- **FAB Press:** Small bounce\n- **Swipe Actions:** Left (delete), Right (edit)\n- **Pull-to-Refresh:** On Database and History\n- **Modal Transitions:** Slide-up with backdrop dim\n- **Success Toast:** \"Drink added\" with auto-dismiss\n- **Delete Undo:** Snackbar with UNDO button\n\n## Warnings & Alerts\n\n- **80% Limit:** Warning color (#F2A43A) with suggestion\n- **Over Limit:** Danger color (#E85D4E) with modal\n- **Sleep Impact:** Badge for caffeine after 4 PM\n- **Copy:** \"Caffeine logged after 4 PM may affect sleep tonight\"\n\n## Accessibility\n\n- **Contrast Ratio:** 4.5:1 for body text\n- **Tap Targets:** 44x44px\n- **Dynamic Type:** Support font scaling\n- **Visual Feedback:** All touchable elements show press state","path":null,"size_bytes":5557,"size_tokens":null},"hooks/useScreenInsets.ts":{"content":"import { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { useBottomTabBarHeight } from \"@react-navigation/bottom-tabs\";\n\nimport { Spacing } from \"@/constants/theme\";\n\nexport function useScreenInsets() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const tabBarHeight = useBottomTabBarHeight();\n\n  return {\n    paddingTop: headerHeight + Spacing.xl,\n    paddingBottom: tabBarHeight + Spacing.xl,\n    scrollInsetBottom: insets.bottom + 16,\n  };\n}\n","path":null,"size_bytes":563,"size_tokens":null},"navigation/screenOptions.ts":{"content":"import { Platform } from \"react-native\";\nimport { NativeStackNavigationOptions } from \"@react-navigation/native-stack\";\nimport { isLiquidGlassAvailable } from \"expo-glass-effect\";\n\ninterface ScreenOptionsParams {\n  theme: {\n    backgroundRoot: string;\n    text: string;\n  };\n  isDark: boolean;\n  transparent?: boolean;\n  statusBarHeight?: number;\n}\n\nexport const getCommonScreenOptions = ({\n  theme,\n  isDark,\n  transparent = true,\n  statusBarHeight = 0,\n}: ScreenOptionsParams): NativeStackNavigationOptions => {\n  // headerStatusBarHeight ensures header content is positioned below the status bar\n  // This is critical for both iOS and Android to prevent header titles from colliding with status bar\n  \n  return {\n    headerTitleAlign: \"center\",\n    headerTransparent: transparent,\n    headerBlurEffect: isDark ? \"dark\" : \"light\",\n    headerTintColor: theme.text,\n    // This is critical: ensures header content (title) is positioned below the status bar\n    // React Navigation uses this to add padding-top to the header content area\n    headerStatusBarHeight: statusBarHeight,\n    headerStyle: {\n      backgroundColor: Platform.select({\n        ios: transparent ? undefined : theme.backgroundRoot,\n        android: transparent ? undefined : theme.backgroundRoot,\n        web: theme.backgroundRoot,\n      }),\n      // Ensure header extends into status bar area for background\n      // React Navigation automatically handles content positioning with headerStatusBarHeight\n    },\n    gestureEnabled: true,\n    gestureDirection: \"horizontal\",\n    fullScreenGestureEnabled: isLiquidGlassAvailable() ? false : true,\n    contentStyle: {\n      backgroundColor: theme.backgroundRoot,\n    },\n  };\n};\n","path":null,"size_bytes":1694,"size_tokens":null},"components/StickyDateHeader.tsx":{"content":"import React from \"react\";\nimport { StyleSheet, Text } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  interpolate,\n  Extrapolation,\n} from \"react-native-reanimated\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing } from \"@/constants/theme\";\n\ninterface StickyDateHeaderProps {\n  scrollY: Animated.SharedValue<number>;\n  collapseThreshold: number;\n  stickyOffset: number;\n  currentDate: string;\n  titleHeight?: number;\n}\n\nexport function StickyDateHeader({\n  scrollY,\n  collapseThreshold,\n  stickyOffset,\n  currentDate,\n  titleHeight,\n}: StickyDateHeaderProps) {\n  const { theme } = useTheme();\n\n  const titleHeightValue = titleHeight ?? 28;\n  const dateOffset = stickyOffset + titleHeightValue - Spacing.xs;\n\n  const stickyStyle = useAnimatedStyle(() => {\n    const progress = Math.min(scrollY.value / collapseThreshold, 1);\n    const isSticky = scrollY.value >= collapseThreshold;\n    \n    return {\n      opacity: isSticky && currentDate\n        ? interpolate(progress, [0.8, 1], [0, 1], Extrapolation.CLAMP)\n        : 0,\n      pointerEvents: isSticky ? \"auto\" : \"none\",\n    } as any;\n  });\n\n  if (!currentDate) return null;\n\n  return (\n    <Animated.View\n      style={[\n        styles.container,\n        { top: dateOffset, backgroundColor: theme.bg },\n        stickyStyle,\n      ]}\n    >\n      <Text style={[styles.dateText, { color: theme.mutedGrey }]}>\n        {currentDate}\n      </Text>\n    </Animated.View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    position: \"absolute\",\n    left: 0,\n    right: 0,\n    zIndex: 9,\n    paddingTop: 0,\n    paddingBottom: Spacing.sm,\n    paddingHorizontal: Spacing.lg,\n  },\n  dateText: {\n    fontSize: 12,\n    fontWeight: \"600\",\n    letterSpacing: 0.5,\n  },\n});\n","path":null,"size_bytes":1747,"size_tokens":null},"components/TimePickerModal.tsx":{"content":"import React, { useState, useEffect, useMemo } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Modal,\n  Pressable,\n  ScrollView,\n  useWindowDimensions,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  withTiming,\n  runOnJS,\n} from \"react-native-reanimated\";\nimport { Gesture, GestureDetector, GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { Calendar, TimePickerModal as PaperTimePickerModal, registerTranslation, en } from \"react-native-paper-dates\";\nimport { Button, Provider as PaperProvider, MD3DarkTheme, MD3LightTheme, Portal } from \"react-native-paper\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\n\nregisterTranslation('en', en);\n\nconst BOTTOM_SHEET_HEIGHT_RATIO = 0.45;\nconst CALENDAR_HEADER_OFFSET = 100;\n\ninterface TimePickerModalProps {\n  visible: boolean;\n  onClose: () => void;\n  onSelectTime: (date: Date, label: string) => void;\n  initialDate?: Date;\n}\n\nconst PRESET_OPTIONS = [\n  { label: \"now\", minutes: 0 },\n  { label: \"10 minutes ago\", minutes: 10 },\n  { label: \"15 minutes ago\", minutes: 15 },\n  { label: \"20 minutes ago\", minutes: 20 },\n  { label: \"25 minutes ago\", minutes: 25 },\n  { label: \"30 minutes ago\", minutes: 30 },\n];\n\nexport function TimePickerModal({ visible, onClose, onSelectTime, initialDate }: TimePickerModalProps) {\n  const { theme, isDark } = useTheme();\n  const insets = useSafeAreaInsets();\n  const { width: windowWidth, height: windowHeight } = useWindowDimensions();\n\n  const [selectedPreset, setSelectedPreset] = useState<string>(\"now\");\n  const [customDate, setCustomDate] = useState(new Date());\n  const [showDatePicker, setShowDatePicker] = useState(false);\n  const [showTimePicker, setShowTimePicker] = useState(false);\n\n  const MODAL_HEIGHT = windowHeight * BOTTOM_SHEET_HEIGHT_RATIO;\n  const translateY = useSharedValue(MODAL_HEIGHT);\n  const startY = useSharedValue(0);\n\n  const calendarModalWidth = Math.min(windowWidth * 0.9, 400);\n  const calendarCellSize = calendarModalWidth / 7;\n  const calendarFixedHeight = (calendarCellSize * 6) + CALENDAR_HEADER_OFFSET;\n\n  const accentColor = isDark ? Colors.dark.accent : Colors.light.accent;\n  \n  const paperTheme = useMemo(() => {\n    const baseTheme = isDark ? MD3DarkTheme : MD3LightTheme;\n    const themeColors = isDark ? Colors.dark : Colors.light;\n    return {\n      ...baseTheme,\n      colors: {\n        ...baseTheme.colors,\n        primary: accentColor,\n        primaryContainer: isDark ? themeColors.backgroundSecondary : `${accentColor}20`,\n        onPrimaryContainer: isDark ? themeColors.text : accentColor,\n        secondary: accentColor,\n        secondaryContainer: isDark ? themeColors.backgroundSecondary : `${accentColor}15`,\n        onSecondaryContainer: themeColors.text,\n        surface: themeColors.backgroundRoot,\n        surfaceVariant: isDark ? themeColors.backgroundSecondary : themeColors.backgroundTertiary,\n        onSurface: themeColors.text,\n        onSurfaceVariant: themeColors.textMuted,\n        outline: themeColors.divider,\n        background: themeColors.backgroundRoot,\n        onBackground: themeColors.text,\n        elevation: {\n          level0: \"transparent\",\n          level1: themeColors.backgroundDefault,\n          level2: themeColors.backgroundSecondary,\n          level3: themeColors.backgroundTertiary,\n          level4: themeColors.backgroundTertiary,\n          level5: themeColors.backgroundTertiary,\n        },\n      },\n    };\n  }, [isDark, accentColor]);\n\n  useEffect(() => {\n    if (visible) {\n      setSelectedPreset(\"now\");\n      setCustomDate(initialDate || new Date());\n      translateY.value = MODAL_HEIGHT;\n        translateY.value = withSpring(0);\n    } else {\n      translateY.value = MODAL_HEIGHT;\n    }\n  }, [visible, translateY, initialDate]);\n\n  const closeModal = () => {\n    translateY.value = withTiming(MODAL_HEIGHT, { duration: 200 }, () => {\n      runOnJS(onClose)();\n    });\n  };\n\n  const panGesture = Gesture.Pan()\n    .onStart(() => {\n      startY.value = translateY.value;\n    })\n    .onUpdate((event) => {\n      const nextY = Math.max(0, startY.value + event.translationY);\n      translateY.value = nextY;\n    })\n    .onEnd((event) => {\n      const shouldClose = translateY.value > MODAL_HEIGHT * 0.35 || event.velocityY > 800;\n      if (shouldClose) {\n        translateY.value = withTiming(MODAL_HEIGHT, { duration: 200 }, () => {\n          runOnJS(onClose)();\n        });\n      } else {\n        translateY.value = withSpring(0, { damping: 16, stiffness: 200 });\n      }\n    });\n\n  const sheetStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: translateY.value }],\n  }));\n\n  const handlePresetSelect = (preset: typeof PRESET_OPTIONS[0]) => {\n    setSelectedPreset(preset.label);\n    const date = new Date();\n    date.setMinutes(date.getMinutes() - preset.minutes);\n    onSelectTime(date, preset.label);\n    closeModal();\n  };\n\n  const [selectedCalendarDate, setSelectedCalendarDate] = useState<Date | undefined>(undefined);\n\n  const onCalendarChange = (params: { date: Date | undefined }) => {\n    if (params.date) {\n      setSelectedCalendarDate(params.date);\n    }\n  };\n\n  const onDateConfirm = () => {\n    setShowDatePicker(false);\n    if (selectedCalendarDate) {\n      const newDate = new Date(customDate);\n      newDate.setFullYear(selectedCalendarDate.getFullYear());\n      newDate.setMonth(selectedCalendarDate.getMonth());\n      newDate.setDate(selectedCalendarDate.getDate());\n      setCustomDate(newDate);\n      setSelectedPreset(\"\");\n      onSelectTime(newDate, formatDateTime(newDate));\n    }\n  };\n\n  const onTimeConfirm = ({ hours, minutes }: { hours: number; minutes: number }) => {\n    setShowTimePicker(false);\n    const newDate = new Date(customDate);\n    newDate.setHours(hours);\n    newDate.setMinutes(minutes);\n    setCustomDate(newDate);\n    setSelectedPreset(\"\");\n    onSelectTime(newDate, formatDateTime(newDate));\n  };\n\n  const formatDate = (date: Date) => {\n    return date.toLocaleDateString(\"en-US\", {\n      month: \"2-digit\",\n      day: \"2-digit\",\n      year: \"numeric\",\n    });\n  };\n\n  const formatTime = (date: Date) => {\n    return date.toLocaleTimeString(\"en-US\", {\n      hour: \"numeric\",\n      minute: \"2-digit\",\n      hour12: true,\n    });\n  };\n\n  const formatDateTime = (date: Date) => {\n    return `${formatDate(date)} ${formatTime(date)}`;\n  };\n\n  if (!visible) return null;\n\n  return (\n    <PaperProvider theme={paperTheme}>\n      <Modal\n        visible={visible}\n        transparent\n        statusBarTranslucent\n        animationType=\"fade\"\n        onRequestClose={closeModal}\n      >\n        <GestureHandlerRootView style={{ flex: 1 }} >\n        <View style={styles.overlay}>\n          <Pressable style={styles.backdrop} onPress={closeModal} />\n\n          <GestureDetector gesture={panGesture}>\n            <Animated.View\n              style={[\n                styles.modalContent,\n                sheetStyle,\n                {\n                  backgroundColor: theme.backgroundRoot,\n                  paddingBottom: insets.bottom + Spacing.lg,\n                  maxHeight: MODAL_HEIGHT,\n                },\n              ]}\n            >\n              <View style={styles.handleContainer}>\n                <View style={[styles.handle, { backgroundColor: accentColor }]} />\n              </View>\n\n              <View style={styles.content}>\n                <ThemedText type=\"body\" style={styles.sectionTitle}>Preset</ThemedText>\n                \n                <ScrollView\n                  horizontal\n                  showsHorizontalScrollIndicator={false}\n                  contentContainerStyle={styles.presetContainer}\n                >\n                  {PRESET_OPTIONS.map((preset) => (\n                    <Pressable\n                      key={preset.label}\n                      onPress={() => handlePresetSelect(preset)}\n                      style={[\n                        styles.presetChip,\n                        selectedPreset === preset.label\n                          ? { backgroundColor: Colors.light.accent }\n                          : { backgroundColor: theme.backgroundSecondary },\n                      ]}\n                    >\n                      <ThemedText\n                        type=\"body\"\n                        style={[\n                          styles.presetText,\n                          selectedPreset === preset.label && { color: \"#FFFFFF\" },\n                        ]}\n                      >\n                        {preset.label}\n                      </ThemedText>\n                    </Pressable>\n                  ))}\n                </ScrollView>\n\n                <ThemedText type=\"body\" style={styles.sectionTitle}>Custom</ThemedText>\n\n                <View style={styles.customRow}>\n                  <Pressable\n                    onPress={() => setShowDatePicker(true)}\n                    style={[styles.customButton, { backgroundColor: theme.backgroundSecondary }]}\n                  >\n                    <Feather name=\"calendar\" size={20} color={theme.accent} />\n                    <ThemedText type=\"body\">{formatDate(customDate)}</ThemedText>\n                  </Pressable>\n\n                  <Pressable\n                    onPress={() => setShowTimePicker(true)}\n                    style={[styles.customButton, { backgroundColor: theme.backgroundSecondary }]}\n                  >\n                    <Feather name=\"clock\" size={20} color={theme.accent} />\n                    <ThemedText type=\"body\">{formatTime(customDate)}</ThemedText>\n                  </Pressable>\n                </View>\n              </View>\n            </Animated.View>\n          </GestureDetector>\n        </View>\n\n        {showDatePicker && (\n          <Modal\n            visible={showDatePicker}\n            transparent\n            statusBarTranslucent\n            animationType=\"fade\"\n            onRequestClose={() => setShowDatePicker(false)}\n          >\n            <View style={styles.centeredOverlay}>\n              <Pressable style={styles.backdrop} onPress={() => setShowDatePicker(false)} />\n              <View style={[styles.calendarModal, { backgroundColor: theme.backgroundRoot }]}>\n                <View style={styles.calendarHeader}>\n                  <ThemedText type=\"h4\" style={styles.calendarTitle}>Select Date</ThemedText>\n                </View>\n                <View style={[styles.calendarWrapper, { height: calendarFixedHeight }]}>\n                  <Calendar\n                    locale=\"en\"\n                    mode=\"single\"\n                    date={selectedCalendarDate || customDate}\n                    onChange={onCalendarChange}\n                  />\n                </View>\n                <View style={styles.calendarActions}>\n                  <Button\n                    mode=\"text\"\n                    onPress={() => setShowDatePicker(false)}\n                    textColor={theme.textMuted}\n                  >\n                    Cancel\n                  </Button>\n                  <Button\n                    mode=\"contained\"\n                    onPress={onDateConfirm}\n                    buttonColor={accentColor}\n                  >\n                    Confirm\n                  </Button>\n                </View>\n              </View>\n            </View>\n          </Modal>\n        )}\n        </GestureHandlerRootView>\n      </Modal>\n\n      <Portal>\n        <PaperTimePickerModal\n          visible={showTimePicker}\n          onDismiss={() => setShowTimePicker(false)}\n          onConfirm={onTimeConfirm}\n          hours={customDate.getHours()}\n          minutes={customDate.getMinutes()}\n          label=\"Select Time\"\n          locale=\"en\"\n          cancelLabel=\"Cancel\"\n          confirmLabel=\"OK\"\n        />\n      </Portal>\n    </PaperProvider>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    flex: 1,\n    justifyContent: \"flex-end\",\n  },\n  centeredOverlay: {\n    flex: 1,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  backdrop: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n  },\n  calendarModal: {\n    borderRadius: BorderRadius.xl,\n    overflow: \"hidden\",\n    maxWidth: 400,\n    width: \"90%\",\n    elevation: 5,\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.25,\n    shadowRadius: 3.84,\n    paddingBottom: Spacing.md,\n  },\n  calendarWrapper: {\n    overflow: \"visible\",\n    paddingBottom: Spacing.sm,\n  },\n  calendarHeader: {\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.lg,\n    paddingBottom: Spacing.sm,\n  },\n  calendarTitle: {\n    fontWeight: \"600\",\n  },\n  calendarActions: {\n    flexDirection: \"row\",\n    justifyContent: \"flex-end\",\n    gap: Spacing.sm,\n    paddingHorizontal: Spacing.lg,\n    paddingTop: Spacing.md,\n  },\n  modalContent: {\n    borderTopLeftRadius: BorderRadius.xl,\n    borderTopRightRadius: BorderRadius.xl,\n  },\n  handleContainer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing.md,\n  },\n  handle: {\n    width: 40,\n    height: 4,\n    borderRadius: 2,\n  },\n  content: {\n    paddingHorizontal: Spacing.xl,\n  },\n  sectionTitle: {\n    fontWeight: \"600\",\n    marginBottom: Spacing.md,\n  },\n  presetContainer: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n    paddingBottom: Spacing.lg,\n  },\n  presetChip: {\n    paddingVertical: Spacing.sm,\n    paddingHorizontal: Spacing.lg,\n    borderRadius: BorderRadius.lg,\n  },\n  presetText: {\n    fontWeight: \"500\",\n  },\n  customRow: {\n    flexDirection: \"row\",\n    gap: Spacing.md,\n    marginBottom: Spacing.lg,\n  },\n  customButton: {\n    flex: 1,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n    paddingVertical: Spacing.md,\n    paddingHorizontal: Spacing.lg,\n    borderRadius: BorderRadius.md,\n  },\n});\n","path":null,"size_bytes":13936,"size_tokens":null},"screens/StatisticsScreen.tsx":{"content":"import React, { useMemo } from \"react\";\nimport { View, StyleSheet, Text, Pressable } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport { ScreenScrollView } from \"@/components/ScreenScrollView\";\nimport { ScreenHeader } from \"@/components/ScreenHeader\";\nimport { useCaffeineStore } from \"@/store/caffeineStore\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\nimport type { StatsStackParamList } from \"@/navigation/StatsStackNavigator\";\n\ntype StatsNavigationProp = NativeStackNavigationProp<StatsStackParamList>;\n\nexport default function StatisticsScreen() {\n  const { theme } = useTheme();\n  const { entries } = useCaffeineStore();\n  const navigation = useNavigation<StatsNavigationProp>();\n\n  const weeklyData = useMemo(() => {\n    const days = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n    const now = new Date();\n    const result: { day: string; value: number }[] = [];\n\n    for (let i = 6; i >= 0; i--) {\n      const date = new Date(now);\n      date.setDate(date.getDate() - i);\n      date.setHours(0, 0, 0, 0);\n      const nextDate = new Date(date);\n      nextDate.setDate(nextDate.getDate() + 1);\n\n      const dayTotal = entries\n        .filter((e) => {\n          const t = new Date(e.timestamp);\n          return t >= date && t < nextDate;\n        })\n        .reduce((sum, e) => sum + e.caffeineAmount, 0);\n\n      result.push({ day: days[date.getDay()], value: dayTotal });\n    }\n    return result;\n  }, [entries]);\n\n  const maxValue = Math.max(...weeklyData.map((d) => d.value), 1);\n\n  return (\n    <ScreenScrollView header={<ScreenHeader title=\"Analytics\" />}>\n      <Text style={[styles.subtitle, { color: theme.text }]}>Spotlight</Text>\n\n      <Pressable\n        style={[styles.card, { backgroundColor: theme.backgroundSecondary }]}\n        onPress={() => navigation.navigate(\"CaffeineIntakeDetail\")}\n      >\n        <View style={styles.cardHeader}>\n          <View style={styles.cardTitleRow}>\n            <Feather name=\"bar-chart-2\" size={18} color={theme.mutedGrey} />\n            <Text style={[styles.cardTitle, { color: theme.text }]}>\n              Daily caffeine intake\n            </Text>\n          </View>\n          <Feather name=\"arrow-right\" size={20} color={theme.mutedGrey} />\n        </View>\n\n        <View style={styles.chartContainer}>\n          {weeklyData.map((item, idx) => (\n            <View key={idx} style={styles.barColumn}>\n              <View style={styles.barWrapper}>\n                {item.value > 0 && (\n                  <>\n                    <Text style={[styles.barLabel, { color: theme.backgroundRoot }]}>\n                      {item.value}\n                    </Text>\n                    <View\n                      style={[\n                        styles.bar,\n                        {\n                          height: (item.value / maxValue) * 120,\n                          backgroundColor: theme.accentGold,\n                        },\n                      ]}\n                    />\n                  </>\n                )}\n                {item.value === 0 && (\n                  <View\n                    style={[\n                      styles.barEmpty,\n                      { backgroundColor: theme.divider },\n                    ]}\n                  />\n                )}\n              </View>\n              <Text style={[styles.dayLabel, { color: theme.mutedGrey }]}>\n                {item.day}\n              </Text>\n            </View>\n          ))}\n        </View>\n      </Pressable>\n\n      <MenuItem\n        icon=\"coffee\"\n        label=\"Caffeine by source\"\n        theme={theme}\n        onPress={() => navigation.navigate(\"CaffeineBySource\")}\n      />\n      <MenuItem\n        icon=\"clock\"\n        label=\"Sleep target\"\n        theme={theme}\n        onPress={() => navigation.navigate(\"SleepTarget\")}\n      />\n      <MenuItem\n        icon=\"refresh-cw\"\n        label=\"Consumption by time of day\"\n        theme={theme}\n        onPress={() => navigation.navigate(\"ConsumptionByTime\")}\n      />\n    </ScreenScrollView>\n  );\n}\n\nfunction MenuItem({\n  icon,\n  label,\n  theme,\n  onPress,\n}: {\n  icon: any;\n  label: string;\n  theme: any;\n  onPress?: () => void;\n}) {\n  return (\n    <Pressable\n      style={[styles.menuItem, { borderBottomColor: theme.divider }]}\n      onPress={onPress}\n    >\n      <View style={styles.menuItemLeft}>\n        <Feather name={icon} size={20} color={theme.mutedGrey} />\n        <Text style={[styles.menuItemLabel, { color: theme.text }]}>{label}</Text>\n      </View>\n      <Feather name=\"arrow-right\" size={20} color={theme.mutedGrey} />\n    </Pressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  subtitle: {\n    fontSize: 18,\n    fontWeight: \"600\",\n    marginBottom: Spacing.lg,\n  },\n  card: {\n    borderRadius: BorderRadius.md,\n    padding: Spacing.lg,\n    marginBottom: Spacing.xl,\n  },\n  cardHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    marginBottom: Spacing.xl,\n  },\n  cardTitleRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n  },\n  cardTitle: {\n    fontSize: 16,\n    fontWeight: \"600\",\n  },\n  chartContainer: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"flex-end\",\n    height: 160,\n    paddingTop: 20,\n  },\n  barColumn: {\n    flex: 1,\n    alignItems: \"center\",\n  },\n  barWrapper: {\n    flex: 1,\n    justifyContent: \"flex-end\",\n    alignItems: \"center\",\n  },\n  bar: {\n    width: 32,\n    borderRadius: 4,\n  },\n  barEmpty: {\n    width: 32,\n    height: 8,\n    borderRadius: 4,\n  },\n  barLabel: {\n    fontSize: 12,\n    fontWeight: \"700\",\n    marginBottom: 4,\n  },\n  dayLabel: {\n    fontSize: 12,\n    marginTop: Spacing.sm,\n  },\n  menuItem: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingVertical: Spacing.lg,\n    borderBottomWidth: StyleSheet.hairlineWidth,\n  },\n  menuItemLeft: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n  },\n  menuItemLabel: {\n    fontSize: 16,\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":6214,"size_tokens":null},"components/CustomDrinkModal.tsx":{"content":"import React, { useState, useMemo, useEffect } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Modal,\n  TextInput,\n  Pressable,\n  ScrollView,\n  useWindowDimensions,\n  Image,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  withTiming,\n  runOnJS,\n} from \"react-native-reanimated\";\nimport { Gesture, GestureDetector,GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { ImagePickerModal, PRESET_IMAGES } from \"@/components/ImagePickerModal\";\nimport { TimePickerModal } from \"@/components/TimePickerModal\";\nimport { GlowIndicator } from \"@/components/GlowIndicator\";\nimport { useCaffeineStore, DrinkEntry } from \"@/store/caffeineStore\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\nimport {\n  CaffeineEvent,\n  getPeakCaffeineWithNewEntry,\n  getMaxCaffeineInSleepWindow,\n  getCaffeineLimitStatus,\n  getSleepImpactStatus,\n  parseBedtimeToMs,\n} from \"@/utils/graphUtils\";\n\ninterface CustomDrinkModalProps {\n  visible: boolean;\n  onClose: () => void;\n  onAdd?: () => void;\n  editEntry?: DrinkEntry | null;\n  prefillDrink?: { id?: string; name: string; caffeinePer100ml: number; defaultServingMl: number; category?: string; sizes?: { name: string; ml: number }[] } | null;\n  editCustomDrink?: { id: string; name: string; caffeinePer100ml: number; defaultServingMl: number; category?: string; sizes?: { name: string; ml: number }[] } | null;\n  onSaveCustomDrink?: () => void;\n}\n\nconst getCategoryImageSource = (category: string) => {\n  const imageMap: Record<string, any> = {\n    coffee: require(\"@/assets/CaffeineSourceImages/coffee.png\"),\n    tea: require(\"@/assets/CaffeineSourceImages/tea.jpg\"),\n    energy: require(\"@/assets/CaffeineSourceImages/energy.png\"),\n    soda: require(\"@/assets/CaffeineSourceImages/soda.png\"),\n    chocolate: require(\"@/assets/CaffeineSourceImages/chocolate.png\"),\n  };\n  return imageMap[category] || imageMap.coffee;\n};\n\nconst getUnitForDrink = (name: string, category?: string, sizes?: { name: string; ml: number }[]): string => {\n  const lowerName = name.toLowerCase();\n  if (lowerName.includes(\"espresso\") || lowerName.includes(\"shot\")) return \"shot\";\n  if (lowerName.includes(\"can\") || category === \"energy\" || category === \"soda\") return \"can\";\n  if (lowerName.includes(\"bottle\")) return \"bottle\";\n  if (sizes?.[0]?.name) return sizes[0].name;\n  if (category === \"tea\" || category === \"coffee\" || category === \"chocolate\") return \"cup\";\n  return \"cup\";\n};\n\nconst UNITS = [\"cup\", \"shot\", \"ml\", \"oz\", \"teaspoon\", \"tablespoon\", \"glass\", \"can\", \"bottle\", \"scoop\", \"pint\", \"liter\", \"fl oz\", \"mug\"];\n\nexport function CustomDrinkModal({ visible, onClose, onAdd, editEntry, prefillDrink, editCustomDrink, onSaveCustomDrink }: CustomDrinkModalProps) {\n  const { theme } = useTheme();\n  const insets = useSafeAreaInsets();\n  const { addEntry, updateEntry, addCustomDrink, updateCustomDrink, profile, entries } = useCaffeineStore();\n  const { height: windowHeight } = useWindowDimensions();\n  const HALF_LIFE_HOURS = 5;\n  \n  const MODAL_HEIGHT = windowHeight * 0.75;\n  const isEditMode = !!editEntry;\n  const isEditingCustomDrink = !!editCustomDrink;\n\n  const [drinkName, setDrinkName] = useState(\"\");\n  const [quantity, setQuantity] = useState(1);\n  const [selectedUnit, setSelectedUnit] = useState(\"cup\");\n  const [caffeineMg, setCaffeineMg] = useState(\"10\");\n  const [showUnitPicker, setShowUnitPicker] = useState(false);\n  const [showImagePicker, setShowImagePicker] = useState(false);\n  const [selectedImage, setSelectedImage] = useState<string | null>(null);\n  const [showStartTimePicker, setShowStartTimePicker] = useState(false);\n  const [startTime, setStartTime] = useState<Date>(new Date());\n  const [startTimeLabel, setStartTimeLabel] = useState(\"now\");\n\n  useEffect(() => {\n    if (editEntry && visible) {\n      setDrinkName(editEntry.name || \"\");\n      setQuantity(1);\n      setCaffeineMg(editEntry.caffeineAmount?.toString() || \"10\");\n      setSelectedUnit(\"cup\");\n      setStartTime(new Date(editEntry.timestamp));\n      const entryDate = new Date(editEntry.timestamp);\n      const now = new Date();\n      const isToday = entryDate.toDateString() === now.toDateString();\n      if (isToday) {\n        const timeDiff = Math.abs(now.getTime() - entryDate.getTime());\n        if (timeDiff < 60000) {\n          setStartTimeLabel(\"now\");\n        } else {\n          setStartTimeLabel(entryDate.toLocaleTimeString(\"en-US\", { hour: \"numeric\", minute: \"2-digit\" }));\n        }\n      } else {\n        setStartTimeLabel(entryDate.toLocaleTimeString(\"en-US\", { hour: \"numeric\", minute: \"2-digit\" }));\n      }\n    } else if (editCustomDrink && visible) {\n      setDrinkName(editCustomDrink.name);\n      setQuantity(1);\n      const bestUnit = getUnitForDrink(editCustomDrink.name, editCustomDrink.category, editCustomDrink.sizes);\n      setSelectedUnit(bestUnit);\n      setCaffeineMg(editCustomDrink.caffeinePer100ml.toString());\n      setStartTime(new Date());\n      setStartTimeLabel(\"now\");\n      const imgUri = (editCustomDrink as any).imageUri;\n      if (imgUri) {\n        setSelectedImage(imgUri);\n      }\n    } else if (prefillDrink && visible && !editEntry) {\n      setDrinkName(prefillDrink.name);\n      setQuantity(1);\n      const bestUnit = getUnitForDrink(prefillDrink.name, prefillDrink.category, prefillDrink.sizes);\n      setSelectedUnit(bestUnit);\n      const caffeine = Math.round((prefillDrink.caffeinePer100ml * prefillDrink.defaultServingMl) / 100);\n      setCaffeineMg(caffeine.toString());\n      setStartTime(new Date());\n      setStartTimeLabel(\"now\");\n      const imgUri = (prefillDrink as any).imageUri;\n      if (imgUri) {\n        setSelectedImage(imgUri);\n      } else if (prefillDrink.category) {\n        setSelectedImage(`category:${prefillDrink.category}`);\n      }\n    }\n  }, [editEntry, prefillDrink, editCustomDrink, visible]);\n\n  const translateY = useSharedValue(MODAL_HEIGHT);\n  const startY = useSharedValue(0);\n\n  const totalCaffeine = useMemo(() => {\n    if (prefillDrink && selectedUnit === \"ml\") {\n      return (prefillDrink.caffeinePer100ml / 100) * quantity;\n    }\n    const mg = parseInt(caffeineMg) || 0;\n    return mg * quantity;\n  }, [caffeineMg, quantity, selectedUnit, prefillDrink]);\n\n  const formatCaffeine = (value: number) => value.toFixed(3).replace(/\\.?0+$/, '') || '0';\n\n  const caffeineEvents: CaffeineEvent[] = useMemo(() => {\n    const filteredEntries = isEditMode && editEntry \n      ? entries.filter((e) => e.id !== editEntry.id)\n      : entries;\n    return filteredEntries.map((entry) => ({\n      id: entry.id,\n      name: entry.name,\n      mg: entry.caffeineAmount,\n      timestampISO: new Date(entry.timestamp).toISOString(),\n    }));\n  }, [entries, isEditMode, editEntry]);\n\n  const caffeineLimitStatus = useMemo(() => {\n    if (!totalCaffeine || totalCaffeine <= 0) return \"safe\" as const;\n    const peakMg = getPeakCaffeineWithNewEntry(\n      caffeineEvents,\n      totalCaffeine,\n      startTime.getTime(),\n      HALF_LIFE_HOURS\n    );\n    return getCaffeineLimitStatus(peakMg, profile.optimalCaffeine);\n  }, [caffeineEvents, totalCaffeine, startTime, profile.optimalCaffeine]);\n\n  const sleepDateLabel = useMemo(() => {\n    const [hours, minutes] = (profile.sleepTime || \"23:00\").split(\":\").map(Number);\n    const sleepDate = new Date(startTime);\n    sleepDate.setHours(hours, minutes, 0, 0);\n    if (sleepDate.getTime() <= startTime.getTime()) {\n      sleepDate.setDate(sleepDate.getDate() + 1);\n    }\n    return sleepDate.toLocaleDateString(\"en-US\", { month: \"short\", day: \"numeric\" });\n  }, [startTime, profile.sleepTime]);\n\n  const sleepImpactStatus = useMemo(() => {\n    if (!totalCaffeine || totalCaffeine <= 0) return \"safe\" as const;\n    const todayStart = new Date();\n    todayStart.setHours(0, 0, 0, 0);\n    if (startTime.getTime() < todayStart.getTime()) return \"safe\" as const;\n    const sleepTimeMs = parseBedtimeToMs(profile.sleepTime || \"23:00\", startTime);\n    const maxCaffeineInSleepWindow = getMaxCaffeineInSleepWindow(\n      caffeineEvents,\n      totalCaffeine,\n      startTime.getTime(),\n      sleepTimeMs,\n      HALF_LIFE_HOURS\n    );\n    return getSleepImpactStatus(maxCaffeineInSleepWindow);\n  }, [caffeineEvents, totalCaffeine, startTime, profile.sleepTime]);\n\n  const resetState = () => {\n    setDrinkName(\"\");\n    setQuantity(1);\n    setSelectedUnit(\"cup\");\n    setCaffeineMg(\"10\");\n    setSelectedImage(null);\n    setStartTime(new Date());\n    setStartTimeLabel(\"now\");\n  };\n\n  const handleSelectImage = (imageUri: string) => {\n    setSelectedImage(imageUri);\n  };\n\n  const handleSelectStartTime = (date: Date, label: string) => {\n    setStartTime(date);\n    setStartTimeLabel(label);\n  };\n\n  useEffect(() => {\n    if (visible) {\n      translateY.value = MODAL_HEIGHT;\n      translateY.value = withSpring(0);\n    } else {\n      translateY.value = MODAL_HEIGHT;\n    }\n  }, [visible, translateY]);\n\n  const closeModal = () => {\n    translateY.value = withTiming(MODAL_HEIGHT, { duration: 200 }, () => {\n      runOnJS(resetState)();\n      runOnJS(onClose)();\n    });\n  };\n\n  const panGesture = Gesture.Pan()\n  .simultaneousWithExternalGesture(Gesture.Native())\n  .onStart(() => {\n    startY.value = translateY.value;\n  })\n  .onUpdate((event) => {\n    const nextY = Math.max(0, startY.value + event.translationY);\n    translateY.value = nextY;\n  })\n  .onEnd((event) => {\n    const shouldClose =\n      translateY.value > MODAL_HEIGHT * 0.35 ||\n      event.velocityY > 800;\n\n    if (shouldClose) {\n      translateY.value = withTiming(MODAL_HEIGHT, { duration: 200 }, () => {\n        runOnJS(resetState)();\n        runOnJS(onClose)();\n      });\n    } else {\n      translateY.value = withSpring(0, { damping: 16, stiffness: 200 });\n    }\n  });\n\n\n  const sheetStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: translateY.value }],\n  }));\n\n  const handleAdd = () => {\n    if (drinkName.trim() && totalCaffeine > 0) {\n      if (isEditMode && editEntry) {\n        updateEntry(editEntry.id, {\n          name: drinkName.trim(),\n          caffeineAmount: totalCaffeine,\n          timestamp: startTime,\n        });\n        closeModal();\n        onAdd?.();\n      } else if (isEditingCustomDrink && editCustomDrink) {\n        updateCustomDrink(editCustomDrink.id, {\n          name: drinkName.trim(),\n          caffeinePer100ml: parseInt(caffeineMg) || 0,\n          sizes: [{ name: selectedUnit, ml: 100 }],\n          imageUri: selectedImage || undefined,\n        });\n        onSaveCustomDrink?.();\n      } else if (prefillDrink?.id && !prefillDrink.id.startsWith('custom-')) {\n        addEntry(prefillDrink as any, prefillDrink.defaultServingMl * quantity, undefined, false, startTime);\n        closeModal();\n        onAdd?.();\n      } else {\n        const savedDrink = addCustomDrink({\n          name: drinkName.trim(),\n          category: \"custom\" as const,\n          caffeinePer100ml: (parseInt(caffeineMg) || 0),\n          defaultServingMl: 100,\n          icon: \"coffee\",\n          sizes: [{ name: selectedUnit, ml: 100 }],\n          imageUri: selectedImage || undefined,\n        });\n        addEntry(savedDrink, 100 * quantity, undefined, false, startTime);\n        closeModal();\n        onAdd?.();\n      }\n    }\n  };\n\n  const incrementQuantity = () => setQuantity((q) => Math.min(q + 1, 10));\n  const decrementQuantity = () => setQuantity((q) => Math.max(q - 1, 1));\n\n  if (!visible) return null;\n\n  return (\n    <Modal\n      visible={visible}\n      transparent\n      statusBarTranslucent\n      animationType=\"fade\"\n      onRequestClose={closeModal}\n    >\n      <GestureHandlerRootView style={{ flex: 1 }}>\n\n      <View style={styles.overlay}>\n        <Pressable style={styles.backdrop} onPress={closeModal} />\n\n        <GestureDetector gesture={panGesture}>\n          <Animated.View\n            style={[\n              styles.modalContent,\n              sheetStyle,\n              {\n                backgroundColor: theme.backgroundRoot,\n                paddingBottom: insets.bottom + Spacing.lg,\n                maxHeight: MODAL_HEIGHT,\n              },\n            ]}\n          >\n            <View style={styles.handleContainer}>\n              <View style={[styles.handle, { backgroundColor: Colors.light.accent }]} />\n            </View>\n\n            <ScrollView\n              style={styles.scrollContent}\n              showsVerticalScrollIndicator={false}\n              keyboardShouldPersistTaps=\"handled\"\n              bounces={false}\n              overScrollMode=\"never\"\n              scrollEventThrottle={16}\n            >\n              <View style={styles.topSection}>\n                <Pressable \n                  onPress={() => setShowImagePicker(true)}\n                  style={[styles.chooseIconBox, { backgroundColor: theme.backgroundSecondary }]}\n                >\n                  {selectedImage ? (\n                    selectedImage.startsWith(\"category:\") ? (\n                      <Image \n                        source={getCategoryImageSource(selectedImage.replace(\"category:\", \"\"))} \n                        style={styles.selectedImage} \n                        resizeMode=\"cover\" \n                      />\n                    ) : selectedImage.startsWith(\"preset:\") ? (\n                      (() => {\n                        const preset = PRESET_IMAGES.find(p => p.id === selectedImage.replace(\"preset:\", \"\"));\n                        return preset ? (\n                          <Image source={preset.image} style={styles.selectedImage} resizeMode=\"cover\" />\n                        ) : (\n                          <Feather name=\"coffee\" size={32} color={Colors.light.accent} />\n                        );\n                      })()\n                    ) : (\n                      <Image source={{ uri: selectedImage }} style={styles.selectedImage} />\n                    )\n                  ) : (\n                    <>\n                      <Feather name=\"plus\" size={28} color={theme.textMuted} />\n                      <ThemedText type=\"caption\" muted>Choose</ThemedText>\n                    </>\n                  )}\n                </Pressable>\n\n                <View style={styles.nameInputSection}>\n                  <ThemedText type=\"caption\" muted>\n                    You are drinking {quantity} {selectedUnit} of\n                  </ThemedText>\n                  <TextInput\n                    style={[styles.nameInput, { color: theme.text, borderBottomColor: theme.divider }]}\n                    placeholder=\"Enter name\"\n                    placeholderTextColor={theme.textMuted}\n                    value={drinkName}\n                    onChangeText={setDrinkName}\n                  />\n                </View>\n              </View>\n\n              <View style={[styles.divider, { backgroundColor: theme.divider }]} />\n\n              <View style={styles.quantityRow}>\n                <ThemedText type=\"h1\" style={styles.quantityNumber}>{quantity}</ThemedText>\n                <View style={styles.quantityButtons}>\n                  <Pressable\n                    onPress={incrementQuantity}\n                    style={[styles.quantityBtn, { borderColor: theme.textMuted }]}\n                  >\n                    <Feather name=\"plus\" size={20} color={theme.textMuted} />\n                  </Pressable>\n                  <Pressable\n                    onPress={decrementQuantity}\n                    style={[styles.quantityBtn, { borderColor: theme.textMuted }]}\n                  >\n                    <Feather name=\"minus\" size={20} color={theme.textMuted} />\n                  </Pressable>\n                </View>\n              </View>\n\n              <View style={[styles.divider, { backgroundColor: theme.divider }]} />\n\n              {prefillDrink ? (\n                <View style={styles.prefillUnitSection}>\n                  <Pressable\n                    onPress={() => setSelectedUnit(getUnitForDrink(prefillDrink.name, prefillDrink.category, prefillDrink.sizes))}\n                    style={styles.radioRow}\n                  >\n                    <View style={[styles.radioCircle, (selectedUnit !== \"ml\" || prefillDrink.category === \"custom\") && styles.radioCircleActive]}>\n                      {(selectedUnit !== \"ml\" || prefillDrink.category === \"custom\") && <View style={styles.radioInner} />}\n                    </View>\n                    <ThemedText type=\"body\" style={{ flex: 1 }}>\n                      {getUnitForDrink(prefillDrink.name, prefillDrink.category, prefillDrink.sizes)}\n                    </ThemedText>\n                    <View style={styles.caffeineInputWrapper}>\n                      <ThemedText type=\"body\" style={{ color: theme.text }}>\n                        {(parseInt(caffeineMg) || 0) * quantity}\n                      </ThemedText>\n                      <ThemedText type=\"body\" muted> mg</ThemedText>\n                    </View>\n                  </Pressable>\n                  {prefillDrink.category !== \"custom\" && (\n                    <Pressable\n                      onPress={() => setSelectedUnit(\"ml\")}\n                      style={styles.radioRow}\n                    >\n                      <View style={[styles.radioCircle, selectedUnit === \"ml\" && styles.radioCircleActive]}>\n                        {selectedUnit === \"ml\" && <View style={styles.radioInner} />}\n                      </View>\n                      <ThemedText type=\"body\" style={{ flex: 1 }}>ml</ThemedText>\n                      <View style={styles.caffeineInputWrapper}>\n                        <ThemedText type=\"body\" style={{ color: theme.text }}>\n                          {formatCaffeine((prefillDrink.caffeinePer100ml / 100) * quantity)}\n                        </ThemedText>\n                        <ThemedText type=\"body\" muted> mg</ThemedText>\n                      </View>\n                    </Pressable>\n                  )}\n                </View>\n              ) : (\n                <View style={styles.unitCaffeineRow}>\n                  <View style={styles.unitSelectorContainer}>\n                    <Pressable\n                      onPress={() => {\n                        setShowUnitPicker(!showUnitPicker);\n                      }}\n                      style={styles.unitSelector}\n                    >\n                      <Feather name=\"chevron-down\" size={16} color={theme.textMuted} />\n                      <ThemedText type=\"body\">{selectedUnit}</ThemedText>\n                    </Pressable>\n\n                  </View>\n\n                  <View style={styles.caffeineInputWrapper}>\n                    <TextInput\n                      style={[styles.caffeineInput, { color: theme.text }]}\n                      value={caffeineMg}\n                      onChangeText={setCaffeineMg}\n                      keyboardType=\"numeric\"\n                      maxLength={4}\n                    />\n                    <ThemedText type=\"body\" muted> mg</ThemedText>\n                  </View>\n                </View>\n              )}\n\n              <View style={[styles.divider, { backgroundColor: theme.divider }]} />\n\n              <View style={styles.timeRow}>\n                <ThemedText type=\"body\">Finished Drinking:</ThemedText>\n                <Pressable \n                  onPress={() => setShowStartTimePicker(true)}\n                  style={[styles.timeChip, { borderColor: Colors.light.accent }]}\n                >\n                  <Feather name=\"calendar\" size={14} color={Colors.light.accent} />\n                  <ThemedText type=\"small\" style={{ color: Colors.light.accent }}>{startTimeLabel}</ThemedText>\n                </Pressable>\n              </View>\n\n              <View style={[styles.divider, { backgroundColor: theme.divider }]} />\n\n              <View style={styles.indicatorsRow}>\n                <View style={styles.indicatorWithText}>\n                  <GlowIndicator\n                    icon=\"coffee\"\n                    label=\"Caffeine Limit\"\n                    status={caffeineLimitStatus}\n                  />\n                  <View style={[styles.indicatorTextCard, { backgroundColor: theme.backgroundSecondary }]}>\n                    <ThemedText type=\"caption\" muted style={styles.indicatorExplanation} numberOfLines={3}>\n                      {caffeineLimitStatus === \"safe\"\n                        ? \"Supports alertness and focus.\"\n                        : caffeineLimitStatus === \"warning\"\n                        ? \"May cause mild restlessness or less stable focus.\"\n                        : \"Side effects like anxiety, jitters, or energy crashes become more likely.\"}\n                    </ThemedText>\n                  </View>\n                </View>\n                <View style={styles.indicatorWithText}>\n                  <GlowIndicator\n                    icon=\"moon\"\n                    label=\"Sleep Impact\"\n                    status={sleepImpactStatus}\n                  />\n                  <ThemedText type=\"caption\" style={styles.sleepDateLabel}>{sleepDateLabel}</ThemedText>\n                  <View style={[styles.indicatorTextCard, { backgroundColor: theme.backgroundSecondary }]}>\n                    <ThemedText type=\"caption\" muted style={styles.indicatorExplanation} numberOfLines={3}>\n                      {sleepImpactStatus === \"safe\"\n                        ? \"Unlikely to disrupt sleep.\"\n                        : sleepImpactStatus === \"warning\"\n                        ? \"May disrupt sleep for some people.\"\n                        : \"More likely to disrupt sleep.\"}\n                    </ThemedText>\n                  </View>\n                </View>\n              </View>\n\n              <Pressable\n                onPress={handleAdd}\n                style={[\n                  styles.addButton,\n                  { opacity: drinkName.trim() && totalCaffeine > 0 ? 1 : 0.5 },\n                ]}\n                disabled={!drinkName.trim() || totalCaffeine <= 0}\n              >\n                <ThemedText type=\"body\" style={styles.addButtonText}>{isEditMode || isEditingCustomDrink ? \"Save\" : \"Add\"}</ThemedText>\n              </Pressable>\n            </ScrollView>\n          </Animated.View>\n        </GestureDetector>\n\n        {showUnitPicker && (\n          <View style={styles.unitPickerOverlay}>\n            <Pressable \n              style={StyleSheet.absoluteFillObject} \n              onPress={() => setShowUnitPicker(false)} \n            />\n            <View style={[styles.unitPickerDropdown, { backgroundColor: theme.backgroundSecondary }]}>\n              <ScrollView style={{ maxHeight: 250 }} showsVerticalScrollIndicator={true}>\n                {UNITS.map((unit) => (\n                  <Pressable\n                    key={unit}\n                    onPress={() => {\n                      setSelectedUnit(unit);\n                      setShowUnitPicker(false);\n                    }}\n                    style={[\n                      styles.pickerItem,\n                      selectedUnit === unit && { backgroundColor: `${Colors.light.accent}20` },\n                    ]}\n                  >\n                    <ThemedText type=\"body\">{unit}</ThemedText>\n                  </Pressable>\n                ))}\n              </ScrollView>\n            </View>\n          </View>\n        )}\n      </View>\n\n      <ImagePickerModal\n        visible={showImagePicker}\n        onClose={() => setShowImagePicker(false)}\n        onSelectImage={handleSelectImage}\n      />\n\n      <TimePickerModal\n        visible={showStartTimePicker}\n        onClose={() => setShowStartTimePicker(false)}\n        onSelectTime={handleSelectStartTime}\n        initialDate={startTime}\n      />\n        </GestureHandlerRootView>\n    </Modal>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n  },\n  backdrop: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: \"rgba(0,0,0,0.35)\",\n  },\n  modalContent: {\n    position: \"absolute\",\n    bottom: 0,\n    left: 0,\n    right: 0,\n    borderTopLeftRadius: BorderRadius.xl,\n    borderTopRightRadius: BorderRadius.xl,\n  },\n  handleContainer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing.md,\n  },\n  handle: {\n    width: 40,\n    height: 4,\n    borderRadius: 2,\n  },\n  scrollContent: {\n    paddingHorizontal: Spacing.xl,\n  },\n  topSection: {\n    flexDirection: \"row\",\n    alignItems: \"flex-start\",\n    gap: Spacing.lg,\n    marginBottom: Spacing.lg,\n  },\n  chooseIconBox: {\n    width: 72,\n    height: 72,\n    borderRadius: BorderRadius.md,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    overflow: \"hidden\",\n  },\n  selectedImage: {\n    width: \"100%\",\n    height: \"100%\",\n    borderRadius: BorderRadius.md,\n  },\n  selectedPresetIcon: {\n    width: \"100%\",\n    height: \"100%\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: 4,\n  },\n  nameInputSection: {\n    flex: 1,\n    paddingTop: Spacing.xs,\n  },\n  nameInput: {\n    fontSize: 20,\n    fontWeight: \"600\",\n    paddingVertical: Spacing.sm,\n    borderBottomWidth: 1,\n  },\n  divider: {\n    height: 1,\n    marginVertical: Spacing.md,\n  },\n  quantityRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingVertical: Spacing.sm,\n  },\n  quantityNumber: {\n    fontSize: 48,\n    fontWeight: \"300\",\n  },\n  quantityButtons: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n  },\n  quantityBtn: {\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    borderWidth: 1.5,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  unitCaffeineRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingVertical: Spacing.sm,\n    zIndex: 10,\n  },\n  unitSelectorContainer: {\n    position: \"relative\",\n    zIndex: 10,\n  },\n  unitSelector: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.xs,\n  },\n  prefillUnitSection: {\n    gap: Spacing.sm,\n  },\n  radioRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    paddingVertical: Spacing.xs,\n  },\n  radioCircle: {\n    width: 20,\n    height: 20,\n    borderRadius: 10,\n    borderWidth: 2,\n    borderColor: \"#ccc\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  radioCircleActive: {\n    borderColor: Colors.light.accent,\n  },\n  radioInner: {\n    width: 10,\n    height: 10,\n    borderRadius: 5,\n    backgroundColor: Colors.light.accent,\n  },\n  unitPickerOverlay: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 100,\n    justifyContent: \"flex-end\",\n    paddingBottom: 280,\n    paddingHorizontal: Spacing.xl,\n  },\n  unitPickerDropdown: {\n    width: 120,\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.25,\n    shadowRadius: 8,\n    elevation: 10,\n  },\n  caffeineInputWrapper: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n  },\n  caffeineInput: {\n    fontSize: 18,\n    fontWeight: \"600\",\n    minWidth: 50,\n    textAlign: \"right\",\n  },\n  pickerDropdown: {\n    borderRadius: BorderRadius.sm,\n    marginTop: Spacing.xs,\n    overflow: \"hidden\",\n  },\n  pickerItem: {\n    paddingVertical: Spacing.sm,\n    paddingHorizontal: Spacing.md,\n  },\n  timeRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingVertical: Spacing.sm,\n  },\n  timeChip: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.xs,\n    paddingVertical: Spacing.xs,\n    paddingHorizontal: Spacing.md,\n    borderRadius: BorderRadius.lg,\n    borderWidth: 1,\n  },\n  indicatorsRow: {\n    flexDirection: \"row\",\n    justifyContent: \"space-around\",\n    alignItems: \"flex-start\",\n    paddingVertical: Spacing.md,\n    marginBottom: Spacing.md,\n    gap: Spacing.md,\n  },\n  indicatorWithText: {\n    flex: 1,\n    alignItems: \"center\",\n    gap: Spacing.xs,\n    borderWidth: 1,\n    borderColor: \"rgba(0,0,0,0.1)\",\n    borderRadius: BorderRadius.md,\n    padding: Spacing.sm,\n  },\n  indicatorTextCard: {\n    borderRadius: BorderRadius.sm,\n    paddingVertical: Spacing.xs,\n    paddingHorizontal: Spacing.sm,\n    width: \"100%\",\n    minHeight: 56,\n    justifyContent: \"center\",\n  },\n  sleepDateLabel: {\n    position: \"absolute\",\n    top: Spacing.xs,\n    right: Spacing.sm,\n    color: Colors.light.accent,\n    fontWeight: \"500\",\n  },\n  indicatorExplanation: {\n    textAlign: \"center\",\n    lineHeight: 16,\n  },\n  addButton: {\n    backgroundColor: \"#4CAF50\",\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.md,\n    alignItems: \"center\",\n    marginBottom: Spacing.lg,\n  },\n  addButtonText: {\n    color: \"#FFFFFF\",\n    fontWeight: \"700\",\n    fontSize: 16,\n  },\n});\n","path":null,"size_bytes":28750,"size_tokens":null},"components/StackedEntriesModal.tsx":{"content":"import React from \"react\";\nimport {\n  Modal,\n  View,\n  StyleSheet,\n  Pressable,\n  Text,\n  Image,\n  ScrollView,\n  Dimensions,\n} from \"react-native\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { CaffeineEvent } from \"@/utils/graphUtils\";\n\nconst SCREEN_WIDTH = Dimensions.get(\"window\").width;\nconst SCREEN_HEIGHT = Dimensions.get(\"window\").height;\nconst DEFAULT_MODAL_HEIGHT = SCREEN_HEIGHT * 0.28;\nconst MODAL_WIDTH = SCREEN_WIDTH * 0.35;\n\nconst CATEGORY_IMAGES: Record<string, any> = {\n  coffee: require(\"@/assets/CaffeineSourceImages/coffee.png\"),\n  tea: require(\"@/assets/CaffeineSourceImages/tea.jpg\"),\n  energy: require(\"@/assets/CaffeineSourceImages/energy.png\"),\n  soda: require(\"@/assets/CaffeineSourceImages/soda.png\"),\n  chocolate: require(\"@/assets/CaffeineSourceImages/chocolate.png\"),\n};\n\nconst resolveImageSource = (imageUri?: string): any => {\n  if (!imageUri) return null;\n  if (imageUri.startsWith(\"preset:\")) {\n    const { PRESET_IMAGES } = require(\"@/components/ImagePickerModal\");\n    const preset = PRESET_IMAGES.find((p: any) => p.id === imageUri.replace(\"preset:\", \"\"));\n    return preset?.image;\n  }\n  return { uri: imageUri };\n};\n\ninterface StackedEntriesModalProps {\n  visible: boolean;\n  events: CaffeineEvent[];\n  position: { x: number; y: number };\n  onClose: () => void;\n  onSelectEvent: (event: CaffeineEvent) => void;\n}\n\nfunction formatTime(timestampISO: string): string {\n  const date = new Date(timestampISO);\n  return date.toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  });\n}\n\nexport function StackedEntriesModal({\n  visible,\n  events,\n  position,\n  onClose,\n  onSelectEvent,\n}: StackedEntriesModalProps) {\n  const { theme } = useTheme();\n  const [modalHeight, setModalHeight] = React.useState(0);\n  const [modalWidth, setModalWidth] = React.useState(0);\n\n  const effectiveModalHeight = modalHeight || DEFAULT_MODAL_HEIGHT;\n  const effectiveModalWidth = modalWidth || MODAL_WIDTH;\n\n  const modalLeft = Math.min(\n    Math.max(position.x + 10, 10),\n    SCREEN_WIDTH - effectiveModalWidth - 10\n  );\n  const xAxisLabelHeight = SCREEN_HEIGHT * 0.04;\n  const modalTop = Math.min(\n    Math.max(position.y - 40, 60),\n    SCREEN_HEIGHT - effectiveModalHeight - xAxisLabelHeight\n  );\n\n  if (!visible || events.length === 0) return null;\n\n  return (\n    <Modal\n      visible={visible}\n      transparent\n      animationType=\"fade\"\n      onRequestClose={onClose}\n    >\n      <Pressable style={[styles.overlay, { backgroundColor: \"transparent\" }]} onPress={onClose}>\n        <View\n          style={[\n            styles.modalContainer,\n            {\n              backgroundColor: theme.bg,\n              left: modalLeft,\n              top: modalTop,\n              shadowColor: \"#000\",\n              maxHeight: effectiveModalHeight,\n            },\n          ]}\n          onLayout={(e) => {\n            setModalHeight(e.nativeEvent.layout.height);\n            setModalWidth(e.nativeEvent.layout.width);\n          }}\n        >\n          <ScrollView\n            style={[styles.scrollView, { maxHeight: effectiveModalHeight }]}\n            showsVerticalScrollIndicator={false}\n          >\n            {events.map((event, index) => {\n              const categoryImage = CATEGORY_IMAGES[event.category || \"coffee\"];\n              const resolvedImage = resolveImageSource(event.imageUri) || categoryImage;\n\n              return (\n                <Pressable\n                  key={event.id || index}\n                  style={({ pressed }) => [\n                    styles.entryRow,\n                    { backgroundColor: pressed ? theme.backgroundTertiary : \"transparent\" },\n                    index < events.length - 1 && {\n                      borderBottomWidth: StyleSheet.hairlineWidth,\n                      borderBottomColor: theme.mutedGrey + \"30\",\n                    },\n                  ]}\n                  onPress={() => {\n                    onSelectEvent(event);\n                  }}\n                >\n                  <View style={[styles.imageContainer, { backgroundColor: theme.backgroundSecondary }]}>\n                    {resolvedImage ? (\n                      <Image source={resolvedImage} style={styles.entryImage} />\n                    ) : (\n                      <Text style={styles.emoji}></Text>\n                    )}\n                  </View>\n                  <View style={styles.textContainer}>\n                    <Text style={[styles.entryName, { color: theme.darkBrown }]} numberOfLines={1}>\n                      {event.name}\n                    </Text>\n                    <View style={styles.timeAndMgRow}>\n                      <Text style={[styles.entryTime, { color: theme.mutedGrey }]}>\n                        {formatTime(event.timestampISO)}\n                      </Text>\n                      <Text style={[styles.entryMg, { color: theme.accentGold }]}>\n                        {event.mg} mg\n                      </Text>\n                    </View>\n                  </View>\n                </Pressable>\n              );\n            })}\n          </ScrollView>\n        </View>\n      </Pressable>\n    </Modal>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0, 0, 0, 0.3)\",\n  },\n  modalContainer: {\n    position: \"absolute\",\n    width: MODAL_WIDTH,\n    borderRadius: 12,\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.2,\n    shadowRadius: 8,\n    elevation: 8,\n    overflow: \"hidden\",\n  },\n  scrollView: {\n    flex: 1,\n  },\n  entryRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingVertical: SCREEN_HEIGHT * 0.003,\n    paddingHorizontal: SCREEN_WIDTH * 0.01,\n  },\n  imageContainer: {\n    width: SCREEN_WIDTH * 0.045,\n    height: SCREEN_WIDTH * 0.045,\n    borderRadius: SCREEN_WIDTH * 0.0225,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    overflow: \"hidden\",\n  },\n  entryImage: {\n    width: SCREEN_WIDTH * 0.045,\n    height: SCREEN_WIDTH * 0.045,\n    borderRadius: SCREEN_WIDTH * 0.0225,\n  },\n  emoji: {\n    fontSize: SCREEN_WIDTH * 0.022,\n  },\n  textContainer: {\n    flex: 1,\n    marginLeft: SCREEN_WIDTH * 0.02,\n  },\n  entryName: {\n    fontSize: 10,\n    fontWeight: \"600\",\n  },\n  timeAndMgRow: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    marginTop: 2,\n    gap: 4,\n  },\n  entryTime: {\n    fontSize: 8,\n    flex: 1,\n  },\n  entryMg: {\n    fontSize: 8,\n    fontWeight: \"600\",\n  },\n});\n\nexport default StackedEntriesModal;\n","path":null,"size_bytes":6482,"size_tokens":null},"navigation/HomeStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport HomeScreen from \"@/screens/HomeScreen\";\nimport StatisticsScreen from \"@/screens/StatisticsScreen\";\nimport DrinkDatabaseScreen from \"@/screens/DrinkDatabaseScreen\";\n\nexport type HomeStackParamList = {\n  Home: undefined;\n  Statistics: undefined;\n  DrinkDatabase: undefined;\n};\n\nconst Stack = createNativeStackNavigator<HomeStackParamList>();\n\nexport default function HomeStackNavigator() {\n  return (\n    <Stack.Navigator\n      screenOptions={{\n        headerShown: false,\n      }}\n    >\n      <Stack.Screen name=\"Home\" component={HomeScreen} />\n      <Stack.Screen name=\"Statistics\" component={StatisticsScreen} />\n      <Stack.Screen name=\"DrinkDatabase\" component={DrinkDatabaseScreen} />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":831,"size_tokens":null},"screens/OnboardingScreen.tsx":{"content":"import React, { useState, useCallback } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Dimensions,\n  Pressable,\n  Platform,\n  TextInput,\n  Modal,\n  ScrollView,\n} from \"react-native\";\nimport { TimePickerModal } from \"react-native-paper-dates\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  withTiming,\n  interpolate,\n  Extrapolation,\n  runOnJS,\n} from \"react-native-reanimated\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\nimport {\n  useCaffeineStore,\n  calculateOptimalCaffeine,\n  AgeRange,\n  CaffeineSensitivity,\n  AlcoholIntake,\n  Medication,\n} from \"@/store/caffeineStore\";\n\nconst { width: SCREEN_WIDTH } = Dimensions.get(\"window\");\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\ntype OnboardingStep =\n  | \"name\"\n  | \"age\"\n  | \"weight\"\n  | \"sensitivity\"\n  | \"alcohol\"\n  | \"medications\"\n  | \"schedule\"\n  | \"summary\";\n\nconst STEPS: OnboardingStep[] = [\n  \"name\",\n  \"age\",\n  \"weight\",\n  \"sensitivity\",\n  \"alcohol\",\n  \"medications\",\n  \"schedule\",\n];\n\ninterface OnboardingData {\n  name?: string;\n  ageRange?: AgeRange;\n  weight?: number;\n  caffeineSensitivity?: CaffeineSensitivity;\n  alcoholIntake?: AlcoholIntake;\n  medications?: Medication[];\n  wakeTime?: string;\n  sleepTime?: string;\n}\n\nexport default function OnboardingScreen() {\n  const { theme } = useTheme();\n  const insets = useSafeAreaInsets();\n  const { updateProfile } = useCaffeineStore();\n\n  const [currentStep, setCurrentStep] = useState(0);\n  const [data, setData] = useState<OnboardingData>({});\n  const slideAnim = useSharedValue(0);\n\n  const animateToStep = useCallback(\n    (nextStep: number) => {\n      slideAnim.value = withTiming(nextStep, { duration: 300 }, () => {\n        runOnJS(setCurrentStep)(nextStep);\n      });\n    },\n    [slideAnim]\n  );\n\n  const handleNext = useCallback(() => {\n    if (currentStep < STEPS.length - 1) {\n      animateToStep(currentStep + 1);\n    }\n  }, [currentStep, animateToStep]);\n\n  const handleBack = useCallback(() => {\n    if (currentStep > 0) {\n      animateToStep(currentStep - 1);\n    }\n  }, [currentStep, animateToStep]);\n\n  const handleSkip = useCallback(() => {\n    handleNext();\n  }, [handleNext]);\n\n  const handleFinish = useCallback((wakeTimeOverride?: string, sleepTimeOverride?: string) => {\n    const calculationInputs = {\n      ageRange: data.ageRange,\n      weight: data.weight,\n      caffeineSensitivity: data.caffeineSensitivity,\n      alcoholIntake: data.alcoholIntake,\n      medications: data.medications,\n    };\n\n    const { optimal, safe } = calculateOptimalCaffeine(calculationInputs);\n\n    updateProfile({\n      name: data.name || \"\",\n      ageRange: data.ageRange,\n      weight: data.weight,\n      isPregnant: false,\n      hasHeartCondition: false,\n      caffeineSensitivity: data.caffeineSensitivity,\n      alcoholIntake: data.alcoholIntake,\n      medications: data.medications,\n      wakeTime: wakeTimeOverride || data.wakeTime || \"07:00\",\n      sleepTime: sleepTimeOverride || data.sleepTime || \"23:00\",\n      optimalCaffeine: optimal,\n      safeCaffeine: safe,\n      dailyLimit: optimal,\n      hasCompletedOnboarding: true,\n    });\n  }, [data, updateProfile]);\n\n  const updateData = useCallback(\n    <K extends keyof OnboardingData>(key: K, value: OnboardingData[K]) => {\n      setData((prev) => ({ ...prev, [key]: value }));\n    },\n    []\n  );\n\n  const progressWidth = ((currentStep + 1) / STEPS.length) * 100;\n\n  const renderStep = () => {\n    switch (STEPS[currentStep]) {\n      case \"name\":\n        return (\n          <NameStep\n            value={data.name}\n            onChange={(v) => updateData(\"name\", v)}\n            onNext={handleNext}\n            onSkip={handleSkip}\n          />\n        );\n      case \"age\":\n        return (\n          <AgeStep\n            value={data.ageRange}\n            onChange={(v) => updateData(\"ageRange\", v)}\n            onNext={handleNext}\n            onSkip={handleSkip}\n          />\n        );\n      case \"weight\":\n        return (\n          <WeightStep\n            value={data.weight}\n            onChange={(v) => updateData(\"weight\", v)}\n            onNext={handleNext}\n            onSkip={handleSkip}\n          />\n        );\n      case \"sensitivity\":\n        return (\n          <SensitivityStep\n            value={data.caffeineSensitivity}\n            onChange={(v) => updateData(\"caffeineSensitivity\", v)}\n            onNext={handleNext}\n            onSkip={handleSkip}\n          />\n        );\n      case \"alcohol\":\n        return (\n          <AlcoholStep\n            value={data.alcoholIntake}\n            onChange={(v) => updateData(\"alcoholIntake\", v)}\n            onNext={handleNext}\n            onSkip={handleSkip}\n          />\n        );\n      case \"medications\":\n        return (\n          <MedicationsStep\n            value={data.medications}\n            onChange={(v) => updateData(\"medications\", v)}\n            onNext={handleNext}\n            onSkip={handleSkip}\n          />\n        );\n      case \"schedule\":\n        return (\n          <ScheduleStep\n            wakeTime={data.wakeTime}\n            sleepTime={data.sleepTime}\n            onWakeTimeChange={(v) => updateData(\"wakeTime\", v)}\n            onSleepTimeChange={(v) => updateData(\"sleepTime\", v)}\n            onFinish={handleFinish}\n            data={data}\n          />\n        );\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <View style={[styles.container, { backgroundColor: theme.backgroundRoot }]}>\n      <View\n        style={[\n          styles.header,\n          { paddingTop: insets.top + Spacing.md },\n        ]}\n      >\n        {currentStep > 0 ? (\n          <Pressable onPress={handleBack} style={styles.backButton}>\n            <Feather name=\"arrow-left\" size={24} color={theme.text} />\n          </Pressable>\n        ) : (\n          <View style={styles.backButton} />\n        )}\n\n        <View style={styles.progressContainer}>\n          <View\n            style={[\n              styles.progressBar,\n              { backgroundColor: theme.backgroundSecondary },\n            ]}\n          >\n            <Animated.View\n              style={[\n                styles.progressFill,\n                {\n                  backgroundColor: Colors.light.accent,\n                  width: `${progressWidth}%`,\n                },\n              ]}\n            />\n          </View>\n        </View>\n\n        <View style={styles.backButton} />\n      </View>\n\n      <View style={styles.content}>{renderStep()}</View>\n    </View>\n  );\n}\n\ninterface StepProps<T> {\n  value: T | undefined;\n  onChange: (value: T) => void;\n  onNext: () => void;\n  onSkip: () => void;\n}\n\nfunction NameStep({ value, onChange, onNext, onSkip }: StepProps<string>) {\n  const { theme } = useTheme();\n  const [localValue, setLocalValue] = useState(value || \"\");\n\n  const handleConfirm = () => {\n    onChange(localValue);\n    onNext();\n  };\n\n  return (\n    <StepContainer icon=\"user\" title=\"What's your name?\" onSkip={onSkip}>\n      <View style={styles.inputContainer}>\n        <ThemedText type=\"body\" muted style={styles.inputLabel}>\n          We'll use this to personalize your experience\n        </ThemedText>\n        <View\n          style={[\n            styles.textInputContainer,\n            { backgroundColor: theme.backgroundSecondary },\n          ]}\n        >\n          <Feather name=\"user\" size={20} color={theme.textMuted} />\n          <View style={styles.textInputWrapper}>\n            <TextInput\n              style={[styles.textInput, { color: theme.text }]}\n              value={localValue}\n              onChangeText={setLocalValue}\n              placeholder=\"Enter your name\"\n              placeholderTextColor={theme.textMuted}\n              autoFocus\n              returnKeyType=\"done\"\n              onSubmitEditing={handleConfirm}\n            />\n          </View>\n        </View>\n      </View>\n      <ContinueButton onPress={handleConfirm} disabled={!localValue.trim()} />\n    </StepContainer>\n  );\n}\n\nfunction AgeStep({ value, onChange, onNext, onSkip }: StepProps<AgeRange>) {\n  const handleSelect = (ageRange: AgeRange) => {\n    onChange(ageRange);\n    onNext();\n  };\n\n  const options: { key: AgeRange; label: string; description: string; icon: keyof typeof Feather.glyphMap }[] = [\n    { key: \"under_18\", label: \"Under 18\", description: \"Teen or younger\", icon: \"user\" },\n    { key: \"18_to_60\", label: \"18 to 60\", description: \"Adult\", icon: \"user\" },\n    { key: \"over_60\", label: \"Over 60\", description: \"Senior\", icon: \"user\" },\n  ];\n\n  return (\n    <StepContainer\n      icon=\"user\"\n      title=\"Your Age Range\"\n      onSkip={onSkip}\n    >\n      <View style={styles.optionsContainer}>\n        {options.map((option) => (\n          <OptionButton\n            key={option.key}\n            label={option.label}\n            icon={option.icon}\n            isSelected={value === option.key}\n            onPress={() => handleSelect(option.key)}\n          />\n        ))}\n      </View>\n    </StepContainer>\n  );\n}\n\nfunction WeightStep({ value, onChange, onNext, onSkip }: StepProps<number>) {\n  const { theme } = useTheme();\n  const [localValue, setLocalValue] = useState(value ? String(value) : \"\");\n\n  const handleConfirm = () => {\n    const weightValue = parseInt(localValue, 10);\n    if (weightValue && weightValue >= 20 && weightValue <= 300) {\n      onChange(weightValue);\n      onNext();\n    }\n  };\n\n  const handleTextChange = (text: string) => {\n    const numericText = text.replace(/[^0-9]/g, \"\");\n    setLocalValue(numericText);\n  };\n\n  const isValid = () => {\n    const weightValue = parseInt(localValue, 10);\n    return weightValue && weightValue >= 20 && weightValue <= 300;\n  };\n\n  return (\n    <StepContainer\n      icon=\"activity\"\n      title=\"Your Weight\"\n      onSkip={onSkip}\n    >\n      <View style={styles.inputContainer}>\n        <ThemedText type=\"body\" muted style={styles.inputLabel}>\n          Enter your weight in kilograms\n        </ThemedText>\n        <View\n          style={[\n            styles.textInputContainer,\n            { backgroundColor: theme.backgroundSecondary },\n          ]}\n        >\n          <Feather name=\"activity\" size={20} color={theme.textMuted} />\n          <View style={styles.textInputWrapper}>\n            <TextInput\n              style={[styles.textInput, { color: theme.text }]}\n              value={localValue}\n              onChangeText={handleTextChange}\n              placeholder=\"Enter weight (kg)\"\n              placeholderTextColor={theme.textMuted}\n              keyboardType=\"number-pad\"\n              autoFocus\n              returnKeyType=\"done\"\n              onSubmitEditing={handleConfirm}\n              maxLength={3}\n            />\n          </View>\n          <ThemedText type=\"body\" muted>kg</ThemedText>\n        </View>\n      </View>\n      <ContinueButton onPress={handleConfirm} disabled={!isValid()} />\n    </StepContainer>\n  );\n}\n\nfunction SensitivityStep({\n  value,\n  onChange,\n  onNext,\n  onSkip,\n}: StepProps<CaffeineSensitivity>) {\n  const handleSelect = (sensitivity: CaffeineSensitivity) => {\n    onChange(sensitivity);\n    onNext();\n  };\n\n  const options: { key: CaffeineSensitivity; label: string; icon: keyof typeof Feather.glyphMap }[] = [\n    { key: \"medium\", label: \"Normal\", icon: \"coffee\" },\n    { key: \"low\", label: \"Low\", icon: \"coffee\" },\n    { key: \"high\", label: \"High\", icon: \"alert-circle\" },\n  ];\n\n  return (\n    <StepContainer\n      icon=\"zap\"\n      title=\"Caffeine Sensitivity\"\n      onSkip={onSkip}\n    >\n      <View style={styles.optionsContainer}>\n        {options.map((option) => (\n          <OptionButton\n            key={option.key}\n            label={option.label}\n            icon={option.icon}\n            isSelected={value === option.key}\n            onPress={() => handleSelect(option.key)}\n          />\n        ))}\n      </View>\n    </StepContainer>\n  );\n}\n\nfunction AlcoholStep({\n  value,\n  onChange,\n  onNext,\n  onSkip,\n}: StepProps<AlcoholIntake>) {\n  const handleSelect = (alcoholIntake: AlcoholIntake) => {\n    onChange(alcoholIntake);\n    onNext();\n  };\n\n  const options: { key: AlcoholIntake; label: string; icon: keyof typeof Feather.glyphMap }[] = [\n    { key: \"rare\", label: \"Never\", icon: \"check-circle\" },\n    { key: \"sometimes\", label: \"Sometimes\", icon: \"clock\" },\n    { key: \"daily\", label: \"Daily\", icon: \"repeat\" },\n  ];\n\n  return (\n    <StepContainer\n      icon=\"droplet\"\n      title=\"Alcohol Intake\"\n      onSkip={onSkip}\n    >\n      <View style={styles.optionsContainer}>\n        {options.map((option) => (\n          <OptionButton\n            key={option.key}\n            label={option.label}\n            icon={option.icon}\n            isSelected={value === option.key}\n            onPress={() => handleSelect(option.key)}\n          />\n        ))}\n      </View>\n    </StepContainer>\n  );\n}\n\nfunction MedicationsStep({\n  value,\n  onChange,\n  onNext,\n  onSkip,\n}: StepProps<Medication[]>) {\n  const handleSelect = (medication: Medication) => {\n    onChange([medication]);\n    onNext();\n  };\n\n  const options: { key: Medication; label: string; icon: keyof typeof Feather.glyphMap }[] = [\n    { key: \"none\", label: \"None / Skip\", icon: \"check\" },\n    { key: \"anxiety_panic\", label: \"Anxiety / Panic issues\", icon: \"heart\" },\n    { key: \"adhd_medication\", label: \"ADHD (focus medications)\", icon: \"zap\" },\n    { key: \"insomnia_medication\", label: \"Sleep issues / Insomnia medication\", icon: \"moon\" },\n    { key: \"acid_reflux\", label: \"Acid reflux / Stomach problems\", icon: \"thermometer\" },\n    { key: \"high_blood_pressure\", label: \"High blood pressure\", icon: \"activity\" },\n    { key: \"depression_treatment\", label: \"Depression treatment\", icon: \"shield\" },\n  ];\n\n  return (\n    <StepContainer\n      icon=\"thermometer\"\n      title=\"Medications\"\n      onSkip={onSkip}\n    >\n      <View style={styles.optionsContainer}>\n        {options.map((option) => (\n          <OptionButton\n            key={option.key}\n            label={option.label}\n            icon={option.icon}\n            isSelected={value?.includes(option.key) ?? false}\n            onPress={() => handleSelect(option.key)}\n          />\n        ))}\n      </View>\n    </StepContainer>\n  );\n}\n\ninterface ScheduleStepProps {\n  wakeTime: string | undefined;\n  sleepTime: string | undefined;\n  onWakeTimeChange: (value: string) => void;\n  onSleepTimeChange: (value: string) => void;\n  onFinish: (wakeTime: string, sleepTime: string) => void;\n  data: OnboardingData;\n}\n\nfunction ScheduleStep({\n  wakeTime,\n  sleepTime,\n  onWakeTimeChange,\n  onSleepTimeChange,\n  onFinish,\n  data,\n}: ScheduleStepProps) {\n  const { theme } = useTheme();\n  const insets = useSafeAreaInsets();\n  const [localWakeTime, setLocalWakeTime] = useState(wakeTime || \"07:00\");\n  const [localSleepTime, setLocalSleepTime] = useState(sleepTime || \"23:00\");\n  const [showWakePicker, setShowWakePicker] = useState(false);\n  const [showSleepPicker, setShowSleepPicker] = useState(false);\n\n  const parseTime = (timeStr: string) => {\n    const [hourStr, minuteStr] = timeStr.split(\":\");\n    const hours = parseInt(hourStr);\n    const minutes = parseInt(minuteStr) || 0;\n    return { hours, minutes };\n  };\n\n  const formatTime = (time: string) => {\n    const { hours, minutes } = parseTime(time);\n    const period = hours >= 12 ? \"PM\" : \"AM\";\n    let hour12 = hours % 12;\n    if (hour12 === 0) hour12 = 12;\n    return `${hour12}:${String(minutes).padStart(2, \"0\")} ${period}`;\n  };\n\n  const onWakePickerConfirm = useCallback(\n    ({ hours, minutes }: { hours: number; minutes: number }) => {\n      setShowWakePicker(false);\n      const timeStr = `${String(hours).padStart(2, \"0\")}:${String(minutes).padStart(2, \"0\")}`;\n      setLocalWakeTime(timeStr);\n    },\n    []\n  );\n\n  const onSleepPickerConfirm = useCallback(\n    ({ hours, minutes }: { hours: number; minutes: number }) => {\n      setShowSleepPicker(false);\n      const timeStr = `${String(hours).padStart(2, \"0\")}:${String(minutes).padStart(2, \"0\")}`;\n      setLocalSleepTime(timeStr);\n    },\n    []\n  );\n\n  const handleConfirm = () => {\n    onWakeTimeChange(localWakeTime);\n    onSleepTimeChange(localSleepTime);\n    onFinish(localWakeTime, localSleepTime);\n  };\n\n  const wakeTimeParsed = parseTime(localWakeTime);\n  const sleepTimeParsed = parseTime(localSleepTime);\n\n  return (\n    <View style={styles.stepContainer}>\n      <View style={styles.stepHeader}>\n        <View\n          style={[\n            styles.iconCircle,\n            { backgroundColor: `${Colors.light.accent}20` },\n          ]}\n        >\n          <Feather name=\"clock\" size={32} color={Colors.light.accent} />\n        </View>\n        <ThemedText type=\"h2\" style={styles.stepTitle}>\n          Your Sleep Schedule\n        </ThemedText>\n      </View>\n\n      <View style={styles.stepContent}>\n        <ThemedText type=\"body\" muted style={styles.scheduleSubtitle}>\n          This helps us calculate when to stop caffeine\n        </ThemedText>\n\n        <View style={styles.scheduleContainer}>\n          <View style={styles.scheduleItem}>\n            <Feather name=\"sun\" size={24} color={Colors.light.accent} />\n            <ThemedText type=\"body\" style={styles.scheduleLabel}>\n              Wake up\n            </ThemedText>\n            <Pressable\n              onPress={() => setShowWakePicker(true)}\n              style={[styles.timePickerButton, { backgroundColor: theme.backgroundSecondary }]}\n            >\n              <Feather name=\"clock\" size={20} color={Colors.light.accent} />\n              <ThemedText type=\"h3\" style={styles.timeValue}>\n                {formatTime(localWakeTime)}\n              </ThemedText>\n              <Feather name=\"chevron-right\" size={20} color={theme.textMuted} />\n            </Pressable>\n          </View>\n\n          <View style={styles.scheduleItem}>\n            <Feather name=\"moon\" size={24} color={Colors.light.accent} />\n            <ThemedText type=\"body\" style={styles.scheduleLabel}>\n              Bedtime\n            </ThemedText>\n            <Pressable\n              onPress={() => setShowSleepPicker(true)}\n              style={[styles.timePickerButton, { backgroundColor: theme.backgroundSecondary }]}\n            >\n              <Feather name=\"clock\" size={20} color={Colors.light.accent} />\n              <ThemedText type=\"h3\" style={styles.timeValue}>\n                {formatTime(localSleepTime)}\n              </ThemedText>\n              <Feather name=\"chevron-right\" size={20} color={theme.textMuted} />\n            </Pressable>\n          </View>\n        </View>\n\n        <ThemedText type=\"caption\" muted style={styles.scheduleNote}>\n          Tap a time to change it\n        </ThemedText>\n      </View>\n\n      <View style={[styles.requiredButtonContainer, { paddingBottom: insets.bottom + Spacing.xl }]}>\n        <ContinueButton onPress={handleConfirm} />\n      </View>\n\n      <TimePickerModal\n        visible={showWakePicker}\n        onDismiss={() => setShowWakePicker(false)}\n        onConfirm={onWakePickerConfirm}\n        hours={wakeTimeParsed.hours}\n        minutes={wakeTimeParsed.minutes}\n        label=\"Wake Up Time\"\n        locale=\"en\"\n      />\n\n      <TimePickerModal\n        visible={showSleepPicker}\n        onDismiss={() => setShowSleepPicker(false)}\n        onConfirm={onSleepPickerConfirm}\n        hours={sleepTimeParsed.hours}\n        minutes={sleepTimeParsed.minutes}\n        label=\"Bedtime\"\n        locale=\"en\"\n      />\n    </View>\n  );\n}\n\ninterface SummaryStepProps {\n  data: OnboardingData;\n  onFinish: () => void;\n}\n\nfunction SummaryStep({ data, onFinish }: SummaryStepProps) {\n  const { theme } = useTheme();\n  const insets = useSafeAreaInsets();\n\n  const { optimal, safe } = calculateOptimalCaffeine(data);\n\n  return (\n    <View style={styles.summaryContainer}>\n      <View style={styles.summaryIconContainer}>\n        <View\n          style={[\n            styles.summaryIconCircle,\n            { backgroundColor: `${Colors.light.accent}20` },\n          ]}\n        >\n          <Feather name=\"check-circle\" size={48} color={Colors.light.accent} />\n        </View>\n      </View>\n\n      <ThemedText type=\"h2\" style={styles.summaryTitle}>\n        Your Caffeine Profile\n      </ThemedText>\n\n      <View style={styles.resultsContainer}>\n        <ThemedView elevation={1} style={styles.resultCard}>\n          <ThemedText type=\"caption\" muted style={styles.resultLabel}>\n            Optimal Daily Limit\n          </ThemedText>\n          <ThemedText type=\"h1\" style={[styles.resultValue, { color: Colors.light.accent }]}>\n            {optimal}\n            <ThemedText type=\"body\" style={{ color: Colors.light.accent }}> mg</ThemedText>\n          </ThemedText>\n        </ThemedView>\n\n        <ThemedView elevation={1} style={styles.resultCard}>\n          <ThemedText type=\"caption\" muted style={styles.resultLabel}>\n            Safe Maximum\n          </ThemedText>\n          <ThemedText type=\"h1\" style={styles.resultValue}>\n            {safe}\n            <ThemedText type=\"body\" muted> mg</ThemedText>\n          </ThemedText>\n        </ThemedView>\n      </View>\n\n      <View style={[styles.finishButtonContainer, { paddingBottom: insets.bottom + Spacing.xl }]}>\n        <Pressable\n          onPress={onFinish}\n          style={[styles.finishButton, { backgroundColor: Colors.light.accent }]}\n        >\n          <ThemedText type=\"body\" style={styles.finishButtonText}>\n            Get Started\n          </ThemedText>\n        </Pressable>\n      </View>\n    </View>\n  );\n}\n\ninterface StepContainerProps {\n  icon: keyof typeof Feather.glyphMap;\n  title: string;\n  onSkip: () => void;\n  children: React.ReactNode;\n}\n\nfunction StepContainer({ icon, title, onSkip, children }: StepContainerProps) {\n  const { theme } = useTheme();\n  const insets = useSafeAreaInsets();\n\n  return (\n    <View style={styles.stepContainer}>\n      <View style={styles.stepHeader}>\n        <View\n          style={[\n            styles.iconCircle,\n            { backgroundColor: `${Colors.light.accent}20` },\n          ]}\n        >\n          <Feather name={icon} size={32} color={Colors.light.accent} />\n        </View>\n        <ThemedText type=\"h2\" style={styles.stepTitle}>\n          {title}\n        </ThemedText>\n      </View>\n\n      <View style={styles.stepContent}>{children}</View>\n\n      <View style={[styles.skipContainer, { paddingBottom: insets.bottom + Spacing.xl }]}>\n        <Pressable onPress={onSkip} style={styles.skipButton}>\n          <ThemedText type=\"body\" muted style={styles.skipText}>\n            Skip\n          </ThemedText>\n        </Pressable>\n      </View>\n    </View>\n  );\n}\n\ninterface OptionButtonProps {\n  label: string;\n  icon: keyof typeof Feather.glyphMap;\n  isSelected: boolean;\n  onPress: () => void;\n}\n\nfunction OptionButton({ label, icon, isSelected, onPress }: OptionButtonProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={() => {\n        scale.value = withSpring(0.97);\n      }}\n      onPressOut={() => {\n        scale.value = withSpring(1);\n      }}\n      style={[\n        styles.optionButton,\n        {\n          backgroundColor: isSelected\n            ? Colors.light.accent\n            : theme.backgroundDefault,\n          borderColor: isSelected ? Colors.light.accent : theme.backgroundSecondary,\n        },\n        animatedStyle,\n      ]}\n    >\n      <Feather\n        name={icon}\n        size={20}\n        color={isSelected ? \"#FFFFFF\" : theme.text}\n      />\n      <ThemedText\n        type=\"body\"\n        style={[\n          styles.optionLabel,\n          { color: isSelected ? \"#FFFFFF\" : theme.text },\n        ]}\n      >\n        {label}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\ninterface SliderButtonProps {\n  icon: \"plus\" | \"minus\";\n  onPress: () => void;\n}\n\nfunction SliderButton({ icon, onPress }: SliderButtonProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={() => {\n        scale.value = withSpring(0.9);\n      }}\n      onPressOut={() => {\n        scale.value = withSpring(1);\n      }}\n      style={[\n        styles.sliderButton,\n        { backgroundColor: theme.backgroundDefault },\n        animatedStyle,\n      ]}\n    >\n      <Feather name={icon} size={24} color={Colors.light.accent} />\n    </AnimatedPressable>\n  );\n}\n\ninterface ContinueButtonProps {\n  onPress: () => void;\n  disabled?: boolean;\n}\n\nfunction ContinueButton({ onPress, disabled = false }: ContinueButtonProps) {\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  return (\n    <AnimatedPressable\n      onPress={disabled ? undefined : onPress}\n      onPressIn={() => {\n        if (!disabled) {\n          scale.value = withSpring(0.97);\n        }\n      }}\n      onPressOut={() => {\n        if (!disabled) {\n          scale.value = withSpring(1);\n        }\n      }}\n      style={[\n        styles.continueButton,\n        { backgroundColor: disabled ? Colors.light.textMuted : Colors.light.accent },\n        animatedStyle,\n      ]}\n    >\n      <ThemedText type=\"body\" style={styles.continueButtonText}>\n        Continue\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing.md,\n  },\n  backButton: {\n    width: 44,\n    height: 44,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  progressContainer: {\n    flex: 1,\n    paddingHorizontal: Spacing.md,\n  },\n  progressBar: {\n    height: 4,\n    borderRadius: 2,\n    overflow: \"hidden\",\n  },\n  progressFill: {\n    height: \"100%\",\n    borderRadius: 2,\n  },\n  content: {\n    flex: 1,\n  },\n  stepContainer: {\n    flex: 1,\n    paddingHorizontal: Spacing.xl,\n  },\n  stepHeader: {\n    alignItems: \"center\",\n    paddingTop: Spacing[\"3xl\"],\n    paddingBottom: Spacing[\"2xl\"],\n  },\n  iconCircle: {\n    width: 80,\n    height: 80,\n    borderRadius: 40,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginBottom: Spacing.lg,\n  },\n  stepTitle: {\n    textAlign: \"center\",\n  },\n  stepContent: {\n    flex: 1,\n  },\n  skipContainer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing.lg,\n  },\n  skipButton: {\n    paddingVertical: Spacing.sm,\n    paddingHorizontal: Spacing.xl,\n  },\n  skipText: {\n    fontWeight: \"500\",\n  },\n  sliderContainer: {\n    alignItems: \"center\",\n    paddingTop: Spacing[\"2xl\"],\n  },\n  valueDisplay: {\n    fontSize: 64,\n    fontWeight: \"700\",\n  },\n  valueLabel: {\n    marginTop: Spacing.xs,\n    marginBottom: Spacing[\"2xl\"],\n  },\n  sliderRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    width: \"100%\",\n    gap: Spacing.md,\n  },\n  sliderButton: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  sliderTrack: {\n    flex: 1,\n    height: 8,\n    backgroundColor: Colors.light.divider,\n    borderRadius: 4,\n    overflow: \"hidden\",\n  },\n  sliderFill: {\n    height: \"100%\",\n    borderRadius: 4,\n  },\n  rangeLabels: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    width: \"100%\",\n    paddingHorizontal: 56,\n    marginTop: Spacing.sm,\n  },\n  optionsContainer: {\n    gap: Spacing.md,\n    paddingTop: Spacing.lg,\n  },\n  optionButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    borderWidth: 2,\n    gap: Spacing.md,\n  },\n  optionLabel: {\n    fontWeight: \"500\",\n  },\n  continueButton: {\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    alignItems: \"center\",\n    marginTop: Spacing[\"2xl\"],\n  },\n  continueButtonText: {\n    color: \"#FFFFFF\",\n    fontWeight: \"600\",\n  },\n  summaryContainer: {\n    flex: 1,\n    paddingHorizontal: Spacing.xl,\n    justifyContent: \"center\",\n  },\n  summaryIconContainer: {\n    alignItems: \"center\",\n    marginBottom: Spacing[\"2xl\"],\n  },\n  summaryIconCircle: {\n    width: 100,\n    height: 100,\n    borderRadius: 50,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  summaryTitle: {\n    textAlign: \"center\",\n    marginBottom: Spacing[\"2xl\"],\n  },\n  resultsContainer: {\n    gap: Spacing.lg,\n    marginBottom: Spacing[\"3xl\"],\n  },\n  resultCard: {\n    padding: Spacing.xl,\n    borderRadius: BorderRadius.md,\n    alignItems: \"center\",\n  },\n  resultLabel: {\n    marginBottom: Spacing.sm,\n    textTransform: \"uppercase\",\n    letterSpacing: 0.5,\n  },\n  resultValue: {\n    fontWeight: \"700\",\n  },\n  finishButtonContainer: {\n    paddingTop: Spacing.xl,\n  },\n  finishButton: {\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    alignItems: \"center\",\n  },\n  finishButtonText: {\n    color: \"#FFFFFF\",\n    fontWeight: \"600\",\n  },\n  inputContainer: {\n    paddingTop: Spacing.lg,\n  },\n  inputLabel: {\n    textAlign: \"center\",\n    marginBottom: Spacing[\"2xl\"],\n  },\n  textInputContainer: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.md,\n    gap: Spacing.md,\n  },\n  textInputWrapper: {\n    flex: 1,\n  },\n  textInput: {\n    fontSize: 16,\n    paddingVertical: Spacing.sm,\n  },\n  scheduleSubtitle: {\n    textAlign: \"center\",\n    marginBottom: Spacing[\"2xl\"],\n  },\n  scheduleContainer: {\n    gap: Spacing.xl,\n  },\n  scheduleItem: {\n    alignItems: \"center\",\n    gap: Spacing.md,\n  },\n  scheduleLabel: {\n    fontWeight: \"500\",\n  },\n  timeSelector: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.lg,\n  },\n  timeValue: {\n    minWidth: 120,\n    textAlign: \"center\",\n  },\n  scheduleNote: {\n    textAlign: \"center\",\n    marginTop: Spacing[\"2xl\"],\n  },\n  requiredButtonContainer: {\n    paddingTop: Spacing.xl,\n  },\n  timePickerButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingVertical: Spacing.lg,\n    paddingHorizontal: Spacing.xl,\n    borderRadius: BorderRadius.md,\n    gap: Spacing.md,\n    minWidth: 180,\n    justifyContent: \"center\",\n  },\n  pickerModalOverlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    justifyContent: \"flex-end\",\n  },\n  pickerModalContent: {\n    borderTopLeftRadius: BorderRadius.lg,\n    borderTopRightRadius: BorderRadius.lg,\n    paddingBottom: Spacing[\"3xl\"],\n  },\n  pickerHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.xl,\n    paddingVertical: Spacing.lg,\n    borderBottomWidth: 1,\n    borderBottomColor: \"rgba(0, 0, 0, 0.1)\",\n  },\n  pickerTitle: {\n    fontWeight: \"600\",\n  },\n  pickerDoneButton: {\n    paddingVertical: Spacing.sm,\n    paddingHorizontal: Spacing.md,\n  },\n  timePicker: {\n    height: 200,\n  },\n  timePickerContainer: {\n    flexDirection: \"row\",\n    justifyContent: \"center\",\n    gap: Spacing.lg,\n    paddingHorizontal: Spacing.xl,\n    paddingVertical: Spacing.lg,\n  },\n  timePickerColumn: {\n    alignItems: \"center\",\n    flex: 1,\n  },\n  timePickerLabel: {\n    marginBottom: Spacing.sm,\n    textTransform: \"uppercase\",\n    letterSpacing: 0.5,\n  },\n  timePickerScroll: {\n    maxHeight: 180,\n  },\n  timePickerItem: {\n    paddingVertical: Spacing.md,\n    paddingHorizontal: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    marginVertical: 2,\n    minWidth: 60,\n    alignItems: \"center\",\n  },\n  timePickerItemText: {\n    fontWeight: \"500\",\n  },\n  periodContainer: {\n    gap: Spacing.sm,\n  },\n  periodButton: {\n    paddingVertical: Spacing.md,\n    paddingHorizontal: Spacing.xl,\n    borderRadius: BorderRadius.sm,\n    minWidth: 70,\n    alignItems: \"center\",\n  },\n  periodButtonText: {\n    fontWeight: \"600\",\n  },\n  previewContainer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing.lg,\n    borderTopWidth: 1,\n    borderTopColor: \"rgba(0, 0, 0, 0.1)\",\n    marginTop: Spacing.md,\n  },\n});\n","path":null,"size_bytes":32188,"size_tokens":null},"index.js":{"content":"import { registerRootComponent } from \"expo\";\n\nimport App from \"@/App\";\n\nregisterRootComponent(App);\n","path":null,"size_bytes":101,"size_tokens":null},"App.tsx":{"content":"import React from \"react\";\nimport { StyleSheet, View } from \"react-native\";\nimport { NavigationContainer, DefaultTheme, DarkTheme } from \"@react-navigation/native\";\nimport { GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport { KeyboardProvider } from \"react-native-keyboard-controller\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\nimport { StatusBar } from \"expo-status-bar\";\nimport { PaperProvider, MD3LightTheme, MD3DarkTheme } from \"react-native-paper\";\n\nimport RootNavigator from \"@/navigation/RootNavigator\";\nimport { ErrorBoundary } from \"@/components/ErrorBoundary\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors } from \"@/constants/theme\";\nimport { ThemeProvider } from \"@/store/themeStore\";\n\nconst caffiLightTheme = {\n  ...MD3LightTheme,\n  colors: {\n    ...MD3LightTheme.colors,\n    primary: \"#C69C6D\",\n    primaryContainer: \"#FFFFFF\",\n    onPrimaryContainer: \"#6B4C3B\",\n    secondary: \"#C69C6D\",\n    secondaryContainer: \"#F5F5F5\",\n    onSecondaryContainer: \"#6B4C3B\",\n    tertiary: \"#C69C6D\",\n    tertiaryContainer: \"#FFFFFF\",\n    surface: \"#FFFFFF\",\n    surfaceVariant: \"#F5F5F5\",\n    onSurface: \"#6B4C3B\",\n    onSurfaceVariant: \"#5A5A5A\",\n    outline: \"#C69C6D\",\n    background: \"#FFFFFF\",\n    onBackground: \"#6B4C3B\",\n  },\n};\n\nconst caffiDarkTheme = {\n  ...MD3DarkTheme,\n  colors: {\n    ...MD3DarkTheme.colors,\n    primary: \"#C9A36A\",\n    primaryContainer: \"#2A2420\",\n    onPrimaryContainer: \"#F5EBDD\",\n    secondary: \"#C9A36A\",\n    secondaryContainer: \"#353030\",\n    onSecondaryContainer: \"#F5EBDD\",\n    tertiary: \"#C9A36A\",\n    tertiaryContainer: \"#2A2420\",\n    surface: \"#1F1815\",\n    surfaceVariant: \"#353030\",\n    onSurface: \"#F5EBDD\",\n    onSurfaceVariant: \"#A0A0A0\",\n    outline: \"#C9A36A\",\n    background: \"#1F1815\",\n    onBackground: \"#F5EBDD\",\n  },\n};\n\nconst navLightTheme = {\n  ...DefaultTheme,\n  colors: {\n    ...DefaultTheme.colors,\n    background: Colors.light.bg,\n    card: Colors.light.backgroundSecondary,\n    text: Colors.light.text,\n    border: Colors.light.divider,\n    primary: Colors.light.accent,\n  },\n};\n\nconst navDarkTheme = {\n  ...DarkTheme,\n  colors: {\n    ...DarkTheme.colors,\n    background: Colors.dark.bg,\n    card: Colors.dark.backgroundSecondary,\n    text: Colors.dark.text,\n    border: Colors.dark.divider,\n    primary: Colors.dark.accent,\n  },\n};\n\nfunction AppContent() {\n  const { isDark, theme } = useTheme();\n  \n  return (\n    <PaperProvider theme={isDark ? caffiDarkTheme : caffiLightTheme}>\n      <SafeAreaProvider>\n        <GestureHandlerRootView style={styles.root}>\n          <View style={[styles.root, { backgroundColor: theme.bg }]}>\n            <KeyboardProvider>\n              <NavigationContainer theme={isDark ? navDarkTheme : navLightTheme}>\n                <RootNavigator />\n              </NavigationContainer>\n              <StatusBar style={isDark ? \"light\" : \"dark\"} />\n            </KeyboardProvider>\n          </View>\n        </GestureHandlerRootView>\n      </SafeAreaProvider>\n    </PaperProvider>\n  );\n}\n\nexport default function App() {\n  return (\n    <ErrorBoundary>\n      <ThemeProvider>\n        <AppContent />\n      </ThemeProvider>\n    </ErrorBoundary>\n  );\n}\n\nconst styles = StyleSheet.create({\n  root: {\n    flex: 1,\n  },\n});\n","path":null,"size_bytes":3260,"size_tokens":null},"components/Spacer.tsx":{"content":"import { View } from \"react-native\";\n\ntype Props = {\n  width?: number;\n  height?: number;\n};\n\nexport default function Spacer(props: Props) {\n  const width: number = props.width ?? 1;\n  const height: number = props.height ?? 1;\n\n  return (\n    <View\n      style={{\n        width,\n        height,\n      }}\n    />\n  );\n}\n","path":null,"size_bytes":318,"size_tokens":null},"constants/theme.ts":{"content":"import { Platform } from \"react-native\";\n\nexport const Colors = {\n  light: {\n    bg: \"#FFFFFF\",\n    accentGold: \"#C9A36A\",\n    darkBrown: \"#5C4A3B\",\n    darkBrown2: \"#6A513B\",\n    green: \"#53A451\",\n    blue: \"#4DA3FF\",\n    mutedGrey: \"#9E9E9E\",\n    red: \"#D9534F\",\n    white: \"#FFFFFF\",\n    text: \"#5C4A3B\",\n    textMuted: \"#9E9E9E\",\n    buttonText: \"#FFFFFF\",\n    tabIconDefault: \"#9E9E9E\",\n    tabIconSelected: \"#C9A36A\",\n    link: \"#C9A36A\",\n    backgroundRoot: \"#FFFFFF\",\n    backgroundDefault: \"#FFFFFF\",\n    backgroundSecondary: \"#FFFFFF\",\n    backgroundTertiary: \"#F5F5F5\",\n    accent: \"#C9A36A\",\n    success: \"#53A451\",\n    warning: \"#F2A43A\",\n    danger: \"#D9534F\",\n    divider: \"#E8E4DC\",\n  },\n  dark: {\n    bg: \"#1F1815\",\n    accentGold: \"#C9A36A\",\n    darkBrown: \"#F5EBDD\",\n    darkBrown2: \"#E8DFD4\",\n    green: \"#53A451\",\n    blue: \"#4DA3FF\",\n    mutedGrey: \"#A0A0A0\",\n    red: \"#D9534F\",\n    white: \"#FFFFFF\",\n    text: \"#F5EBDD\",\n    textMuted: \"#A0A0A0\",\n    buttonText: \"#FFFFFF\",\n    tabIconDefault: \"#9BA1A6\",\n    tabIconSelected: \"#C9A36A\",\n    link: \"#C9A36A\",\n    backgroundRoot: \"#1F1815\",\n    backgroundDefault: \"#2A2420\",\n    backgroundSecondary: \"#353030\",\n    backgroundTertiary: \"#403838\",\n    accent: \"#C9A36A\",\n    success: \"#53A451\",\n    warning: \"#F2A43A\",\n    danger: \"#D9534F\",\n    divider: \"#3A3535\",\n  },\n};\n\nexport const Spacing = {\n  xs: 4,\n  sm: 8,\n  md: 12,\n  lg: 16,\n  xl: 20,\n  \"2xl\": 24,\n  \"3xl\": 32,\n  \"4xl\": 40,\n  \"5xl\": 48,\n  inputHeight: 48,\n  buttonHeight: 52,\n};\n\nexport const BorderRadius = {\n  xs: 8,\n  sm: 12,\n  md: 16,\n  lg: 24,\n  xl: 30,\n  \"2xl\": 40,\n  \"3xl\": 50,\n  full: 9999,\n};\n\nexport const Typography = {\n  h1: {\n    fontSize: 32,\n    fontWeight: \"700\" as const,\n  },\n  h2: {\n    fontSize: 28,\n    fontWeight: \"700\" as const,\n  },\n  h3: {\n    fontSize: 24,\n    fontWeight: \"600\" as const,\n  },\n  h4: {\n    fontSize: 20,\n    fontWeight: \"600\" as const,\n  },\n  body: {\n    fontSize: 16,\n    fontWeight: \"400\" as const,\n  },\n  small: {\n    fontSize: 14,\n    fontWeight: \"400\" as const,\n  },\n  caption: {\n    fontSize: 12,\n    fontWeight: \"400\" as const,\n  },\n  link: {\n    fontSize: 16,\n    fontWeight: \"400\" as const,\n  },\n  largeStat: {\n    fontSize: 44,\n    fontWeight: \"700\" as const,\n  },\n};\n\nexport const Fonts = Platform.select({\n  ios: {\n    sans: \"system-ui\",\n    serif: \"ui-serif\",\n    rounded: \"ui-rounded\",\n    mono: \"ui-monospace\",\n  },\n  default: {\n    sans: \"normal\",\n    serif: \"serif\",\n    rounded: \"normal\",\n    mono: \"monospace\",\n  },\n  web: {\n    sans: \"Inter, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif\",\n    serif: \"Georgia, 'Times New Roman', serif\",\n    rounded:\n      \"'SF Pro Rounded', 'Hiragino Maru Gothic ProN', Meiryo, 'MS PGothic', sans-serif\",\n    mono: \"SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace\",\n  },\n});\n\nexport const Shadows = {\n  small: {\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.08,\n    shadowRadius: 4,\n    elevation: 2,\n  },\n  medium: {\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.1,\n    shadowRadius: 8,\n    elevation: 4,\n  },\n  large: {\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 6 },\n    shadowOpacity: 0.12,\n    shadowRadius: 12,\n    elevation: 6,\n  },\n};\n","path":null,"size_bytes":3365,"size_tokens":null},"components/QuickStatCard.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface QuickStatCardProps {\n  icon: keyof typeof Feather.glyphMap;\n  label: string;\n  value: string;\n  sublabel?: string;\n  status?: \"good\" | \"warning\" | \"danger\";\n}\n\nexport function QuickStatCard({\n  icon,\n  label,\n  value,\n  sublabel,\n  status,\n}: QuickStatCardProps) {\n  const { theme } = useTheme();\n\n  const getStatusColor = () => {\n    switch (status) {\n      case \"good\":\n        return Colors.light.success;\n      case \"warning\":\n        return Colors.light.warning;\n      case \"danger\":\n        return Colors.light.danger;\n      default:\n        return Colors.light.accent;\n    }\n  };\n\n  return (\n    <ThemedView elevation={1} style={styles.container}>\n      <View\n        style={[\n          styles.iconContainer,\n          { backgroundColor: `${getStatusColor()}20` },\n        ]}\n      >\n        <Feather name={icon} size={16} color={getStatusColor()} />\n      </View>\n      <ThemedText type=\"caption\" muted style={styles.label}>\n        {label}\n      </ThemedText>\n      <ThemedText\n        type=\"small\"\n        style={[styles.value, status && { color: getStatusColor() }]}\n        numberOfLines={1}\n      >\n        {value}\n      </ThemedText>\n      {sublabel && (\n        <ThemedText type=\"caption\" muted numberOfLines={1}>\n          {sublabel}\n        </ThemedText>\n      )}\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n  },\n  iconContainer: {\n    width: 32,\n    height: 32,\n    borderRadius: 16,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginBottom: Spacing.xs,\n  },\n  label: {\n    marginBottom: Spacing.xs,\n    textAlign: \"center\",\n  },\n  value: {\n    fontWeight: \"600\",\n    textAlign: \"center\",\n  },\n});\n","path":null,"size_bytes":2116,"size_tokens":null},"components/RingProgress.tsx":{"content":"import React from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Text,\n  Pressable,\n  AccessibilityProps,\n} from \"react-native\";\nimport Svg, { Circle, Defs, LinearGradient, Stop } from \"react-native-svg\";\nimport Animated, {\n  useAnimatedProps,\n  useSharedValue,\n  withTiming,\n  Easing,\n} from \"react-native-reanimated\";\nimport { Colors, Shadows } from \"@/constants/theme\";\n\ninterface RingProgressProps {\n  consumedTodayMg: number;\n  optimalDailyMg: number;\n  sizePx?: number;\n  onPress?: () => void;\n}\n\nconst AnimatedCircle = Animated.createAnimatedComponent(Circle);\n\nexport function RingProgress({\n  consumedTodayMg,\n  optimalDailyMg,\n  sizePx = 72,\n  onPress,\n}: RingProgressProps) {\n  const strokeWidth = 8;\n  const radius = (sizePx - strokeWidth) / 2;\n  const circumference = 2 * Math.PI * radius;\n\n  const rawPercent = (consumedTodayMg / optimalDailyMg) * 100;\n  const percent = Math.min(Math.max(rawPercent, 0), 150);\n  const displayPercent = Math.round(rawPercent);\n  const isOverLimit = rawPercent > 100;\n\n  const progress = useSharedValue(0);\n\n  React.useEffect(() => {\n    progress.value = withTiming(Math.min(percent, 100) / 100, {\n      duration: 800,\n      easing: Easing.bezier(0.25, 0.1, 0.25, 1),\n    });\n  }, [percent]);\n\n  const animatedProps = useAnimatedProps(() => {\n    const strokeDashoffset = circumference * (1 - progress.value);\n    return {\n      strokeDashoffset,\n    };\n  });\n\n  const ringColor = isOverLimit ? Colors.light.red : Colors.light.accentGold;\n  const accessibilityLabel = `Today: ${consumedTodayMg} milligrams of ${optimalDailyMg} milligrams (${displayPercent}%)`;\n\n  const content = (\n    <View\n      style={[\n        styles.container,\n        { width: sizePx, height: sizePx },\n        isOverLimit && styles.overLimitGlow,\n      ]}\n      accessibilityLabel={accessibilityLabel}\n      accessibilityRole=\"progressbar\"\n      accessibilityValue={{\n        min: 0,\n        max: 100,\n        now: Math.min(displayPercent, 100),\n      }}\n    >\n      <Svg width={sizePx} height={sizePx}>\n        <Defs>\n          <LinearGradient id=\"ringGradient\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"1\">\n            <Stop\n              offset=\"0\"\n              stopColor={isOverLimit ? Colors.light.red : Colors.light.accentGold}\n            />\n            <Stop\n              offset=\"1\"\n              stopColor={isOverLimit ? \"#E85D4E\" : Colors.light.green}\n            />\n          </LinearGradient>\n        </Defs>\n\n        <Circle\n          cx={sizePx / 2}\n          cy={sizePx / 2}\n          r={radius}\n          stroke={Colors.light.divider}\n          strokeWidth={strokeWidth}\n          fill=\"white\"\n        />\n\n        <AnimatedCircle\n          cx={sizePx / 2}\n          cy={sizePx / 2}\n          r={radius}\n          stroke=\"url(#ringGradient)\"\n          strokeWidth={strokeWidth}\n          fill=\"transparent\"\n          strokeDasharray={circumference}\n          animatedProps={animatedProps}\n          strokeLinecap=\"round\"\n          rotation=\"-90\"\n          origin={`${sizePx / 2}, ${sizePx / 2}`}\n        />\n      </Svg>\n\n      <View style={styles.centerContent}>\n        <Text\n          style={[styles.consumedText, isOverLimit && { color: Colors.light.red }]}\n        >\n          {consumedTodayMg}\n        </Text>\n        <Text style={styles.subtitleText}>\n          {isOverLimit ? \"Over limit\" : `of ${optimalDailyMg}`}\n        </Text>\n      </View>\n    </View>\n  );\n\n  if (onPress) {\n    return (\n      <Pressable onPress={onPress} style={styles.pressable}>\n        {content}\n      </Pressable>\n    );\n  }\n\n  return content;\n}\n\nconst styles = StyleSheet.create({\n  pressable: {\n    ...Shadows.small,\n  },\n  container: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    backgroundColor: \"white\",\n    borderRadius: 100,\n    ...Shadows.small,\n  },\n  overLimitGlow: {\n    shadowColor: Colors.light.red,\n    shadowOpacity: 0.3,\n  },\n  centerContent: {\n    position: \"absolute\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  consumedText: {\n    fontSize: 14,\n    fontWeight: \"700\",\n    color: Colors.light.darkBrown,\n  },\n  subtitleText: {\n    fontSize: 8,\n    color: Colors.light.mutedGrey,\n    marginTop: -2,\n  },\n});\n","path":null,"size_bytes":4160,"size_tokens":null},"components/ThemedView.tsx":{"content":"import { View, type ViewProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\n\nexport type ThemedViewProps = ViewProps & {\n  lightColor?: string;\n  darkColor?: string;\n  elevation?: 0 | 1 | 2 | 3;\n};\n\nexport function ThemedView({\n  style,\n  lightColor,\n  darkColor,\n  elevation = 0,\n  ...otherProps\n}: ThemedViewProps) {\n  const { theme, isDark } = useTheme();\n\n  const getBackgroundColor = () => {\n    if (isDark && darkColor) {\n      return darkColor;\n    }\n    if (!isDark && lightColor) {\n      return lightColor;\n    }\n    switch (elevation) {\n      case 1:\n        return theme.backgroundDefault;\n      case 2:\n        return theme.backgroundSecondary;\n      case 3:\n        return theme.backgroundTertiary;\n      default:\n        return theme.backgroundRoot;\n    }\n  };\n\n  return (\n    <View\n      style={[{ backgroundColor: getBackgroundColor() }, style]}\n      {...otherProps}\n    />\n  );\n}\n","path":null,"size_bytes":921,"size_tokens":null},"navigation/HistoryStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport HistoryScreen from \"@/screens/HistoryScreen\";\nimport ArticleScreen from \"@/screens/ArticleScreen\";\n\ninterface Article {\n  id: string;\n  title: string;\n  summary: string;\n  image: string;\n  content: string;\n  references: string[];\n}\n\nexport type HistoryStackParamList = {\n  History: undefined;\n  Article: { article: Article };\n};\n\nconst Stack = createNativeStackNavigator<HistoryStackParamList>();\n\nexport default function HistoryStackNavigator() {\n  return (\n    <Stack.Navigator\n      screenOptions={{\n        headerShown: false,\n      }}\n    >\n      <Stack.Screen name=\"History\" component={HistoryScreen} />\n      <Stack.Screen name=\"Article\" component={ArticleScreen} />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":815,"size_tokens":null},"screens/ConsumptionByTimeScreen.tsx":{"content":"import React, { useMemo, useState } from \"react\";\nimport { View, StyleSheet, Text, Pressable, ScrollView } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useCaffeineStore } from \"@/store/caffeineStore\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ntype ViewMode = \"Week\" | \"Month\" | \"Year\";\n\ninterface TimePeriod {\n  label: string;\n  icon: string;\n  startHour: number;\n  endHour: number;\n}\n\nconst TIME_PERIODS: TimePeriod[] = [\n  { label: \"5AM - 12PM\", icon: \"sunrise\", startHour: 5, endHour: 12 },\n  { label: \"12PM - 3PM\", icon: \"sun\", startHour: 12, endHour: 15 },\n  { label: \"3PM - 7PM\", icon: \"sunset\", startHour: 15, endHour: 19 },\n  { label: \"7PM - 5AM\", icon: \"moon\", startHour: 19, endHour: 5 },\n];\n\nconst BAR_COLORS = [\n  \"#E8DCCC\",\n  \"#D4C4A8\",\n  \"#C9A36A\",\n  \"#5C4A3B\",\n];\n\nexport default function ConsumptionByTimeScreen() {\n  const { theme } = useTheme();\n  const navigation = useNavigation();\n  const insets = useSafeAreaInsets();\n  const { entries } = useCaffeineStore();\n  const [viewMode, setViewMode] = useState<ViewMode>(\"Month\");\n  const [selectedDate, setSelectedDate] = useState(new Date());\n\n  const isInTimePeriod = (hour: number, period: TimePeriod): boolean => {\n    if (period.startHour < period.endHour) {\n      return hour >= period.startHour && hour < period.endHour;\n    } else {\n      return hour >= period.startHour || hour < period.endHour;\n    }\n  };\n\n  const getDateRange = useMemo(() => {\n    const start = new Date(selectedDate);\n    const end = new Date(selectedDate);\n\n    if (viewMode === \"Week\") {\n      const day = start.getDay();\n      start.setDate(start.getDate() - day);\n      start.setHours(0, 0, 0, 0);\n      end.setDate(start.getDate() + 6);\n      end.setHours(23, 59, 59, 999);\n    } else if (viewMode === \"Month\") {\n      start.setDate(1);\n      start.setHours(0, 0, 0, 0);\n      end.setMonth(end.getMonth() + 1);\n      end.setDate(0);\n      end.setHours(23, 59, 59, 999);\n    } else {\n      start.setMonth(0, 1);\n      start.setHours(0, 0, 0, 0);\n      end.setMonth(11, 31);\n      end.setHours(23, 59, 59, 999);\n    }\n\n    return { start, end };\n  }, [selectedDate, viewMode]);\n\n  const periodData = useMemo(() => {\n    const { start, end } = getDateRange;\n\n    return TIME_PERIODS.map((period) => {\n      const total = entries\n        .filter((entry) => {\n          const entryDate = new Date(entry.timestamp);\n          return entryDate >= start && entryDate <= end;\n        })\n        .filter((entry) => {\n          const hour = new Date(entry.timestamp).getHours();\n          return isInTimePeriod(hour, period);\n        })\n        .reduce((sum, entry) => sum + entry.caffeineAmount, 0);\n\n      return { ...period, total: Math.round(total) };\n    });\n  }, [entries, getDateRange]);\n\n  const maxTotal = Math.max(...periodData.map((p) => p.total), 1);\n\n  const navigateDate = (direction: number) => {\n    const newDate = new Date(selectedDate);\n    if (viewMode === \"Week\") {\n      newDate.setDate(newDate.getDate() + direction * 7);\n    } else if (viewMode === \"Month\") {\n      newDate.setMonth(newDate.getMonth() + direction);\n    } else {\n      newDate.setFullYear(newDate.getFullYear() + direction);\n    }\n    setSelectedDate(newDate);\n  };\n\n  const getDateLabel = (): string => {\n    if (viewMode === \"Week\") {\n      const { start, end } = getDateRange;\n      const startStr = start.toLocaleDateString(\"en-US\", { month: \"short\", day: \"numeric\" });\n      const endStr = end.toLocaleDateString(\"en-US\", { month: \"short\", day: \"numeric\", year: \"numeric\" });\n      return `${startStr} - ${endStr}`;\n    } else if (viewMode === \"Month\") {\n      return selectedDate.toLocaleDateString(\"en-US\", {\n        month: \"long\",\n        year: \"numeric\",\n      });\n    } else {\n      return selectedDate.getFullYear().toString();\n    }\n  };\n\n  const getIconComponent = (iconName: string) => {\n    return <Feather name={iconName as any} size={18} color={theme.mutedGrey} />;\n  };\n\n  return (\n    <View style={[styles.container, { backgroundColor: theme.backgroundRoot }]}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.md }]}>\n        <Pressable\n          onPress={() => navigation.goBack()}\n          style={styles.backButton}\n          hitSlop={{ top: 12, bottom: 12, left: 12, right: 12 }}\n        >\n          <Feather name=\"arrow-left\" size={24} color={theme.text} />\n        </Pressable>\n        <Text style={[styles.headerTitle, { color: theme.text }]}>Analytic</Text>\n        <View style={styles.headerSpacer} />\n      </View>\n\n      <ScrollView\n        style={styles.scrollView}\n        contentContainerStyle={styles.scrollContent}\n        showsVerticalScrollIndicator={false}\n      >\n        <Text style={[styles.title, { color: theme.text }]}>\n          Consumption by time of day\n        </Text>\n        <Text style={[styles.description, { color: theme.mutedGrey }]}>\n          When do you consume caffeine throughout the day?\n        </Text>\n\n        <View style={styles.modeSelector}>\n          {([\"Week\", \"Month\", \"Year\"] as ViewMode[]).map((mode) => (\n            <Pressable\n              key={mode}\n              style={[\n                styles.modeButton,\n                viewMode === mode\n                  ? { backgroundColor: theme.accentGold }\n                  : { backgroundColor: theme.backgroundSecondary },\n              ]}\n              onPress={() => setViewMode(mode)}\n            >\n              <Text\n                style={[\n                  styles.modeButtonText,\n                  { color: viewMode === mode ? \"#FFFFFF\" : theme.text },\n                ]}\n              >\n                {mode}\n              </Text>\n            </Pressable>\n          ))}\n        </View>\n\n        <View style={styles.dateNavigator}>\n          <Pressable onPress={() => navigateDate(-1)} hitSlop={12}>\n            <Feather name=\"chevron-left\" size={20} color={theme.text} />\n          </Pressable>\n          <Text style={[styles.dateLabel, { color: theme.text }]}>\n            {getDateLabel()}\n          </Text>\n          <Pressable onPress={() => navigateDate(1)} hitSlop={12}>\n            <Feather name=\"chevron-right\" size={20} color={theme.text} />\n          </Pressable>\n        </View>\n\n        <View style={styles.barsContainer}>\n          {periodData.map((period, idx) => {\n            const barWidth = period.total > 0 ? (period.total / maxTotal) * 100 : 0;\n            const barColor = BAR_COLORS[idx];\n            const isDarkBar = idx >= 2;\n            const textOnBar = barWidth > 60;\n\n            return (\n              <View key={idx} style={styles.barRow}>\n                <View\n                  style={[\n                    styles.barBackground,\n                    { backgroundColor: theme.backgroundSecondary },\n                  ]}\n                >\n                  <View\n                    style={[\n                      styles.barFill,\n                      {\n                        width: `${barWidth}%`,\n                        backgroundColor: barColor,\n                      },\n                    ]}\n                  />\n                  <View style={styles.barContent}>\n                    <View style={styles.barLabelContainer}>\n                      {getIconComponent(period.icon)}\n                      <Text\n                        style={[\n                          styles.barLabelText,\n                          { color: textOnBar && isDarkBar ? \"#FFFFFF\" : theme.text },\n                        ]}\n                      >\n                        {period.label}\n                      </Text>\n                    </View>\n                    <Text\n                      style={[\n                        styles.barValueText,\n                        { color: textOnBar && isDarkBar ? \"#FFFFFF\" : theme.text },\n                      ]}\n                    >\n                      {period.total} mg\n                    </Text>\n                  </View>\n                </View>\n              </View>\n            );\n          })}\n        </View>\n\n        <Text style={[styles.summaryText, { color: theme.mutedGrey }]}>\n          Average amount of caffeine consumed per time period.\n        </Text>\n      </ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing.lg,\n  },\n  backButton: {\n    width: 24,\n  },\n  headerTitle: {\n    fontSize: 18,\n    fontWeight: \"600\",\n    textAlign: \"center\",\n  },\n  headerSpacer: {\n    width: 24,\n  },\n  scrollView: {\n    flex: 1,\n  },\n  scrollContent: {\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing[\"3xl\"],\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: \"700\",\n    marginBottom: Spacing.sm,\n  },\n  description: {\n    fontSize: 14,\n    lineHeight: 20,\n    marginBottom: Spacing.xl,\n  },\n  modeSelector: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.xl,\n  },\n  modeButton: {\n    paddingHorizontal: Spacing.xl,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.xl,\n  },\n  modeButtonText: {\n    fontSize: 14,\n    fontWeight: \"600\",\n  },\n  dateNavigator: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n    marginBottom: Spacing[\"2xl\"],\n  },\n  dateLabel: {\n    fontSize: 16,\n    fontWeight: \"600\",\n    minWidth: 200,\n    textAlign: \"center\",\n  },\n  barsContainer: {\n    gap: Spacing.lg,\n    marginBottom: Spacing[\"2xl\"],\n  },\n  barRow: {\n    width: \"100%\",\n  },\n  barBackground: {\n    height: 56,\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n    position: \"relative\",\n  },\n  barFill: {\n    position: \"absolute\",\n    left: 0,\n    top: 0,\n    bottom: 0,\n    borderRadius: BorderRadius.md,\n  },\n  barContent: {\n    position: \"absolute\",\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n  },\n  barLabelContainer: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n  },\n  barLabelText: {\n    fontSize: 14,\n    fontWeight: \"600\",\n  },\n  barValueText: {\n    fontSize: 14,\n    fontWeight: \"600\",\n  },\n  summaryText: {\n    fontSize: 14,\n    lineHeight: 20,\n  },\n});\n","path":null,"size_bytes":10478,"size_tokens":null},"components/CaffeineLogPopup.tsx":{"content":"import React, { useEffect, useMemo } from \"react\";\nimport {\n  Modal,\n  View,\n  StyleSheet,\n  Pressable,\n  Dimensions,\n  Image,\n  Text,\n  ScrollView,\n} from \"react-native\";\nimport { Gesture, GestureDetector, GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n  withTiming,\n  runOnJS,\n} from \"react-native-reanimated\";\nimport Svg, { Defs, LinearGradient, Stop, Path, Circle, Text as SvgText } from \"react-native-svg\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { Spacing } from \"@/constants/theme\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport type { DrinkEntry } from \"@/store/caffeineStore\";\n\nconst SCREEN_HEIGHT = Dimensions.get(\"window\").height;\nconst SHEET_MAX_HEIGHT = SCREEN_HEIGHT * 0.9;\n\ntype CaffeineLogPopupProps = {\n  visible: boolean;\n  entry: DrinkEntry | null;\n  onClose: () => void;\n  onEdit?: (entry: DrinkEntry) => void;\n  onDuplicate?: (entry: DrinkEntry) => void;\n  onDelete?: (entry: DrinkEntry) => void;\n};\n\n// Build a simple decay curve for the single entry to mirror home graph color\nconst CAFFEINE_HALF_LIFE_HOURS = 5.5;\n\nfunction calculateCaffeineStats(entry: DrinkEntry | null) {\n  if (!entry) {\n    return {\n      peakMg: 0,\n      currentMg: 0,\n      totalMg: 0,\n      peakTimeLabel: \"\",\n      currentTimeLabel: \"\",\n      hoursElapsed: 0,\n    };\n  }\n\n  const now = new Date();\n  const entryTime = new Date(entry.timestamp);\n  const hoursElapsed = (now.getTime() - entryTime.getTime()) / (1000 * 60 * 60);\n  \n  const totalMg = entry.caffeineAmount;\n  const peakMg = entry.caffeineAmount;\n  \n  const remainingFactor = Math.pow(0.5, hoursElapsed / CAFFEINE_HALF_LIFE_HOURS);\n  const currentMg = totalMg * remainingFactor;\n  \n  const peakTimeLabel = entryTime.toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n  });\n  \n  const currentTimeLabel = now.toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n  });\n\n  return {\n    peakMg: Math.round(peakMg * 10) / 10,\n    currentMg: Math.round(currentMg * 10) / 10,\n    totalMg: Math.round(totalMg * 10) / 10,\n    peakTimeLabel,\n    currentTimeLabel,\n    hoursElapsed,\n  };\n}\n\nfunction useDecayPath(entry: DrinkEntry | null, curveColor: string) {\n  const width = Dimensions.get(\"window\").width - Spacing.lg * 2;\n  const height = 160;\n\n  const caffeineStats = useMemo(() => calculateCaffeineStats(entry), [entry]);\n\n  const { path, area, peak, peakTimeLabel, timeLabels } = useMemo(() => {\n    if (!entry) {\n      return { path: \"\", area: \"\", peak: { x: 0, y: height }, peakTimeLabel: \"\", timeLabels: [] };\n    }\n    \n    const entryTime = new Date(entry.timestamp);\n    const now = new Date();\n    const hoursElapsed = (now.getTime() - entryTime.getTime()) / (1000 * 60 * 60);\n    const hoursToShow = Math.max(12, hoursElapsed + 2);\n    \n    const startX = 0;\n    const startY = height;\n    const peakX = width * 0.08;\n    const peakY = height * 0.15;\n    \n    const nowX = Math.min((hoursElapsed / hoursToShow) * width, width * 0.95);\n    const decayFactor = Math.pow(0.5, hoursElapsed / CAFFEINE_HALF_LIFE_HOURS);\n    const nowY = height * 0.15 + (height * 0.7) * (1 - decayFactor);\n    \n    const endX = width;\n    const endDecayFactor = Math.pow(0.5, hoursToShow / CAFFEINE_HALF_LIFE_HOURS);\n    const endY = height * 0.15 + (height * 0.7) * (1 - endDecayFactor);\n\n    const cp1x = width * 0.02;\n    const cp1y = height * 0.1;\n    const cp2x = width * 0.12;\n    const cp2y = height * 0.05;\n\n    const cp3x = width * 0.35;\n    const cp3y = height * 0.35;\n\n    const pathStr = `M ${startX} ${startY} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${peakX} ${peakY} S ${cp3x} ${cp3y}, ${endX} ${endY}`;\n    const areaStr = `${pathStr} L ${endX} ${height} L ${startX} ${height} Z`;\n\n    const date = new Date(entry.timestamp);\n    const timeLabel = date.toLocaleTimeString(\"en-US\", {\n      hour: \"numeric\",\n      minute: \"2-digit\",\n    });\n\n    const startLabel = new Date(entryTime.getTime() - 1000 * 60 * 60).toLocaleTimeString(\"en-US\", { hour: \"numeric\" });\n    const endLabel = new Date(entryTime.getTime() + hoursToShow * 1000 * 60 * 60).toLocaleTimeString(\"en-US\", { hour: \"numeric\" });\n    \n    const midHours = [2, 4, 6, 8, 10];\n    const labels = midHours\n      .filter(h => h < hoursToShow)\n      .map(h => ({\n        x: (h / hoursToShow) * width,\n        label: new Date(entryTime.getTime() + h * 1000 * 60 * 60).toLocaleTimeString(\"en-US\", { hour: \"numeric\" }),\n      }));\n\n    return {\n      path: pathStr,\n      area: areaStr,\n      peak: { x: peakX, y: peakY },\n      peakTimeLabel: timeLabel,\n      timeLabels: [\n        { x: 0, label: startLabel },\n        ...labels,\n        { x: width, label: endLabel },\n      ],\n    };\n  }, [entry, height, width]);\n\n  return { width, height, path, area, peak, peakTimeLabel, curveColor, caffeineStats, timeLabels };\n}\n\nexport function CaffeineLogPopup({\n  visible,\n  entry,\n  onClose,\n  onEdit,\n  onDuplicate,\n  onDelete,\n}: CaffeineLogPopupProps) {\n  const { theme, isDark } = useTheme();\n  const insets = useSafeAreaInsets();\n  const sheetHeight = Math.min(SHEET_MAX_HEIGHT, SCREEN_HEIGHT - 40);\n  const translateY = useSharedValue(sheetHeight);\n\n  const curveColor = theme.darkBrown2; // matches home graph stroke color\n  const areaStart = isDark ? theme.backgroundTertiary : theme.accentGold + \"1A\";\n  const areaEnd = isDark ? theme.backgroundSecondary : theme.accentGold + \"0D\";\n\n  const { width, height, path, area, peak, peakTimeLabel, caffeineStats, timeLabels } = useDecayPath(entry, curveColor);\n  const startY = useSharedValue(0);\n\n  useEffect(() => {\n    if (visible) {\n      translateY.value = withSpring(0);\n    } else {\n      translateY.value = sheetHeight;\n    }\n  }, [visible, translateY, sheetHeight]);\n\n  const closeSheet = () => {\n    translateY.value = withTiming(sheetHeight, { duration: 180 }, () => {\n      runOnJS(onClose)();\n    });\n  };\n\n  const panGesture = Gesture.Pan()\n    .onStart(() => {\n      startY.value = translateY.value;\n    })\n    .onUpdate((event) => {\n      const next = startY.value + event.translationY;\n      translateY.value = Math.min(Math.max(0, next), sheetHeight);\n    })\n    .onEnd((event) => {\n      const shouldClose = translateY.value > sheetHeight * 0.5 || event.velocityY > 1200;\n      if (shouldClose) {\n        translateY.value = withTiming(sheetHeight, { duration: 180 }, () => {\n          runOnJS(onClose)();\n        });\n      } else {\n        translateY.value = withSpring(0, { damping: 16, stiffness: 200 });\n      }\n    });\n\n  const sheetStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: translateY.value }],\n  }));\n\n  if (!visible || !entry) return null;\n\n  return (\n    <Modal\n      visible={visible}\n      transparent\n      animationType=\"fade\"\n      statusBarTranslucent\n      onRequestClose={onClose}\n    >\n      <GestureHandlerRootView style={{ flex: 1 }}>\n      <View style={styles.overlay}>\n        <Pressable style={styles.backdrop} onPress={onClose} />\n\n        <GestureDetector gesture={panGesture}>\n          <Animated.View style={[styles.sheetContainer, sheetStyle]}>\n            <Animated.View\n              style={[\n                styles.sheet,\n                {\n                  backgroundColor: theme.backgroundRoot,\n                  maxHeight: sheetHeight,\n                  paddingBottom: Spacing[\"2xl\"] + insets.bottom,\n                },\n              ]}\n            >\n              <View style={styles.handle} />\n\n              <ScrollView\n                showsVerticalScrollIndicator={false}\n                contentContainerStyle={{ paddingBottom: Spacing.lg }}\n              >\n                {/* Header */}\n                <View style={styles.headerRow}>\n                  <View style={[styles.iconWrap, { backgroundColor: theme.backgroundSecondary }]}>\n                    {entry.imageUri ? (\n                      <Image\n                        source={{ uri: entry.imageUri }}\n                        style={styles.icon}\n                        resizeMode=\"cover\"\n                      />\n                    ) : (\n                      <Image\n                        source={require(\"@/assets/images/icon.png\")}\n                        style={styles.icon}\n                        resizeMode=\"cover\"\n                      />\n                    )}\n                  </View>\n                  <View style={styles.headerTextWrap}>\n                    <Text style={[styles.mutedText, { color: theme.mutedGrey }]}>\n                      You drank {entry.servingSize} {entry.servingSize === 1 ? \"cup\" : \"cups\"} of\n                    </Text>\n                    <Text style={[styles.title, { color: theme.text }]}>{entry.name}</Text>\n                  </View>\n                </View>\n\n                {/* Graph */}\n                <View style={styles.graphWrap}>\n                  <Svg width={width} height={height + 30}>\n                    <Defs>\n                      <LinearGradient id=\"decayArea\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\n                        <Stop offset=\"0\" stopColor={areaStart} stopOpacity=\"0.6\" />\n                        <Stop offset=\"1\" stopColor={areaEnd} stopOpacity=\"0.1\" />\n                      </LinearGradient>\n                    </Defs>\n                    <Path d={area} fill=\"url(#decayArea)\" />\n                    <Path d={path} stroke={curveColor} strokeWidth={3} fill=\"none\" />\n\n                    {/* Peak marker */}\n                    <Circle cx={peak.x} cy={peak.y} r={6} fill={theme.danger} />\n                    <SvgText\n                      x={peak.x}\n                      y={peak.y - 10}\n                      fontSize={12}\n                      fill={theme.danger}\n                      textAnchor=\"middle\"\n                    >\n                      {peakTimeLabel}\n                    </SvgText>\n\n                    {/* X-axis time labels */}\n                    {timeLabels.map((item, idx) => (\n                      <SvgText\n                        key={idx}\n                        x={item.x}\n                        y={height + 20}\n                        fontSize={11}\n                        fill={theme.mutedGrey}\n                        textAnchor={idx === 0 ? \"start\" : idx === timeLabels.length - 1 ? \"end\" : \"middle\"}\n                      >\n                        {item.label}\n                      </SvgText>\n                    ))}\n                  </Svg>\n                  <View style={styles.graphRightText}>\n                    <Text style={[styles.addsText, { color: theme.darkBrown }]}>adds {caffeineStats.currentMg} mg</Text>\n                    <Text style={[styles.nowText, { color: theme.mutedGrey }]}>now</Text>\n                  </View>\n                  {/* Start/End time labels */}\n                  <View style={styles.graphTimeRow}>\n                    <Text style={[styles.graphTimeLabel, { color: theme.mutedGrey }]}>{caffeineStats.peakTimeLabel}</Text>\n                    <Text style={[styles.graphTimeLabel, { color: theme.mutedGrey }]}>{caffeineStats.currentTimeLabel}</Text>\n                  </View>\n                </View>\n\n                {/* Breakdown */}\n                <View style={styles.section}>\n                  <Text style={[styles.sectionTitle, { color: theme.text }]}>\n                    Drink contribution to caffeine levels\n                  </Text>\n                  <View style={[styles.divider, { borderBottomColor: theme.divider }]} />\n                  <Row label={`At peak (${caffeineStats.peakTimeLabel})`} value={`${caffeineStats.peakMg} mg`} themeColor={theme} />\n                  <Row label=\"Now\" value={`${caffeineStats.currentMg} mg`} themeColor={theme} />\n                  <Row label=\"In total (over time)\" value={`${caffeineStats.totalMg} mg`} themeColor={theme} />\n                </View>\n\n                {/* Actions */}\n                <View style={styles.actionsRow}>\n                  <ActionButton\n                    label=\"Edit\"\n                    icon=\"edit-3\"\n                    onPress={() => onEdit?.(entry)}\n                    themeColor={theme.text}\n                    bg={theme.backgroundSecondary}\n                  />\n                  <ActionButton\n                    label=\"Duplicate\"\n                    icon=\"copy\"\n                    onPress={() => onDuplicate?.(entry)}\n                    themeColor={theme.text}\n                    bg={theme.backgroundSecondary}\n                  />\n                  <ActionButton\n                    label=\"Delete\"\n                    icon=\"trash\"\n                    onPress={() => onDelete?.(entry)}\n                    themeColor={theme.danger}\n                    bg={theme.backgroundSecondary}\n                  />\n                </View>\n              </ScrollView>\n            </Animated.View>\n          </Animated.View>\n        </GestureDetector>\n      </View>\n      </GestureHandlerRootView>\n    </Modal>\n  );\n}\n\ntype RowProps = {\n  label: string;\n  value: string;\n  themeColor: any;\n};\n\nfunction Row({ label, value, themeColor }: RowProps) {\n  return (\n    <View style={styles.row}>\n      <Text style={[styles.rowLabel, { color: themeColor.text }]}>{label}</Text>\n      <Text style={[styles.rowValue, { color: themeColor.text }]}>{value}</Text>\n    </View>\n  );\n}\n\ntype ActionButtonProps = {\n  label: string;\n  icon: any;\n  onPress?: () => void;\n  themeColor: string;\n  bg: string;\n};\n\nfunction ActionButton({ label, icon, onPress, themeColor, bg }: ActionButtonProps) {\n  return (\n    <Pressable style={[styles.actionButton, { backgroundColor: bg }]} onPress={onPress}>\n      <Feather name={icon} size={18} color={themeColor} />\n      <Text style={[styles.actionLabel, { color: themeColor }]}>{label}</Text>\n    </Pressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    flex: 1,\n    justifyContent: \"flex-end\",\n  },\n  backdrop: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: \"rgba(0,0,0,0.35)\",\n  },\n  sheetContainer: {\n    position: \"absolute\",\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n  sheet: {\n    borderTopLeftRadius: 20,\n    borderTopRightRadius: 20,\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing[\"3xl\"],\n    paddingTop: Spacing.lg,\n  },\n  handle: {\n    alignSelf: \"center\",\n    width: 42,\n    height: 4,\n    borderRadius: 2,\n    backgroundColor: \"rgba(255,255,255,0.35)\",\n    marginBottom: Spacing.lg,\n  },\n  headerRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    marginBottom: Spacing.lg,\n  },\n  iconWrap: {\n    width: 52,\n    height: 52,\n    borderRadius: 14,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    marginRight: Spacing.md,\n    overflow: \"hidden\",\n  },\n  icon: {\n    width: 52,\n    height: 52,\n    borderRadius: 14,\n  },\n  headerTextWrap: {\n    flex: 1,\n  },\n  mutedText: {\n    fontSize: 14,\n    fontWeight: \"500\",\n  },\n  title: {\n    fontSize: 22,\n    fontWeight: \"800\",\n    marginTop: 2,\n  },\n  graphWrap: {\n    marginBottom: Spacing.lg,\n  },\n  graphRightText: {\n    position: \"absolute\",\n    right: 0,\n    top: 16,\n    alignItems: \"flex-end\",\n  },\n  addsText: {\n    fontSize: 20,\n    fontWeight: \"800\",\n  },\n  nowText: {\n    fontSize: 14,\n    marginTop: 2,\n  },\n  section: {\n    marginBottom: Spacing.lg,\n  },\n  sectionTitle: {\n    fontSize: 16,\n    fontWeight: \"700\",\n    marginBottom: Spacing.sm,\n  },\n  divider: {\n    borderBottomWidth: StyleSheet.hairlineWidth,\n    marginBottom: Spacing.md,\n  },\n  row: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingVertical: Spacing.xs,\n  },\n  rowLabel: {\n    fontSize: 14,\n  },\n  rowValue: {\n    fontSize: 14,\n    fontWeight: \"800\",\n  },\n  actionsRow: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    gap: Spacing.sm,\n  },\n  actionButton: {\n    flex: 1,\n    height: 64,\n    borderRadius: 14,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: 4,\n  },\n  actionLabel: {\n    fontSize: 13,\n    fontWeight: \"600\",\n  },\n  graphTimeRow: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    marginTop: Spacing.xs,\n  },\n  graphTimeLabel: {\n    fontSize: 11,\n  },\n});\n\n","path":null,"size_bytes":16129,"size_tokens":null},"components/DrinkTimelineItem.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Pressable, Alert } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\nimport type { DrinkEntry } from \"@/store/caffeineStore\";\n\ninterface DrinkTimelineItemProps {\n  entry: DrinkEntry;\n  onDelete: () => void;\n  onEdit?: () => void;\n  showDate?: boolean;\n}\n\nexport function DrinkTimelineItem({\n  entry,\n  onDelete,\n  onEdit,\n  showDate = false,\n}: DrinkTimelineItemProps) {\n  const { theme } = useTheme();\n\n  const formatTime = () => {\n    const date = new Date(entry.timestamp);\n    return date.toLocaleTimeString(\"en-US\", {\n      hour: \"numeric\",\n      minute: \"2-digit\",\n      hour12: true,\n    });\n  };\n\n  const handleDelete = () => {\n    Alert.alert(\n      \"Delete Drink\",\n      `Remove ${entry.name} from your log?`,\n      [\n        { text: \"Cancel\", style: \"cancel\" },\n        {\n          text: \"Delete\",\n          style: \"destructive\",\n          onPress: onDelete,\n        },\n      ],\n    );\n  };\n\n  const getCategoryIcon = (): keyof typeof Feather.glyphMap => {\n    switch (entry.category) {\n      case \"coffee\":\n        return \"coffee\";\n      case \"tea\":\n        return \"droplet\";\n      case \"energy\":\n        return \"zap\";\n      case \"soda\":\n        return \"droplet\";\n      case \"chocolate\":\n        return \"square\";\n      default:\n        return \"circle\";\n    }\n  };\n\n  return (\n    <View style={styles.container}>\n      <Pressable\n        onPress={onEdit}\n        style={[\n          styles.itemContainer,\n          { backgroundColor: theme.backgroundDefault },\n        ]}\n      >\n        <View style={styles.timeColumn}>\n          <ThemedText type=\"small\" muted>\n            {formatTime()}\n          </ThemedText>\n        </View>\n        <View style={styles.iconContainer}>\n          <Feather\n            name={getCategoryIcon()}\n            size={18}\n            color={Colors.light.accent}\n          />\n        </View>\n        <View style={styles.contentColumn}>\n          <ThemedText type=\"body\" style={styles.drinkName}>\n            {entry.name}\n          </ThemedText>\n          <ThemedText type=\"caption\" muted>\n            {entry.servingSize}ml\n          </ThemedText>\n        </View>\n        <View style={styles.caffeineColumn}>\n          <ThemedText\n            type=\"body\"\n            style={[styles.caffeineAmount, { color: Colors.light.accent }]}\n          >\n            {entry.caffeineAmount}\n          </ThemedText>\n          <ThemedText type=\"caption\" muted>\n            mg\n          </ThemedText>\n        </View>\n        <Pressable\n          onPress={(e) => {\n            e.stopPropagation();\n            handleDelete();\n          }}\n          style={styles.deleteIconButton}\n          hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}\n        >\n          <Feather name=\"trash-2\" size={16} color={Colors.light.danger} />\n        </Pressable>\n      </Pressable>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    marginBottom: Spacing.sm,\n    overflow: \"hidden\",\n    borderRadius: BorderRadius.sm,\n  },\n  itemContainer: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.md,\n  },\n  timeColumn: {\n    width: 60,\n  },\n  iconContainer: {\n    width: 36,\n    height: 36,\n    borderRadius: 18,\n    backgroundColor: `${Colors.light.accent}20`,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  contentColumn: {\n    flex: 1,\n  },\n  drinkName: {\n    fontWeight: \"500\",\n    marginBottom: 2,\n  },\n  caffeineColumn: {\n    alignItems: \"flex-end\",\n  },\n  caffeineAmount: {\n    fontWeight: \"600\",\n  },\n  deleteIconButton: {\n    padding: Spacing.xs,\n    marginLeft: Spacing.sm,\n  },\n});\n","path":null,"size_bytes":3854,"size_tokens":null},"components/EditDrinkModal.tsx":{"content":"import React, { useState, useEffect } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Modal,\n  TextInput,\n  Pressable,\n  ScrollView,\n  Dimensions,\n  Platform,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { BlurView } from \"expo-blur\";\nimport Animated, {\n  FadeIn,\n  SlideInDown,\n} from \"react-native-reanimated\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { useCaffeineStore, DrinkEntry } from \"@/store/caffeineStore\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\n\nconst { height: SCREEN_HEIGHT } = Dimensions.get(\"window\");\n\ninterface EditDrinkModalProps {\n  visible: boolean;\n  entry: DrinkEntry | null;\n  onClose: () => void;\n}\n\nexport default function EditDrinkModal({ visible, entry, onClose }: EditDrinkModalProps) {\n  const { theme, isDark } = useTheme();\n  const insets = useSafeAreaInsets();\n  const { updateEntry, getAllDrinks } = useCaffeineStore();\n\n  const [servingSize, setServingSize] = useState<string>(\"\");\n  const [caffeineAmount, setCaffeineAmount] = useState<string>(\"\");\n  const [notes, setNotes] = useState<string>(\"\");\n\n  useEffect(() => {\n    if (entry) {\n      setServingSize(entry.servingSize.toString());\n      setCaffeineAmount(entry.caffeineAmount.toString());\n      setNotes(entry.notes || \"\");\n    }\n  }, [entry]);\n\n  const handleSave = () => {\n    if (!entry) return;\n\n    const newServingSize = parseInt(servingSize) || entry.servingSize;\n    const newCaffeineAmount = parseInt(caffeineAmount) || entry.caffeineAmount;\n\n    updateEntry(entry.id, {\n      servingSize: newServingSize,\n      caffeineAmount: newCaffeineAmount,\n      notes: notes.trim() || undefined,\n    });\n\n    onClose();\n  };\n\n  const handleClose = () => {\n    onClose();\n  };\n\n  if (!entry) return null;\n\n  return (\n    <Modal\n      visible={visible}\n      transparent\n      animationType=\"none\"\n      statusBarTranslucent\n      onRequestClose={handleClose}\n    >\n      <View style={styles.overlay}>\n        <Pressable style={styles.backdrop} onPress={handleClose} />\n        <Animated.View\n          entering={SlideInDown.springify().damping(20)}\n          style={[\n            styles.modalContainer,\n            {\n              backgroundColor: theme.backgroundRoot,\n              paddingBottom: insets.bottom + Spacing.lg,\n              maxHeight: SCREEN_HEIGHT * 0.7,\n            },\n          ]}\n        >\n          <View style={styles.handle} />\n\n          <View style={styles.header}>\n            <ThemedText type=\"h3\">Edit Drink</ThemedText>\n            <Pressable onPress={handleClose} style={styles.closeButton}>\n              <Feather name=\"x\" size={24} color={theme.text} />\n            </Pressable>\n          </View>\n\n          <ScrollView\n            style={styles.scrollContent}\n            showsVerticalScrollIndicator={false}\n          >\n            <ThemedView elevation={1} style={styles.drinkCard}>\n              <View style={styles.drinkHeader}>\n                <View style={styles.drinkIconLarge}>\n                  <Feather\n                    name={getCategoryIcon(entry.category)}\n                    size={28}\n                    color={Colors.light.accent}\n                  />\n                </View>\n                <View style={styles.drinkInfo}>\n                  <ThemedText type=\"h4\">{entry.name}</ThemedText>\n                  <ThemedText type=\"small\" muted>\n                    {entry.category}\n                  </ThemedText>\n                </View>\n              </View>\n\n              <View style={styles.inputSection}>\n                <ThemedText type=\"small\" muted style={styles.inputLabel}>\n                  SERVING SIZE (ml)\n                </ThemedText>\n                <View\n                  style={[\n                    styles.inputBox,\n                    { backgroundColor: theme.backgroundDefault },\n                  ]}\n                >\n                  <TextInput\n                    style={[styles.input, { color: theme.text }]}\n                    value={servingSize}\n                    onChangeText={setServingSize}\n                    keyboardType=\"numeric\"\n                    placeholder=\"Enter size in ml\"\n                    placeholderTextColor={theme.textMuted}\n                  />\n                  <ThemedText type=\"small\" muted>\n                    ml\n                  </ThemedText>\n                </View>\n              </View>\n\n              <View style={styles.inputSection}>\n                <ThemedText type=\"small\" muted style={styles.inputLabel}>\n                  CAFFEINE AMOUNT (mg)\n                </ThemedText>\n                <View\n                  style={[\n                    styles.inputBox,\n                    { backgroundColor: theme.backgroundDefault },\n                  ]}\n                >\n                  <TextInput\n                    style={[styles.input, { color: theme.text }]}\n                    value={caffeineAmount}\n                    onChangeText={setCaffeineAmount}\n                    keyboardType=\"numeric\"\n                    placeholder=\"Enter caffeine in mg\"\n                    placeholderTextColor={theme.textMuted}\n                  />\n                  <ThemedText type=\"small\" muted>\n                    mg\n                  </ThemedText>\n                </View>\n              </View>\n\n              <View style={styles.inputSection}>\n                <ThemedText type=\"small\" muted style={styles.inputLabel}>\n                  NOTES (optional)\n                </ThemedText>\n                <View\n                  style={[\n                    styles.inputBox,\n                    { backgroundColor: theme.backgroundDefault },\n                  ]}\n                >\n                  <TextInput\n                    style={[styles.input, { color: theme.text }]}\n                    value={notes}\n                    onChangeText={setNotes}\n                    placeholder=\"Add a note...\"\n                    placeholderTextColor={theme.textMuted}\n                    multiline\n                  />\n                </View>\n              </View>\n            </ThemedView>\n\n            <View style={styles.buttonRow}>\n              <Pressable\n                onPress={handleClose}\n                style={[\n                  styles.button,\n                  styles.cancelButton,\n                  { backgroundColor: theme.backgroundDefault },\n                ]}\n              >\n                <ThemedText type=\"body\" style={styles.cancelButtonText}>\n                  Cancel\n                </ThemedText>\n              </Pressable>\n              <Pressable\n                onPress={handleSave}\n                style={[\n                  styles.button,\n                  styles.saveButton,\n                  { backgroundColor: Colors.light.accent },\n                ]}\n              >\n                <ThemedText type=\"body\" style={styles.saveButtonText}>\n                  Save Changes\n                </ThemedText>\n              </Pressable>\n            </View>\n          </ScrollView>\n        </Animated.View>\n      </View>\n    </Modal>\n  );\n}\n\nfunction getCategoryIcon(category: string): keyof typeof Feather.glyphMap {\n  switch (category) {\n    case \"coffee\":\n      return \"coffee\";\n    case \"tea\":\n      return \"droplet\";\n    case \"energy\":\n      return \"zap\";\n    case \"soda\":\n      return \"droplet\";\n    case \"chocolate\":\n      return \"square\";\n    default:\n      return \"circle\";\n  }\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    flex: 1,\n    justifyContent: \"flex-end\",\n  },\n  backdrop: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: \"rgba(0,0,0,0.35)\",\n  },\n  modalContainer: {\n    borderTopLeftRadius: BorderRadius.xl,\n    borderTopRightRadius: BorderRadius.xl,\n    padding: Spacing.lg,\n    paddingTop: Spacing.sm,\n  },\n  handle: {\n    width: 40,\n    height: 4,\n    backgroundColor: Colors.light.divider,\n    borderRadius: 2,\n    alignSelf: \"center\",\n    marginBottom: Spacing.md,\n  },\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    marginBottom: Spacing.lg,\n  },\n  closeButton: {\n    padding: Spacing.xs,\n  },\n  scrollContent: {\n    flex: 1,\n  },\n  drinkCard: {\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    marginBottom: Spacing.lg,\n  },\n  drinkHeader: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    marginBottom: Spacing.lg,\n    gap: Spacing.md,\n  },\n  drinkIconLarge: {\n    width: 56,\n    height: 56,\n    borderRadius: 28,\n    backgroundColor: `${Colors.light.accent}20`,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  drinkInfo: {\n    flex: 1,\n  },\n  inputSection: {\n    marginBottom: Spacing.md,\n  },\n  inputLabel: {\n    marginBottom: Spacing.xs,\n    fontWeight: \"600\",\n  },\n  inputBox: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.sm,\n  },\n  input: {\n    flex: 1,\n    fontSize: 16,\n    paddingVertical: Spacing.xs,\n  },\n  buttonRow: {\n    flexDirection: \"row\",\n    gap: Spacing.md,\n    marginTop: Spacing.md,\n  },\n  button: {\n    flex: 1,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n  },\n  cancelButton: {},\n  saveButton: {},\n  cancelButtonText: {\n    fontWeight: \"600\",\n  },\n  saveButtonText: {\n    fontWeight: \"600\",\n    color: \"#FFFFFF\",\n  },\n});\n","path":null,"size_bytes":9523,"size_tokens":null},"screens/ArticleScreen.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Text, Pressable, ScrollView, Image } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation, useRoute, RouteProp } from \"@react-navigation/native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\nimport { HistoryStackParamList } from \"@/navigation/HistoryStackNavigator\";\n\ntype ArticleRouteProp = RouteProp<HistoryStackParamList, \"Article\">;\n\nexport default function ArticleScreen() {\n  const { theme } = useTheme();\n  const navigation = useNavigation();\n  const route = useRoute<ArticleRouteProp>();\n  const insets = useSafeAreaInsets();\n  const { article } = route.params;\n\n  return (\n    <View style={[styles.container, { backgroundColor: theme.backgroundRoot }]}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.md }]}>\n        <Pressable\n          onPress={() => navigation.goBack()}\n          style={styles.backButton}\n          hitSlop={{ top: 12, bottom: 12, left: 12, right: 12 }}\n        >\n          <Feather name=\"arrow-left\" size={24} color={theme.text} />\n        </Pressable>\n        <Text style={[styles.headerTitle, { color: theme.text }]} numberOfLines={1}>\n          Information Hub\n        </Text>\n        <View style={styles.headerSpacer} />\n      </View>\n\n      <ScrollView\n        style={styles.scrollView}\n        contentContainerStyle={styles.scrollContent}\n        showsVerticalScrollIndicator={false}\n      >\n        <Image source={{ uri: article.image }} style={styles.articleImage} />\n        <Text style={[styles.title, { color: theme.text }]}>{article.title}</Text>\n        \n        <Text style={[styles.content, { color: theme.text }]}>\n          {article.content}\n        </Text>\n\n        <View style={[styles.referencesContainer, { backgroundColor: theme.backgroundSecondary }]}>\n          <Text style={[styles.referencesTitle, { color: theme.text }]}>References</Text>\n          {article.references.map((ref, idx) => (\n            <Text key={idx} style={[styles.referenceItem, { color: theme.mutedGrey }]}>\n              {idx + 1}. {ref}\n            </Text>\n          ))}\n        </View>\n      </ScrollView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing.lg,\n  },\n  backButton: {\n    width: 24,\n  },\n  headerTitle: {\n    fontSize: 18,\n    fontWeight: \"600\",\n    textAlign: \"center\",\n    flex: 1,\n  },\n  headerSpacer: {\n    width: 24,\n  },\n  scrollView: {\n    flex: 1,\n  },\n  scrollContent: {\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing[\"3xl\"],\n  },\n  articleImage: {\n    width: \"100%\",\n    height: 200,\n    borderRadius: BorderRadius.md,\n    marginBottom: Spacing.lg,\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: \"700\",\n    marginBottom: Spacing.xl,\n    lineHeight: 32,\n  },\n  content: {\n    fontSize: 16,\n    lineHeight: 26,\n    marginBottom: Spacing.xl,\n  },\n  referencesContainer: {\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.md,\n  },\n  referencesTitle: {\n    fontSize: 16,\n    fontWeight: \"600\",\n    marginBottom: Spacing.md,\n  },\n  referenceItem: {\n    fontSize: 14,\n    lineHeight: 22,\n    marginBottom: Spacing.sm,\n  },\n});\n","path":null,"size_bytes":3440,"size_tokens":null},"store/themeStore.ts":{"content":"import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from \"react\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\n\nexport type ThemeMode = \"light\" | \"dark\" | \"system\";\n\nconst STORAGE_KEY = \"@caffi_theme\";\n\ninterface ThemeContextType {\n  themeMode: ThemeMode;\n  setThemeMode: (mode: ThemeMode) => void;\n  toggleTheme: () => void;\n  isInitialized: boolean;\n}\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined);\n\nexport function ThemeProvider({ children }: { children: ReactNode }) {\n  const [themeMode, setThemeModeState] = useState<ThemeMode>(\"light\");\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  useEffect(() => {\n    const loadTheme = async () => {\n      try {\n        const storedTheme = await AsyncStorage.getItem(STORAGE_KEY);\n        if (storedTheme && (storedTheme === \"light\" || storedTheme === \"dark\" || storedTheme === \"system\")) {\n          setThemeModeState(storedTheme as ThemeMode);\n        }\n      } catch (error) {\n        console.error(\"Error loading theme:\", error);\n      }\n      setIsInitialized(true);\n    };\n    loadTheme();\n  }, []);\n\n  const setThemeMode = useCallback((mode: ThemeMode) => {\n    console.log(\"Setting theme mode to:\", mode);\n    setThemeModeState(mode);\n    AsyncStorage.setItem(STORAGE_KEY, mode).catch((error) => {\n      console.error(\"Error saving theme:\", error);\n    });\n  }, []);\n\n  const toggleTheme = useCallback(() => {\n    const newMode = themeMode === \"light\" ? \"dark\" : \"light\";\n    setThemeMode(newMode);\n  }, [themeMode, setThemeMode]);\n\n  return React.createElement(\n    ThemeContext.Provider,\n    { value: { themeMode, setThemeMode, toggleTheme, isInitialized } },\n    children\n  );\n}\n\nexport function useThemeStore(): ThemeContextType {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    return {\n      themeMode: \"light\",\n      setThemeMode: () => {},\n      toggleTheme: () => {},\n      isInitialized: false,\n    };\n  }\n  return context;\n}\n","path":null,"size_bytes":2017,"size_tokens":null},"components/RecommendationCards.tsx":{"content":"import React, { useState } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Text,\n  ScrollView,\n  Pressable,\n  Modal,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { Spacing, BorderRadius, Shadows } from \"@/constants/theme\";\nimport { RecommendationResult } from \"@/utils/recommendationEngine\";\nimport { InfoCardResult } from \"@/utils/infocardLogic\";\nimport { useTheme } from \"@/hooks/useTheme\";\n\ninterface RecommendationCardsProps {\n  recommendations?: RecommendationResult;\n  infoCard?: InfoCardResult;\n}\n\ninterface CardData {\n  id: string;\n  icon: keyof typeof Feather.glyphMap;\n  title: string;\n  value: string;\n  subtitle: string;\n  accentColor: string;\n  reasoning: string;\n}\n\nexport function RecommendationCards({\n  recommendations,\n  infoCard,\n}: RecommendationCardsProps) {\n  const { theme, isDark } = useTheme();\n  const [modalVisible, setModalVisible] = useState(false);\n  const [selectedCard, setSelectedCard] = useState<CardData | null>(null);\n\n  const accentColor = theme.accentGold;\n\n  // Format time helper\n  const formatTime = (date: Date): string => {\n    const hours = date.getHours();\n    const minutes = date.getMinutes();\n    const ampm = hours >= 12 ? \"PM\" : \"AM\";\n    const hour12 = hours % 12 || 12;\n    const minStr = minutes.toString().padStart(2, \"0\");\n    return `${hour12}:${minStr} ${ampm}`;\n  };\n  \n  // Use new infoCard if available, otherwise fall back to old recommendations\n  const cards: CardData[] = infoCard\n    ? [\n        {\n          id: \"focus\",\n          icon: \"target\",\n          title: \"Focus Dose\",\n          value:\n            infoCard.status === \"NO_MORE_CAFFEINE_TODAY\"\n              ? \"Oops \"\n              : `${infoCard.focusDose || 0} mg`,\n          subtitle:\n            infoCard.status === \"NO_MORE_CAFFEINE_TODAY\"\n              ? \"No more caffeine today\"\n              : \"Recommended caffeine dose\",\n          accentColor,\n          reasoning:\n            infoCard.status === \"NO_MORE_CAFFEINE_TODAY\"\n              ? \"No more caffeine recommended today.\"\n              : `Take ${infoCard.focusDose}mg for optimal focus without disrupting sleep.`,\n        },\n        {\n          id: \"bestTime\",\n          icon: \"clock\",\n          title: \"Best Time\",\n          value:\n            infoCard.status === \"NO_MORE_CAFFEINE_TODAY\"\n              ? \"Oops \"\n              : `${formatTime(infoCard.bestTimeStart || new Date())}  ${formatTime(infoCard.bestTimeEnd || new Date())}`,\n          subtitle:\n            infoCard.status === \"NO_MORE_CAFFEINE_TODAY\"\n              ? \"No safe window today\"\n              : \"optimal intake window\",\n          accentColor,\n          reasoning:\n            infoCard.status === \"NO_MORE_CAFFEINE_TODAY\"\n              ? \"Peak safe levels already reached today.\"\n              : \"Peak-aware timing for maximum focus while preserving sleep quality.\",\n        },\n      ]\n    : recommendations\n    ? [\n        {\n          id: \"focus\",\n          icon: \"target\",\n          title: \"Focus Dose\",\n          value:\n            recommendations.noSafeDose || recommendations.focusDoseMg === 0\n              ? \"None\"\n              : `${recommendations.focusDoseMg} mg`,\n          subtitle: recommendations.noSafeDose\n            ? \"Limit reached\"\n            : \"Small boost for concentration\",\n          accentColor,\n          reasoning: recommendations.focusDoseReasoning,\n        },\n        {\n          id: \"bestTime\",\n          icon: \"clock\",\n          title: \"Best Time\",\n          value:\n            recommendations.noSafeDose\n              ? \"N/A\"\n              : `${recommendations.bestWindowStart}  ${recommendations.bestWindowEnd}`,\n          subtitle: \"Your ideal caffeine window\",\n          accentColor,\n          reasoning: recommendations.bestTimeReasoning,\n        },\n        {\n          id: \"cutoff\",\n          icon: \"alert-circle\",\n          title: \"Cutoff Time\",\n          value: `After ${recommendations.cutoffTime}`,\n          subtitle: \"Avoid for best sleep\",\n          accentColor,\n          reasoning: recommendations.cutoffReasoning,\n        },\n      ]\n    : [];\n\n  const handleCardPress = (card: CardData) => {\n    setSelectedCard(card);\n    setModalVisible(true);\n  };\n\n  const isTwoCards = cards.length === 2;\n\n  return (\n    <>\n      <ScrollView\n        horizontal\n        showsHorizontalScrollIndicator={false}\n        contentContainerStyle={[styles.scrollContent, isTwoCards && styles.spacedContent]}\n        style={styles.scrollView}\n        scrollEnabled={!isTwoCards}\n      >\n        {cards.map((card) => (\n          <Pressable\n            key={card.id}\n            style={({ pressed }) => [\n              styles.card,\n              isTwoCards && styles.cardFlex,\n              { \n                borderLeftColor: card.accentColor,\n                backgroundColor: theme.backgroundSecondary,\n                shadowColor: isDark ? \"#000\" : \"#9E9E9E\",\n                shadowOpacity: isDark ? 0.3 : 0.25,\n                borderWidth: 1,\n                borderColor: isDark ? theme.divider : \"#E8E4DC\",\n              },\n              pressed && { opacity: 0.8, transform: [{ scale: 0.98 }] },\n            ]}\n            onPress={() => handleCardPress(card)}\n            accessibilityLabel={`${card.title}: ${card.value}. ${card.subtitle}`}\n            accessibilityRole=\"button\"\n          >\n            <View style={styles.cardHeader}>\n              <Feather name={card.icon} size={14} color={card.accentColor} />\n              <Text style={[styles.cardTitle, { color: theme.mutedGrey }]}>{card.title}</Text>\n            </View>\n            <Text style={[styles.cardValue, { color: theme.darkBrown }]} numberOfLines={1}>\n              {card.value}\n            </Text>\n            <Text style={[styles.cardSubtitle, { color: theme.mutedGrey }]} numberOfLines={1}>\n              {card.subtitle}\n            </Text>\n          </Pressable>\n        ))}\n      </ScrollView>\n\n      <Modal\n        visible={modalVisible}\n        transparent\n        animationType=\"fade\"\n        onRequestClose={() => setModalVisible(false)}\n      >\n        <Pressable\n          style={[styles.modalOverlay, { backgroundColor: isDark ? \"rgba(0, 0, 0, 0.7)\" : \"rgba(0, 0, 0, 0.5)\" }]}\n          onPress={() => setModalVisible(false)}\n        >\n          <View style={[styles.modalContent, { backgroundColor: theme.backgroundDefault, shadowColor: isDark ? \"#000\" : \"#000\" }]}>\n            {selectedCard && (\n              <>\n                <View style={styles.modalHeader}>\n                  <View\n                    style={[\n                      styles.modalIconContainer,\n                      { backgroundColor: selectedCard.accentColor + \"20\" },\n                    ]}\n                  >\n                    <Feather\n                      name={selectedCard.icon}\n                      size={24}\n                      color={selectedCard.accentColor}\n                    />\n                  </View>\n                  <Text style={[styles.modalTitle, { color: theme.darkBrown }]}>{selectedCard.title}</Text>\n                </View>\n                <Text style={[styles.modalValue, { color: theme.darkBrown }]}>{selectedCard.value}</Text>\n                <Text style={[styles.modalReasoning, { color: theme.mutedGrey }]}>{selectedCard.reasoning}</Text>\n                <Pressable\n                  style={[styles.reminderButton, { backgroundColor: theme.accentGold }]}\n                  onPress={() => setModalVisible(false)}\n                >\n                  <Feather name=\"bell\" size={16} color={theme.bg} />\n                  <Text style={[styles.reminderButtonText, { color: theme.bg }]}>Schedule reminder</Text>\n                </Pressable>\n              </>\n            )}\n          </View>\n        </Pressable>\n      </Modal>\n    </>\n  );\n}\n\nconst styles = StyleSheet.create({\n  scrollView: {\n    marginHorizontal: -Spacing.lg,\n  },\n  scrollContent: {\n    paddingHorizontal: Spacing.lg,\n    gap: Spacing.sm,\n  },\n  spacedContent: {\n    flex: 1,\n    justifyContent: \"center\",\n    gap: Spacing.md,\n  },\n  card: {\n    borderRadius: BorderRadius.sm,\n    padding: Spacing.sm,\n    minWidth: 120,\n    maxWidth: 140,\n    borderLeftWidth: 3,\n    shadowOffset: { width: 0, height: 2 },\n    shadowRadius: 4,\n    elevation: 2,\n  },\n  cardFlex: {\n    flex: 1,\n    minWidth: undefined,\n    maxWidth: \"48%\",\n  },\n  cardHeader: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: 4,\n    marginBottom: 2,\n  },\n  cardTitle: {\n    fontSize: 9,\n    fontWeight: \"500\",\n    textTransform: \"uppercase\",\n  },\n  cardValue: {\n    fontSize: 13,\n    fontWeight: \"700\",\n    marginBottom: 2,\n  },\n  cardSubtitle: {\n    fontSize: 9,\n  },\n  modalOverlay: {\n    flex: 1,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    padding: Spacing.xl,\n  },\n  modalContent: {\n    borderRadius: BorderRadius.md,\n    padding: Spacing.xl,\n    width: \"100%\",\n    maxWidth: 320,\n    shadowOffset: { width: 0, height: 6 },\n    shadowOpacity: 0.12,\n    shadowRadius: 12,\n    elevation: 6,\n  },\n  modalHeader: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n    marginBottom: Spacing.lg,\n  },\n  modalIconContainer: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  modalTitle: {\n    fontSize: 18,\n    fontWeight: \"600\",\n  },\n  modalValue: {\n    fontSize: 28,\n    fontWeight: \"700\",\n    marginBottom: Spacing.sm,\n  },\n  modalReasoning: {\n    fontSize: 14,\n    lineHeight: 20,\n    marginBottom: Spacing.xl,\n  },\n  reminderButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: Spacing.sm,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.sm,\n  },\n  reminderButtonText: {\n    fontWeight: \"600\",\n    fontSize: 14,\n  },\n});\n","path":null,"size_bytes":9770,"size_tokens":null},"eslint.config.js":{"content":"// https://docs.expo.dev/guides/using-eslint/\nconst { defineConfig } = require(\"eslint/config\");\nconst expoConfig = require(\"eslint-config-expo/flat\");\nconst eslintPluginPrettierRecommended = require(\"eslint-plugin-prettier/recommended\");\n\nmodule.exports = defineConfig([\n  expoConfig,\n  eslintPluginPrettierRecommended,\n  {\n    ignores: [\"dist/*\"],\n  },\n]);\n","path":null,"size_bytes":359,"size_tokens":null},"components/Button.tsx":{"content":"import React, { ReactNode } from \"react\";\nimport { StyleSheet, Pressable, ViewStyle, StyleProp } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { BorderRadius, Spacing, Colors } from \"@/constants/theme\";\n\ntype ButtonVariant = \"primary\" | \"secondary\" | \"tertiary\";\n\ninterface ButtonProps {\n  onPress?: () => void;\n  children: ReactNode;\n  style?: StyleProp<ViewStyle>;\n  disabled?: boolean;\n  variant?: ButtonVariant;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Button({\n  onPress,\n  children,\n  style,\n  disabled = false,\n  variant = \"primary\",\n}: ButtonProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    if (!disabled) {\n      scale.value = withSpring(0.98, springConfig);\n    }\n  };\n\n  const handlePressOut = () => {\n    if (!disabled) {\n      scale.value = withSpring(1, springConfig);\n    }\n  };\n\n  const getBackgroundColor = () => {\n    switch (variant) {\n      case \"primary\":\n        return Colors.light.accent;\n      case \"secondary\":\n        return \"transparent\";\n      case \"tertiary\":\n        return \"transparent\";\n      default:\n        return Colors.light.accent;\n    }\n  };\n\n  const getBorderColor = () => {\n    switch (variant) {\n      case \"secondary\":\n        return Colors.light.accent;\n      default:\n        return \"transparent\";\n    }\n  };\n\n  const getTextColor = () => {\n    switch (variant) {\n      case \"primary\":\n        return \"#FFFFFF\";\n      case \"secondary\":\n        return Colors.light.accent;\n      case \"tertiary\":\n        return Colors.light.accent;\n      default:\n        return \"#FFFFFF\";\n    }\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={disabled ? undefined : onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      disabled={disabled}\n      style={[\n        styles.button,\n        {\n          backgroundColor: getBackgroundColor(),\n          borderColor: getBorderColor(),\n          borderWidth: variant === \"secondary\" ? 1 : 0,\n          opacity: disabled ? 0.5 : 1,\n        },\n        style,\n        animatedStyle,\n      ]}\n    >\n      <ThemedText\n        type=\"body\"\n        style={[styles.buttonText, { color: getTextColor() }]}\n      >\n        {children}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    paddingHorizontal: Spacing.xl,\n  },\n  buttonText: {\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":3005,"size_tokens":null},"components/ScreenKeyboardAwareScrollView.tsx":{"content":"import { Platform, StyleSheet, View, ReactNode } from \"react-native\";\nimport {\n  KeyboardAwareScrollView,\n  KeyboardAwareScrollViewProps,\n} from \"react-native-keyboard-controller\";\nimport { SafeAreaView, useSafeAreaInsets } from \"react-native-safe-area-context\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useScreenInsets } from \"@/hooks/useScreenInsets\";\nimport { Spacing } from \"@/constants/theme\";\nimport { ScreenScrollView } from \"./ScreenScrollView\";\n\ninterface ScreenKeyboardAwareScrollViewProps extends KeyboardAwareScrollViewProps {\n  header?: ReactNode;\n}\n\nexport function ScreenKeyboardAwareScrollView({\n  children,\n  contentContainerStyle,\n  style,\n  keyboardShouldPersistTaps = \"handled\",\n  header,\n  ...scrollViewProps\n}: ScreenKeyboardAwareScrollViewProps) {\n  const { theme } = useTheme();\n  const { paddingTop, paddingBottom, scrollInsetBottom } = useScreenInsets();\n  const insets = useSafeAreaInsets();\n\n  /**\n   * KeyboardAwareScrollView isn't compatible with web (it relies on native APIs), so the code falls back to ScreenScrollView on web to avoid runtime errors.\n   */\n  if (Platform.OS === \"web\") {\n    return (\n      <ScreenScrollView\n        style={style}\n        contentContainerStyle={contentContainerStyle}\n        keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n        header={header}\n        {...scrollViewProps}\n      >\n        {children}\n      </ScreenScrollView>\n    );\n  }\n\n  return (\n    <View\n      style={[\n        styles.outerContainer,\n        { backgroundColor: theme.backgroundRoot },\n      ]}\n    >\n      <SafeAreaView\n        style={[\n          styles.safeArea,\n          {\n            paddingTop: insets.top,\n            paddingBottom: insets.bottom,\n          },\n        ]}\n        edges={[]}\n      >\n        {header}\n        <KeyboardAwareScrollView\n          style={[\n            styles.container,\n            style,\n          ]}\n          contentContainerStyle={[\n            {\n              paddingTop,\n              paddingBottom,\n            },\n            styles.contentContainer,\n            contentContainerStyle,\n          ]}\n          scrollIndicatorInsets={{ bottom: scrollInsetBottom }}\n          keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n          {...scrollViewProps}\n        >\n          {children}\n        </KeyboardAwareScrollView>\n      </SafeAreaView>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  outerContainer: {\n    flex: 1,\n  },\n  safeArea: {\n    flex: 1,\n  },\n  container: {\n    flex: 1,\n  },\n  contentContainer: {\n    paddingHorizontal: Spacing.xl,\n  },\n});\n","path":null,"size_bytes":2572,"size_tokens":null},"components/TimeToFinishModal.tsx":{"content":"import React, { useState, useEffect } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Modal,\n  Pressable,\n  useWindowDimensions,\n} from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  withTiming,\n  runOnJS,\n} from \"react-native-reanimated\";\nimport { Gesture, GestureDetector } from \"react-native-gesture-handler\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\n\nconst MODAL_HEIGHT = 220;\nconst SLIDER_WIDTH = 300;\nconst THUMB_SIZE = 32;\nconst MIN_MINUTES = 5;\nconst MAX_MINUTES = 60;\n\ninterface TimeToFinishModalProps {\n  visible: boolean;\n  onClose: () => void;\n  onSelectTime: (minutes: number) => void;\n  initialMinutes?: number;\n}\n\nexport function TimeToFinishModal({\n  visible,\n  onClose,\n  onSelectTime,\n  initialMinutes = 10,\n}: TimeToFinishModalProps) {\n  const { theme } = useTheme();\n  const insets = useSafeAreaInsets();\n  const { height: windowHeight } = useWindowDimensions();\n\n  const [minutes, setMinutes] = useState(initialMinutes);\n  \n  const translateY = useSharedValue(MODAL_HEIGHT);\n  const sliderPosition = useSharedValue(\n    ((initialMinutes - MIN_MINUTES) / (MAX_MINUTES - MIN_MINUTES)) * SLIDER_WIDTH\n  );\n  const startX = useSharedValue(0);\n\n  useEffect(() => {\n    if (visible) {\n      setMinutes(initialMinutes);\n      sliderPosition.value = ((initialMinutes - MIN_MINUTES) / (MAX_MINUTES - MIN_MINUTES)) * SLIDER_WIDTH;\n      translateY.value = MODAL_HEIGHT;\n      setTimeout(() => {\n        translateY.value = withSpring(0, { damping: 16, stiffness: 200 });\n      }, 50);\n    } else {\n      translateY.value = MODAL_HEIGHT;\n    }\n  }, [visible, initialMinutes, translateY, sliderPosition]);\n\n  const closeModal = (saveValue: boolean = true) => {\n    if (saveValue) {\n      onSelectTime(minutes);\n    }\n    translateY.value = withTiming(MODAL_HEIGHT, { duration: 200 }, () => {\n      runOnJS(onClose)();\n    });\n  };\n\n  const updateMinutes = (value: number) => {\n    setMinutes(value);\n  };\n\n  const sliderGesture = Gesture.Pan()\n    .onStart(() => {\n      startX.value = sliderPosition.value;\n    })\n    .onUpdate((event) => {\n      const newPosition = Math.max(0, Math.min(SLIDER_WIDTH, startX.value + event.translationX));\n      sliderPosition.value = newPosition;\n      \n      const progress = newPosition / SLIDER_WIDTH;\n      const newMinutes = Math.round(MIN_MINUTES + progress * (MAX_MINUTES - MIN_MINUTES));\n      runOnJS(updateMinutes)(newMinutes);\n    })\n    .onEnd(() => {\n      const progress = sliderPosition.value / SLIDER_WIDTH;\n      const snappedMinutes = Math.round(MIN_MINUTES + progress * (MAX_MINUTES - MIN_MINUTES));\n      const snappedPosition = ((snappedMinutes - MIN_MINUTES) / (MAX_MINUTES - MIN_MINUTES)) * SLIDER_WIDTH;\n      sliderPosition.value = withSpring(snappedPosition, { damping: 15, stiffness: 200 });\n    });\n\n  const sheetStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: translateY.value }],\n  }));\n\n  const thumbStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: sliderPosition.value }],\n  }));\n\n  const progressStyle = useAnimatedStyle(() => ({\n    width: sliderPosition.value + THUMB_SIZE / 2,\n  }));\n\n  if (!visible) return null;\n\n  return (\n    <Modal\n      visible={visible}\n      transparent\n      statusBarTranslucent\n      animationType=\"fade\"\n      onRequestClose={() => closeModal(true)}\n    >\n      <View style={styles.overlay}>\n        <Pressable style={styles.backdrop} onPress={() => closeModal(true)} />\n\n        <Animated.View\n          style={[\n            styles.modalContent,\n            sheetStyle,\n            {\n              backgroundColor: theme.backgroundRoot,\n              paddingBottom: insets.bottom + Spacing.lg,\n            },\n          ]}\n        >\n          <View style={styles.handleContainer}>\n            <View style={[styles.handle, { backgroundColor: Colors.light.accent }]} />\n          </View>\n\n          <View style={styles.content}>\n            <ThemedText type=\"h2\" style={styles.minutesText}>\n              {minutes} minutes\n            </ThemedText>\n\n            <View style={styles.sliderContainer}>\n              <View style={[styles.sliderTrack, { backgroundColor: theme.divider }]}>\n                <Animated.View\n                  style={[\n                    styles.sliderProgress,\n                    { backgroundColor: Colors.light.accent },\n                    progressStyle,\n                  ]}\n                />\n              </View>\n              \n              <GestureDetector gesture={sliderGesture}>\n                <Animated.View\n                  style={[\n                    styles.sliderThumb,\n                    {\n                      borderColor: Colors.light.accent,\n                      backgroundColor: theme.backgroundRoot,\n                    },\n                    thumbStyle,\n                  ]}\n                />\n              </GestureDetector>\n            </View>\n\n            <View style={styles.labelsRow}>\n              <ThemedText type=\"caption\" muted>{MIN_MINUTES} min</ThemedText>\n              <ThemedText type=\"caption\" muted>{MAX_MINUTES} min</ThemedText>\n            </View>\n          </View>\n        </Animated.View>\n      </View>\n    </Modal>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n  },\n  backdrop: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: \"rgba(0, 0, 0, 0.4)\",\n  },\n  modalContent: {\n    position: \"absolute\",\n    bottom: 0,\n    left: 0,\n    right: 0,\n    borderTopLeftRadius: BorderRadius.xl,\n    borderTopRightRadius: BorderRadius.xl,\n  },\n  handleContainer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing.md,\n  },\n  handle: {\n    width: 40,\n    height: 4,\n    borderRadius: 2,\n  },\n  content: {\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  minutesText: {\n    color: Colors.light.accent,\n    marginBottom: Spacing.xl,\n  },\n  sliderContainer: {\n    width: SLIDER_WIDTH + THUMB_SIZE,\n    height: THUMB_SIZE + 20,\n    justifyContent: \"center\",\n    paddingHorizontal: THUMB_SIZE / 2,\n  },\n  sliderTrack: {\n    position: \"absolute\",\n    left: THUMB_SIZE / 2,\n    right: THUMB_SIZE / 2,\n    height: 6,\n    borderRadius: 3,\n  },\n  sliderProgress: {\n    position: \"absolute\",\n    left: 0,\n    height: 6,\n    borderRadius: 3,\n  },\n  sliderThumb: {\n    position: \"absolute\",\n    left: 0,\n    width: THUMB_SIZE,\n    height: THUMB_SIZE,\n    borderRadius: THUMB_SIZE / 2,\n    borderWidth: 2,\n  },\n  labelsRow: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    width: SLIDER_WIDTH + THUMB_SIZE,\n    marginTop: Spacing.sm,\n  },\n});\n","path":null,"size_bytes":6799,"size_tokens":null}},"version":2}